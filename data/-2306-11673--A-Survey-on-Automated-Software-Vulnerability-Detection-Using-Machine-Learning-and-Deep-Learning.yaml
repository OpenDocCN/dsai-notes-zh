- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '类别: 未分类'
- en: 'date: 2024-09-06 19:38:53'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '日期: 2024-09-06 19:38:53'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: '[2306.11673] A Survey on Automated Software Vulnerability Detection Using Machine
    Learning and Deep Learning'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[2306.11673] 关于使用机器学习和深度学习的自动化软件漏洞检测的调查'
- en: 来源：[https://ar5iv.labs.arxiv.org/html/2306.11673](https://ar5iv.labs.arxiv.org/html/2306.11673)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://ar5iv.labs.arxiv.org/html/2306.11673](https://ar5iv.labs.arxiv.org/html/2306.11673)
- en: A Survey on Automated Software Vulnerability Detection Using Machine Learning
    and Deep Learning
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于使用机器学习和深度学习的自动化软件漏洞检测的调查
- en: Nima Shiri harzevili [nshiri@yorku.ca](mailto:nshiri@yorku.ca) York University4700
    Keele St.North YorkOntarioCanadaM3J 1P3 ,  Alvine Boaye Belle York University4700
    Keele St.North YorkCanada [alvine.belle@lassonde.yorku.ca](mailto:alvine.belle@lassonde.yorku.ca)
    ,  Junjie Wang Institute of Software, Chinese Academy of SciencesBeijingChina
    [junjie@iscas.ac.cn](mailto:junjie@iscas.ac.cn) ,  Song Wang York University4700
    Keele St.North YorkCanada [wangsong@yorku.ca](mailto:wangsong@yorku.ca) ,  Zhen
    Ming (Jack) Jiang York University4700 Keele St.North YorkCanada [zmjiang@eecs.yorku.ca](mailto:zmjiang@eecs.yorku.ca)
     and  Nachiappan Nagappan MetaSeattleUSA [nachiappan.nagappan@gmail.com](mailto:nachiappan.nagappan@gmail.com)(2018)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Nima Shiri harzevili [nshiri@yorku.ca](mailto:nshiri@yorku.ca) 约克大学4700 Keele
    St.北约克安大略省加拿大M3J 1P3， Alvine Boaye Belle 约克大学4700 Keele St.北约克加拿大 [alvine.belle@lassonde.yorku.ca](mailto:alvine.belle@lassonde.yorku.ca)，
    Junjie Wang 中国科学院软件研究所北京中国 [junjie@iscas.ac.cn](mailto:junjie@iscas.ac.cn)， Song
    Wang 约克大学4700 Keele St.北约克加拿大 [wangsong@yorku.ca](mailto:wangsong@yorku.ca)， Zhen
    Ming (Jack) Jiang 约克大学4700 Keele St.北约克加拿大 [zmjiang@eecs.yorku.ca](mailto:zmjiang@eecs.yorku.ca)
    和 Nachiappan Nagappan Meta西雅图美国 [nachiappan.nagappan@gmail.com](mailto:nachiappan.nagappan@gmail.com)(2018)
- en: Abstract.
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 摘要。
- en: Software vulnerability detection is critical in software security because it
    identifies potential bugs in software systems, enabling immediate remediation
    and mitigation measures to be implemented before they may be exploited. Automatic
    vulnerability identification is important because it can evaluate large codebases
    more efficiently than manual code auditing. Many Machine Learning (ML) and Deep
    Learning (DL) based models for detecting vulnerabilities in source code have been
    presented in recent years. However, a survey that summarises, classifies, and
    analyses the application of ML/DL models for vulnerability detection is missing.
    It may be difficult to discover gaps in existing research and potential for future
    improvement without a comprehensive survey. This could result in essential areas
    of research being overlooked or under-represented, leading to a skewed understanding
    of the state of the art in vulnerability detection. This work address that gap
    by presenting a systematic survey to characterize various features of ML/DL-based
    source code level software vulnerability detection approaches via five primary
    research questions (RQs). Specifically, our RQ1 examines the trend of publications
    that leverage ML/DL for vulnerability detection, including the evolution of research
    and the distribution of publication venues. RQ2 describes vulnerability datasets
    used by existing ML/DL-based models, including their sources, types, and representations,
    as well as analyses of the embedding techniques used by these approaches. RQ3
    explores the model architectures and design assumptions of ML/DL-based vulnerability
    detection approaches. RQ4 summarises the type and frequency of vulnerabilities
    that are covered by existing studies. Lastly, RQ5 presents a list of current challenges
    to be researched and an outline of a potential research roadmap that highlights
    crucial opportunities for future work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 软件漏洞检测在软件安全中至关重要，因为它能识别软件系统中的潜在漏洞，从而在漏洞被利用之前实施及时的修复和缓解措施。自动漏洞识别很重要，因为它可以比人工代码审计更高效地评估大型代码库。近年来，许多基于机器学习（ML）和深度学习（DL）的模型已被提出用于检测源代码中的漏洞。然而，缺乏总结、分类和分析ML/DL模型在漏洞检测中的应用的调查。没有全面的调查，可能难以发现现有研究中的差距和未来改进的潜力。这可能导致重要的研究领域被忽视或代表不足，从而对漏洞检测的现状产生偏差的理解。这项工作通过提出一个系统的调查来弥补这一空白，通过五个主要的研究问题（RQs）来表征各种ML/DL基础的源代码级软件漏洞检测方法的特征。具体来说，我们的RQ1考察了利用ML/DL进行漏洞检测的出版趋势，包括研究的发展和出版场所的分布。RQ2描述了现有ML/DL模型使用的漏洞数据集，包括它们的来源、类型和表示，以及对这些方法所用嵌入技术的分析。RQ3探索了ML/DL基础的漏洞检测方法的模型架构和设计假设。RQ4总结了现有研究涵盖的漏洞类型和频率。最后，RQ5提出了当前需要研究的挑战清单，并概述了一个潜在的研究路线图，突出未来工作的关键机会。
- en: 'source code, software security, software vulnerability detection, software
    bug detection, machine learning, deep learning^†^†copyright: acmcopyright^†^†journalyear:
    2018^†^†doi: XXXXXXX.XXXXXXX^†^†journal: JACM^†^†journalvolume: 37^†^†journalnumber:
    4^†^†article: 111^†^†publicationmonth: 8^†^†ccs: Security and privacy Software
    security engineering'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码，软件安全，软件漏洞检测，软件漏洞检测，机器学习，深度学习^†^†版权：acmcopyright^†^†期刊年份：2018^†^†doi：XXXXXXX.XXXXXXX^†^†期刊：JACM^†^†期刊卷号：37^†^†期刊期号：4^†^†文章：111^†^†出版月份：8^†^†ccs：安全与隐私
    软件安全工程
- en: 1\. Introduction
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 引言
- en: 'Automatic detection of software security vulnerabilities is a critical component
    of assuring software security. Machine Learning (ML) and Deep Learning (DL) breakthroughs
    have sparked great interest in employing these models to discover software vulnerabilities
    in general software systems.. (Wang et al., [2018](#bib.bib138); Cheng et al.,
    [2021](#bib.bib29); Li et al., [2021a](#bib.bib85); Le et al., [2021b](#bib.bib80);
    Yan et al., [2021](#bib.bib146)). ML/DL models excel at discovering subtle patterns
    and correlations from large datasets. They can automatically extract meaningful
    features from raw data, such as source code, and identify hidden patterns that
    may indicate software vulnerabilities. This capability is crucial in vulnerability
    detection, as vulnerabilities often involve subtle code characteristics and dependencies.
    Also, ML/DL models can handle a wide range of data types and formats, including
    source code (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33); Shippey et al.,
    [2019](#bib.bib129); Wang et al., [2016](#bib.bib139); Jeon and Kim, [2021](#bib.bib65);
    Tian et al., [2020](#bib.bib135); Liu et al., [2020](#bib.bib96); Yamaguchi et al.,
    [2013](#bib.bib145)), textual information (Hoang et al., [2019](#bib.bib61)),
    and numerical features such as commit characteristics (Pascarella et al., [2019](#bib.bib114);
    Yang et al., [2017](#bib.bib148)). They can process and analyze these data representations
    to detect vulnerabilities effectively. This flexibility allows researchers to
    leverage various sources of data and incorporate different features for comprehensive
    vulnerability detection. The overall process to leverage ML/DL models for software
    vulnerability detection is as follows: Data collection: The first step toward
    building a vulnerability detection model is to collect relevant vulnerable data
    for training the models. There are multiple sources for vulnerability detection
    datasets (we elaborate on this in RQ2), the researchers either use benchmark data (Le
    et al., [2018](#bib.bib77); Zou et al., [2019](#bib.bib161); Cao et al., [2022](#bib.bib18);
    Ghaffarian and Shahriari, [2021](#bib.bib50); Wu et al., [2021](#bib.bib141);
    Ziems and Wu, [2021](#bib.bib159); Zhuang et al., [2020](#bib.bib158); Li et al.,
    [2021c](#bib.bib88); Filus et al., [2020](#bib.bib43); Li et al., [2018](#bib.bib89);
    Yang et al., [2017](#bib.bib148)) or collect from the open source (Fu and Tantithamthavorn,
    [2022](#bib.bib46); Chen et al., [2021](#bib.bib26); Perl et al., [2015](#bib.bib115);
    Riom et al., [2021](#bib.bib121); Ni et al., [2022](#bib.bib111)) based on the
    requirements and the type of vulnerabilities. Data representation: Once the data
    is collected, it needs to be preprocessed to prepare it for training. The preprocess
    includes using appropriate representation techniques, i.e., graph/tree representation (Zou
    et al., [2019](#bib.bib161); Cao et al., [2022](#bib.bib18); Ghaffarian and Shahriari,
    [2021](#bib.bib50); Wu et al., [2021](#bib.bib141); Lin et al., [2017](#bib.bib92);
    Zhuang et al., [2020](#bib.bib158); Li et al., [2017](#bib.bib83); Lin et al.,
    [2019](#bib.bib91); Li et al., [2021c](#bib.bib88); Duan et al., [2019](#bib.bib39);
    Zheng et al., [2021](#bib.bib154); Zhuang et al., [2022](#bib.bib157); Cheng et al.,
    [2022](#bib.bib31); Liu et al., [2021b](#bib.bib98)), token representation (Zou
    et al., [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Harer et al., [2018](#bib.bib56);
    Hin et al., [2022](#bib.bib59); Le et al., [2018](#bib.bib77); Chen et al., [2021](#bib.bib26);
    Scandariato et al., [2014](#bib.bib125); Ziems and Wu, [2021](#bib.bib159); Filus
    et al., [2020](#bib.bib43)), or using commit characteristics. Embedding: This
    step involves converting the source code representation into numerical format (Zou
    et al., [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Harer et al., [2018](#bib.bib56);
    Hin et al., [2022](#bib.bib59); Fu and Tantithamthavorn, [2022](#bib.bib46); Le
    et al., [2018](#bib.bib77); Cao et al., [2022](#bib.bib18); Ghaffarian and Shahriari,
    [2021](#bib.bib50); Lin et al., [2017](#bib.bib92); Scandariato et al., [2014](#bib.bib125);
    Perl et al., [2015](#bib.bib115))(vectors or embeddings) that can be utilized
    by machine learning or deep learning models for vulnerability detection. Model
    selection and architecture design: An suitable ML/DL model must be chosen based
    on the software vulnerability detection task. This can include everything from
    simple ML algorithms like SVM or Random Forests (Chen et al., [2020b](#bib.bib25);
    Sabetta and Bezzi, [2018](#bib.bib124); Zhou and Sharma, [2017](#bib.bib156))
    to more advanced DL architectures like CNNs (Hoang et al., [2019](#bib.bib61);
    Yan et al., [2021](#bib.bib146); Huo et al., [2018](#bib.bib63)) or RNNs. The
    architecture of the model is intended to extract significant characteristics and
    patterns from the input data. Training: In the training phase, the vulnerability
    detection dataset is separated into training and validation sets, and the model
    learns from labeled data. The model’s parameters are updated iteratively depending
    on the prediction errors, using optimization techniques such as gradient descent.
    Evaluation and validation: Once the training is finished, the model’s performance
    is evaluated using a separate test dataset. Various metrics such as accuracy,
    precision, recall, and F1 score are calculated to assess the model’s effectiveness
    in detecting vulnerabilities. The model may also be validated against real-world
    vulnerabilities to measure its practical utility.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 软件安全漏洞的自动检测是确保软件安全的重要组成部分。机器学习（ML）和深度学习（DL）的突破引发了对将这些模型用于发现一般软件系统中的漏洞的极大兴趣。**(Wang
    et al., [2018](#bib.bib138); Cheng et al., [2021](#bib.bib29); Li et al., [2021a](#bib.bib85);
    Le et al., [2021b](#bib.bib80); Yan et al., [2021](#bib.bib146))**。ML/DL 模型擅长从大数据集中发现微妙的模式和相关性。它们可以从原始数据中自动提取有意义的特征，例如源代码，并识别可能指示软件漏洞的隐藏模式。这种能力在漏洞检测中至关重要，因为漏洞通常涉及微妙的代码特征和依赖关系。此外，ML/DL
    模型能够处理各种数据类型和格式，包括源代码 **(Dam et al., [2018](#bib.bib34), [2017](#bib.bib33); Shippey
    et al., [2019](#bib.bib129); Wang et al., [2016](#bib.bib139); Jeon and Kim, [2021](#bib.bib65);
    Tian et al., [2020](#bib.bib135); Liu et al., [2020](#bib.bib96); Yamaguchi et
    al., [2013](#bib.bib145))**，文本信息 **(Hoang et al., [2019](#bib.bib61))**，以及诸如提交特征之类的数值特征
    **(Pascarella et al., [2019](#bib.bib114); Yang et al., [2017](#bib.bib148))**。它们可以处理和分析这些数据表示，以有效地检测漏洞。这种灵活性使研究人员能够利用各种数据源，并结合不同的特征进行全面的漏洞检测。利用
    ML/DL 模型进行软件漏洞检测的整体过程如下：数据收集：构建漏洞检测模型的第一步是收集相关的漏洞数据用于训练模型。漏洞检测数据集有多种来源（我们在 RQ2
    中详细说明），研究人员可以使用基准数据 **(Le et al., [2018](#bib.bib77); Zou et al., [2019](#bib.bib161);
    Cao et al., [2022](#bib.bib18); Ghaffarian and Shahriari, [2021](#bib.bib50);
    Wu et al., [2021](#bib.bib141); Ziems and Wu, [2021](#bib.bib159); Zhuang et al.,
    [2020](#bib.bib158); Li et al., [2021c](#bib.bib88); Filus et al., [2020](#bib.bib43);
    Li et al., [2018](#bib.bib89); Yang et al., [2017](#bib.bib148))** 或根据需求和漏洞类型从开源数据中收集
    **(Fu and Tantithamthavorn, [2022](#bib.bib46); Chen et al., [2021](#bib.bib26);
    Perl et al., [2015](#bib.bib115); Riom et al., [2021](#bib.bib121); Ni et al.,
    [2022](#bib.bib111))**。数据表示：数据收集后，需要进行预处理以准备训练。预处理包括使用适当的表示技术，即图/树表示 **(Zou et
    al., [2019](#bib.bib161); Cao et al., [2022](#bib.bib18); Ghaffarian and Shahriari,
    [2021](#bib.bib50); Wu et al., [2021](#bib.bib141); Lin et al., [2017](#bib.bib92);
    Zhuang et al., [2020](#bib.bib158); Li et al., [2017](#bib.bib83); Lin et al.,
    [2019](#bib.bib91); Li et al., [2021c](#bib.bib88); Duan et al., [2019](#bib.bib39);
    Zheng et al., [2021](#bib.bib154); Zhuang et al., [2022](#bib.bib157); Cheng et
    al., [2022](#bib.bib31); Liu et al., [2021b](#bib.bib98))**，标记表示 **(Zou et al.,
    [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Harer et al., [2018](#bib.bib56);
    Hin et al., [2022](#bib.bib59); Le et al., [2018](#bib.bib77); Chen et al., [2021](#bib.bib26);
    Scandariato et al., [2014](#bib.bib125); Ziems and Wu, [2021](#bib.bib159); Filus
    et al., [2020](#bib.bib43))**，或使用提交特征。嵌入：这一步涉及将源代码表示转换为数值格式 **(Zou et al., [2021](#bib.bib162);
    Huo et al., [2018](#bib.bib63); Harer et al., [2018](#bib.bib56); Hin et al.,
    [2022](#bib.bib59); Fu and Tantithamthavorn, [2022](#bib.bib46); Le et al., [2018](#bib.bib77);
    Cao et al., [2022](#bib.bib18); Ghaffarian and Shahriari, [2021](#bib.bib50);
    Lin et al., [2017](#bib.bib92); Scandariato et al., [2014](#bib.bib125); Perl
    et al., [2015](#bib.bib115))**（向量或嵌入），以便机器学习或深度学习模型可以用于漏洞检测。模型选择和架构设计：必须根据软件漏洞检测任务选择合适的
    ML/DL 模型。这可以包括从简单的 ML 算法，如 SVM 或随机森林 **(Chen et al., [2020b](#bib.bib25); Sabetta
    and Bezzi, [2018](#bib.bib124); Zhou and Sharma, [2017](#bib.bib156))**，到更高级的
    DL 架构，如 CNNs **(Hoang et al., [2019](#bib.bib61); Yan et al., [2021](#bib.bib146);
    Huo et al., [2018](#bib.bib63))** 或 RNNs。模型的架构旨在从输入数据中提取重要特征和模式。训练：在训练阶段，漏洞检测数据集被分为训练集和验证集，模型从标记数据中学习。模型的参数根据预测误差迭代更新，使用如梯度下降等优化技术。评估和验证：训练完成后，使用单独的测试数据集评估模型的性能。计算各种指标，如准确率、精确率、召回率和
    F1 分数，以评估模型在检测漏洞方面的有效性。模型还可能针对现实世界中的漏洞进行验证，以衡量其实际效用。
- en: 'Although many studies have utilized ML/DL to detect software vulnerabilities,
    there has not been a comprehensive review to consolidate the various approaches
    and characteristics of these techniques. Conducting such a systematic survey would
    be beneficial for practitioners and researchers to gain a better understanding
    of the current state-of-the-art tools for vulnerability detection, and could serve
    as inspiration for future studies. This study conducts a detailed and comprehensive
    survey to review, analyze, describe, and classify vulnerability detection papers
    from different perspectives. We analyzed 67 articles published in 37 flagship
    SE journals and conferences from 2011 to 2022\. We investigated the following
    research questions (RQs) in this study:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多研究已经利用机器学习/深度学习技术来检测软件漏洞，但尚未有全面的综述来整合这些技术的各种方法和特征。进行这样一个系统的调查对从业者和研究人员来说将是有益的，可以更好地了解当前最先进的漏洞检测工具，并为未来的研究提供灵感。本研究进行了详细而全面的调查，从不同角度回顾、分析、描述和分类漏洞检测的论文。我们分析了2011年至2022年间在37个旗舰软件工程期刊和会议上发表的67篇文章。我们在本研究中调查了以下研究问题（RQs）：
- en: •
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: 'RQ1: What is the trend of studies using ML/DL models for vulnerability detection?'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ1：使用机器学习/深度学习模型进行漏洞检测的研究趋势是什么？
- en: –
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: –
- en: RQ1.1\. What are the trends of studies in software vulnerability detection studies
    over time?
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ1.1：软件漏洞检测研究的趋势随着时间的推移有什么变化？
- en: –
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: –
- en: RQ1.2\. What is the distribution of the publication venues?
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ1.2：出版场所的分布情况如何？
- en: •
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: 'RQ2: What are the characteristics of experiment datasets used in software vulnerability
    detection?'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ2：在软件漏洞检测中使用的实验数据集有哪些特征？
- en: –
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: –
- en: RQ2.1\. What is the source of data?
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ2.1：数据来源是什么？
- en: –
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: –
- en: RQ2.2\. What are the types of data used in primary studies?
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ2.2：主要研究中使用的数据类型是什么？
- en: –
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: –
- en: RQ2.3\. How input data are represented?
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ2.3：输入数据是如何表示的？
- en: –
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: –
- en: RQ2.4\. How input data are embedded for feature space?
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ2.4：输入数据是如何嵌入到特征空间中的？
- en: •
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: RQ3\. What are the different ML/DL models used for vulnerability detection?
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ3：用于漏洞检测的不同机器学习/深度学习模型有哪些？
- en: •
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: RQ4\. What are the most frequent type of vulnerabilities covered in these studies?
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ4：这些研究中最常见的漏洞类型是什么？
- en: •
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: RQ5\. What are possible challenges and open directions in software vulnerability
    detection?
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RQ5：软件漏洞检测中可能面临的挑战和开放方向有哪些？
- en: 'This paper makes the following contributions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本文做出了以下贡献：
- en: •
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: We thoroughly analyzed 67 relevant studies that used ML/DL techniques to detect
    security vulnerabilities regarding publication trends, distribution of publication
    venues, and types of contributions.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们对67项相关研究进行了深入分析，这些研究使用机器学习/深度学习技术检测安全漏洞，涉及出版趋势、出版场所的分布以及贡献类型。
- en: •
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: We conducted a comprehensive analysis to understand the dataset, the processing
    of data, data representation, model architecture, model interpretability, and
    the types of involved vulnerabilities of these ML/DL-based vulnerability detection
    techniques.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们进行了全面分析，以了解这些基于机器学习/深度学习的漏洞检测技术中的数据集、数据处理、数据表示、模型架构、模型可解释性以及涉及的漏洞类型。
- en: •
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: We provided a classification of ML/DL models used in vulnerability detection
    based on their architectures and analysis of technique selection strategy on these
    models.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们根据模型的架构提供了漏洞检测中使用的机器学习/深度学习模型的分类，并分析了这些模型上的技术选择策略。
- en: •
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: We discuss distinct technical challenges of using ML/DL techniques in vulnerability
    detection and outline key future directions.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们讨论了使用机器学习/深度学习技术进行漏洞检测的不同技术挑战，并概述了关键的未来方向。
- en: •
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: We have shared our results and analysis data as a replication package¹¹1https://colab.research.google.com/drive/1O42duwz34H3fRoyfA37EU6Ig2u16R1Lb?usp=sharing
    to allow other researchers easily follow this paper and extend it.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已将结果和分析数据共享为一个复制包¹¹1https://colab.research.google.com/drive/1O42duwz34H3fRoyfA37EU6Ig2u16R1Lb?usp=sharing，以便其他研究人员可以轻松跟随本文并进行扩展。
- en: We believe that this work is useful for researchers and practitioners in the
    field of software engineering and cybersecurity, particularly those with an interest
    in software vulnerability detection and mitigation. In addition, the findings
    of our systematic survey may also be useful to policymakers, software vendors,
    and other stakeholders who are concerned with improving software security and
    reducing the risk of cyberattacks. These individuals may use the insights provided
    by the review to inform their decisions about software development, procurement,
    and risk management.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信这项工作对软件工程和网络安全领域的研究人员和从业者是有用的，特别是对那些关注软件漏洞检测和缓解的人士。此外，我们的系统性调查结果也可能对政策制定者、软件供应商以及其他关注提高软件安全性和降低网络攻击风险的利益相关者有所帮助。这些人可能会利用评审提供的见解来指导他们在软件开发、采购和风险管理方面的决策。
- en: 'The remaining part of this paper is organized as follows: Section [2](#S2 "2\.
    Background and Related Work ‣ A Survey on Automated Software Vulnerability Detection
    Using Machine Learning and Deep Learning") summarizes existing studies focusing
    on proposing a systematic survey for software vulnerability detection. Section
    2 presents related work on systematic surveys for software vulnerability detection
    using ML/DL techniques. Section 3 presents the research methodology proposed in
    this paper for paper collection and criteria for including and excluding studies.
    Section 4 addresses research questions and corresponding results. Section 5 discusses
    the possible limitations of this systematic survey. Finally, section 6 discusses
    the conclusion and future directions.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的其余部分组织如下：第[2](#S2 "2\. Background and Related Work ‣ A Survey on Automated
    Software Vulnerability Detection Using Machine Learning and Deep Learning")节总结了现有的关注于提出软件漏洞检测系统性调查的研究。第2节介绍了使用ML/DL技术进行软件漏洞检测的系统性调查相关工作。第3节展示了本文提出的论文收集研究方法及纳入和排除研究的标准。第4节讨论了研究问题及相应结果。第5节讨论了这项系统性调查可能存在的局限性。最后，第6节讨论了结论和未来方向。
- en: 2\. Background and Related Work
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. 背景和相关工作
- en: In this section of the paper, we first provide a background on the definition
    of vulnerability and the different steps in software vulnerability detection.
    Then we discuss the related surveys and highlight their differences compared to
    our survey.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文的这一部分，我们首先提供了对漏洞定义和软件漏洞检测不同步骤的背景介绍。然后我们讨论了相关调查，并突出其与我们调查的区别。
- en: 2.1\. Background
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 背景
- en: Software vulnerability management is now essential for guaranteeing the security
    and integrity of software systems (Chang et al., [2011](#bib.bib21); Foreman,
    [2019](#bib.bib44); Raza and Ahmed, [2022](#bib.bib120); Walkowski et al., [2021](#bib.bib136)).
    Given the increasing reliance on software for many critical processes such as
    financial transactions, the frequency of vulnerabilities poses serious risks.. (Lu
    et al., [2021](#bib.bib100); He et al., [2020](#bib.bib58)), autonomous driving (Gao
    et al., [2021](#bib.bib47); Luo et al., [2019](#bib.bib101)), and mission-critical
    systems (Goseva-Popstojanova and Tyo, [2017](#bib.bib54); Harzevili et al., [2022](#bib.bib57)).
    Software vulnerabilities can be exploited by malicious entities to gain unauthorized
    access, compromise sensitive information, or disrupt services if they go undetected
    or ignored. (Harzevili et al., [2022](#bib.bib57)). As a result, excellent software
    vulnerability management is crucial to handling these risks, preserving user privacy (Anthonysamy
    et al., [2017](#bib.bib6)), maintaining system availability, and assuring software
    application trustworthiness (Medeiros et al., [2023](#bib.bib105)). By proactively
    detecting, analyzing, and remediating vulnerabilities, organizations may strengthen
    their software systems against changing cybersecurity threats (Aslan et al., [2023](#bib.bib7))
    and adhere to industry best practices for safe software development and deployment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，软件漏洞管理对保障软件系统的安全性和完整性至关重要 (Chang et al., [2011](#bib.bib21); Foreman, [2019](#bib.bib44);
    Raza and Ahmed, [2022](#bib.bib120); Walkowski et al., [2021](#bib.bib136))。鉴于对软件在金融交易等许多关键过程中的日益依赖，漏洞的频繁出现带来了严重的风险 (Lu
    et al., [2021](#bib.bib100); He et al., [2020](#bib.bib58))，自动驾驶 (Gao et al.,
    [2021](#bib.bib47); Luo et al., [2019](#bib.bib101))，以及任务关键系统 (Goseva-Popstojanova
    and Tyo, [2017](#bib.bib54); Harzevili et al., [2022](#bib.bib57))。如果软件漏洞未被检测或忽视，恶意实体可以利用这些漏洞来获取未经授权的访问、泄露敏感信息或干扰服务 (Harzevili
    et al., [2022](#bib.bib57))。因此，出色的软件漏洞管理对于应对这些风险、保护用户隐私 (Anthonysamy et al., [2017](#bib.bib6))、维护系统可用性，以及确保软件应用的可信度 (Medeiros
    et al., [2023](#bib.bib105))至关重要。通过主动检测、分析和修复漏洞，组织可以增强其软件系统抵御不断变化的网络安全威胁 (Aslan
    et al., [2023](#bib.bib7))，并遵循行业最佳实践以实现安全的软件开发和部署。
- en: There are multiple steps in software vulnerability management including vulnerability
    detection (Cao et al., [2022](#bib.bib18)), vulnerability analysis (Kudjo et al.,
    [2020](#bib.bib74)), and vulnerability remediation (Le et al., [2021a](#bib.bib78)).
    In the following subsections, we elaborate on each step in detail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 软件漏洞管理包括多个步骤，涵盖漏洞检测 (Cao et al., [2022](#bib.bib18))、漏洞分析 (Kudjo et al., [2020](#bib.bib74))
    和漏洞修复 (Le et al., [2021a](#bib.bib78))。在接下来的子章节中，我们将详细阐述每个步骤。
- en: 2.1.1\. Vulnerability detection
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 漏洞检测
- en: 'Vulnerability detection is critical in the overall process of managing software
    vulnerabilities (Cao et al., [2022](#bib.bib18); Jeon and Kim, [2021](#bib.bib65);
    Tian et al., [2020](#bib.bib135); Liu et al., [2020](#bib.bib96); Wang et al.,
    [2020](#bib.bib137); Cheng et al., [2021](#bib.bib29); Zou et al., [2019](#bib.bib161);
    Cao et al., [2022](#bib.bib18); Ziems and Wu, [2021](#bib.bib159); Lin et al.,
    [2019](#bib.bib91); Li et al., [2021c](#bib.bib88)). It comprises detecting and
    investigating possible security weaknesses in software systems that attackers
    may exploit. There are several traditional techniques commonly used for vulnerability
    detection:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞检测在管理软件漏洞的整个过程中至关重要 (Cao et al., [2022](#bib.bib18); Jeon and Kim, [2021](#bib.bib65);
    Tian et al., [2020](#bib.bib135); Liu et al., [2020](#bib.bib96); Wang et al.,
    [2020](#bib.bib137); Cheng et al., [2021](#bib.bib29); Zou et al., [2019](#bib.bib161);
    Cao et al., [2022](#bib.bib18); Ziems and Wu, [2021](#bib.bib159); Lin et al.,
    [2019](#bib.bib91); Li et al., [2021c](#bib.bib88))。它包括检测和调查软件系统中攻击者可能利用的安全漏洞。传统的漏洞检测技术有几种常用的方法：
- en: 'Manual Code Auditing (Staron et al., [2020](#bib.bib131); Bacchelli and Bird,
    [2013](#bib.bib8); Carlsson and Baca, [2005](#bib.bib19); Shar and Tan, [2012](#bib.bib128),
    [2010](#bib.bib127)): In this method, human experts examine the source thoroughly
    with the goal of manually detecting coding flaws, unsafe procedures, and possible
    vulnerabilities. Manual code review is time-consuming and requires the knowledge
    of qualified developers or security analysts. However, it provides for a thorough
    grasp of the code and can reveal subtle bugs that automated tools may overlook.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 手动代码审计（Staron 等, [2020](#bib.bib131); Bacchelli 和 Bird, [2013](#bib.bib8); Carlsson
    和 Baca, [2005](#bib.bib19); Shar 和 Tan, [2012](#bib.bib128), [2010](#bib.bib127)）：在这种方法中，人工专家彻底检查源代码，目的是手动检测编码缺陷、不安全的程序和可能的漏洞。手动代码审查费时且需要合格的开发人员或安全分析师的知识。然而，它提供了对代码的深入理解，并能揭示自动化工具可能忽视的微妙错误。
- en: 'Static Analysis (Facebook, [2013](#bib.bib42); Wheeler, [2013](#bib.bib140);
    Dunham, [2009](#bib.bib40); Marjamäki, [2016](#bib.bib104); SpotBugs., [2021](#bib.bib130);
    Lattner, [2008](#bib.bib76)): Static analysis involves using automated tools to
    analyze the source code or compiled binaries without executing the software. It
    examines the code structure, identifies potential coding issues, and detects common
    vulnerabilities such as buffer overflows (Harzevili et al., [2022](#bib.bib57)),
    injection attacks, and insecure data handling. Static analysis tools employ various
    techniques like data flow analysis, control flow analysis, and pattern matching
    to identify potential vulnerabilities. They can help scale vulnerability detection
    efforts by analyzing large codebases efficiently.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析（Facebook, [2013](#bib.bib42); Wheeler, [2013](#bib.bib140); Dunham, [2009](#bib.bib40);
    Marjamäki, [2016](#bib.bib104); SpotBugs., [2021](#bib.bib130); Lattner, [2008](#bib.bib76)）：静态分析涉及使用自动化工具分析源代码或编译后的二进制文件而无需执行软件。它检查代码结构，识别潜在的编码问题，并检测常见的漏洞，如缓冲区溢出（Harzevili
    等, [2022](#bib.bib57)）、注入攻击和不安全的数据处理。静态分析工具采用数据流分析、控制流分析和模式匹配等各种技术来识别潜在的漏洞。它们可以通过高效分析大型代码库来帮助扩展漏洞检测工作。
- en: 'Dynamic Analysis (Nethercote and Seward, [2007](#bib.bib107); Lehmann and Pradel,
    [2019](#bib.bib82); Cadar et al., [2008](#bib.bib16)): The goal of dynamic analysis
    is to evaluate the behavior of software while it is running. Running the software
    in a controlled environment or through automated tests while monitoring its execution
    and interactions with system resources is what it entails. Dynamic analysis can
    detect bugs in input validation (Kim et al., [2019](#bib.bib71)), access control,
    and error handling. This approach can identify vulnerabilities that static analysis
    alone cannot detect by analyzing the real-time behavior of the software. However,
    the dynamic analysis may have constraints in terms of significant system overhead (Yong
    and Horwitz, [2005](#bib.bib150)).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析（Nethercote 和 Seward, [2007](#bib.bib107); Lehmann 和 Pradel, [2019](#bib.bib82);
    Cadar 等, [2008](#bib.bib16)）：动态分析的目标是评估软件在运行时的行为。它包括在受控环境中运行软件或通过自动化测试来监控其执行和与系统资源的交互。动态分析可以检测输入验证（Kim
    等, [2019](#bib.bib71)）、访问控制和错误处理中的漏洞。通过分析软件的实时行为，这种方法可以识别静态分析无法发现的漏洞。然而，动态分析可能在显著的系统开销方面存在限制（Yong
    和 Horwitz, [2005](#bib.bib150)）。
- en: 2.1.2\. Vulnerability analysis
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 漏洞分析
- en: After the detection of vulnerabilities, the subsequent step in software vulnerability
    management is vulnerability analysis and assessment (Le et al., [2019](#bib.bib81);
    Suciu et al., [2022](#bib.bib132); Jacobs et al., [2023](#bib.bib64); Yin et al.,
    [2022](#bib.bib149); Le et al., [2022](#bib.bib79); Mahor et al., [2022](#bib.bib102);
    Frei et al., [2006](#bib.bib45)). This step involves further examining the identified
    vulnerabilities to assess their severity, impact, and potential exploitability.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到漏洞之后，软件漏洞管理的下一步是漏洞分析和评估（Le 等, [2019](#bib.bib81); Suciu 等, [2022](#bib.bib132);
    Jacobs 等, [2023](#bib.bib64); Yin 等, [2022](#bib.bib149); Le 等, [2022](#bib.bib79);
    Mahor 等, [2022](#bib.bib102); Frei 等, [2006](#bib.bib45)）。这一步涉及对已识别的漏洞进行进一步检查，以评估其严重性、影响和潜在的可利用性。
- en: 'Severity: Accurately assessing software vulnerabilities is vital for several
    reasons. Firstly, it allows organizations to prioritize their response based on
    the severity of the vulnerabilities. Severity refers to the potential impact a
    vulnerability could have if exploited (Kudjo et al., [2019](#bib.bib75); Chen
    et al., [2020a](#bib.bib24); Kudjo et al., [2020](#bib.bib74); Tan et al., [2020](#bib.bib134)).
    By accurately assessing the severity, organizations can focus their attention
    on high-severity vulnerabilities that pose significant risks to the security and
    functionality of the software system.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 严重性：准确评估软件漏洞至关重要，原因有几个。首先，它允许组织根据漏洞的严重性来优先响应。严重性指的是如果漏洞被利用，可能产生的影响（Kudjo et
    al., [2019](#bib.bib75); Chen et al., [2020a](#bib.bib24); Kudjo et al., [2020](#bib.bib74);
    Tan et al., [2020](#bib.bib134)）。通过准确评估严重性，组织可以将注意力集中在对软件系统的安全性和功能性构成重大风险的高严重性漏洞上。
- en: 'Impact: Secondly, accurately assessing vulnerabilities helps determine the
    potential impact they may have on the organization (Gawron et al., [2018](#bib.bib48);
    Gong et al., [2019](#bib.bib52); Chen et al., [2010](#bib.bib28); Jiang and Atif,
    [2020](#bib.bib66)). The term impact refers to the repercussions of exploiting
    a vulnerability, such as denial of service (Harzevili et al., [2022](#bib.bib57))
    or data breaches (Aaltonen and Gao, [2021](#bib.bib2)). By understanding the potential
    impact, organizations can make informed decisions regarding the urgency and priority
    of remediation efforts.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 影响：其次，准确评估漏洞有助于确定其可能对组织产生的影响（Gawron et al., [2018](#bib.bib48); Gong et al.,
    [2019](#bib.bib52); Chen et al., [2010](#bib.bib28); Jiang and Atif, [2020](#bib.bib66)）。影响指的是利用漏洞可能产生的后果，如服务拒绝（Harzevili
    et al., [2022](#bib.bib57)）或数据泄露（Aaltonen and Gao, [2021](#bib.bib2)）。通过了解潜在影响，组织可以就修复工作的紧急性和优先级做出明智决策。
- en: 'exploitability: Furthermore, accurately assessing vulnerabilities aids in understanding
    their potential exploitability (Chen et al., [2019b](#bib.bib23), [a](#bib.bib22);
    Bozorgi et al., [2010](#bib.bib14)). This entails determining the possibility
    that an attacker will be successful in exploiting the vulnerability to infiltrate
    the software system. Organizations can estimate the amount of risk associated
    with each vulnerability and invest resources accordingly by evaluating criteria
    such as the ease of exploitation and the availability of exploit techniques.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 利用性：此外，准确评估漏洞有助于理解其潜在的利用性（Chen et al., [2019b](#bib.bib23), [a](#bib.bib22);
    Bozorgi et al., [2010](#bib.bib14)）。这包括确定攻击者成功利用漏洞渗透软件系统的可能性。通过评估诸如利用难度和利用技术的可用性等标准，组织可以估计每个漏洞相关的风险，并相应地投入资源。
- en: 2.1.3\. Vulnerability remediation
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3\. 漏洞修复
- en: The process of addressing detected software vulnerabilities by different techniques
    such as patching, code modification, and repairing is referred to as software
    vulnerability remediation (Canfora et al., [2022](#bib.bib17); Piantadosi et al.,
    [2019](#bib.bib118); Chen et al., [2022](#bib.bib27); Bhandari et al., [2021](#bib.bib9)).
    The fundamental goal of remediation is to eliminate or mitigate vulnerabilities
    in order to improve the software system’s security and dependability. One common
    approach to vulnerability remediation is applying patches provided by software
    vendors or open-source communities (Xia et al., [2023](#bib.bib142); Li et al.,
    [2022](#bib.bib84); Gissurarson et al., [2022](#bib.bib51)). Patches are updates
    or fixes that address specific vulnerabilities or weaknesses identified in a software
    system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决检测到的软件漏洞的过程，包括修补、代码修改和修复等技术，称为软件漏洞修复（Canfora et al., [2022](#bib.bib17); Piantadosi
    et al., [2019](#bib.bib118); Chen et al., [2022](#bib.bib27); Bhandari et al.,
    [2021](#bib.bib9)）。修复的基本目标是消除或减轻漏洞，以提高软件系统的安全性和可靠性。常见的漏洞修复方法之一是应用由软件供应商或开源社区提供的补丁（Xia
    et al., [2023](#bib.bib142); Li et al., [2022](#bib.bib84); Gissurarson et al.,
    [2022](#bib.bib51)）。补丁是更新或修复，旨在解决软件系统中识别出的特定漏洞或弱点。
- en: 2.1.4\. ML/DL for software vulnerability detection
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.4\. ML/DL用于软件漏洞检测
- en: By utilizing data analysis, pattern recognition, and machine-driven learning
    for finding software security vulnerabilities, ML/DL approaches have revolutionized
    software vulnerability detection. (Wang et al., [2018](#bib.bib138); Cheng et al.,
    [2021](#bib.bib29); Li et al., [2021a](#bib.bib85); Le et al., [2021b](#bib.bib80);
    Yan et al., [2021](#bib.bib146)). These techniques improve the accuracy and efficiency
    of vulnerability detection, potentially allowing for automated detection, faster
    analysis, and the identification of previously undisclosed vulnerabilities.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用数据分析、模式识别和机器驱动学习来发现软件安全漏洞，ML/DL 方法彻底改变了软件漏洞检测。（Wang et al., [2018](#bib.bib138);
    Cheng et al., [2021](#bib.bib29); Li et al., [2021a](#bib.bib85); Le et al., [2021b](#bib.bib80);
    Yan et al., [2021](#bib.bib146)）。这些技术提高了漏洞检测的准确性和效率，可能实现自动检测、更快分析和识别以前未公开的漏洞。
- en: One common application of ML/DL in vulnerability detection is the classification
    of code snippets (Dam et al., [2017](#bib.bib33); Shippey et al., [2019](#bib.bib129);
    Wang et al., [2016](#bib.bib139); Jeon and Kim, [2021](#bib.bib65)), software
    binaries (Phan et al., [2017](#bib.bib117); Nguyen et al., [2020](#bib.bib110);
    Yan et al., [2021](#bib.bib146); Huang et al., [2021](#bib.bib62)), or code changes
    mined from open-source repositories such as GitHub or CVE (Sabetta and Bezzi,
    [2018](#bib.bib124); Wang et al., [2020](#bib.bib137); Liu et al., [2019a](#bib.bib95);
    Pradel and Sen, [2018](#bib.bib119); Hoang et al., [2019](#bib.bib61); Zhou et al.,
    [2019](#bib.bib155); Dinella et al., [2020](#bib.bib36); Li et al., [2019](#bib.bib86)).
    ML models can be trained on labeled datasets, where each sample represents a known
    vulnerability or non-vulnerability. These models then learn to generalize from
    the provided examples and classify new instances based on the patterns they have
    learned. This method allows for automatic vulnerability discovery without the
    need for manual examination, considerably lowering the time and effort necessary
    for analysis.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ML/DL 在漏洞检测中的一个常见应用是对代码片段（Dam et al., [2017](#bib.bib33); Shippey et al., [2019](#bib.bib129);
    Wang et al., [2016](#bib.bib139); Jeon and Kim, [2021](#bib.bib65)）、软件二进制文件（Phan
    et al., [2017](#bib.bib117); Nguyen et al., [2020](#bib.bib110); Yan et al., [2021](#bib.bib146);
    Huang et al., [2021](#bib.bib62)）或从 GitHub 或 CVE 等开源库中提取的代码更改（Sabetta and Bezzi,
    [2018](#bib.bib124); Wang et al., [2020](#bib.bib137); Liu et al., [2019a](#bib.bib95);
    Pradel and Sen, [2018](#bib.bib119); Hoang et al., [2019](#bib.bib61); Zhou et
    al., [2019](#bib.bib155); Dinella et al., [2020](#bib.bib36); Li et al., [2019](#bib.bib86)）进行分类。ML
    模型可以在标记数据集上进行训练，其中每个样本代表已知的漏洞或非漏洞。这些模型然后学习从提供的示例中进行概括，并根据已学到的模式对新实例进行分类。这种方法可以自动发现漏洞，无需手动检查，从而显著减少了分析所需的时间和精力。
- en: ML/DL models for detecting software vulnerabilities have promising advantages
    over traditional methodologies. Each benefit is discussed in depth in the next
    paragraph.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 检测软件漏洞的 ML/DL 模型相比于传统方法具有显著的优势。每项优势将在下一段中深入探讨。
- en: 'Automation: Automation is a significant advantage. ML models can automatically
    scan and analyze large codebases, network traffic logs, or system configurations,
    flagging potential vulnerabilities without requiring human intervention for each
    individual case (Chakraborty et al., [2021](#bib.bib20)). This automation speeds
    up the detection process, allowing security teams to focus on verifying and mitigating
    vulnerabilities rather than manual analysis.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化：自动化是一个重要优势。ML 模型可以自动扫描和分析大规模代码库、网络流量日志或系统配置，标记潜在的漏洞，而不需要对每个单独的案例进行人工干预（Chakraborty
    et al., [2021](#bib.bib20)）。这种自动化加快了检测过程，使安全团队能够专注于验证和缓解漏洞，而不是手动分析。
- en: 'Performance: ML/DL approaches offer faster analysis. Traditional vulnerability
    detection methods rely on manual inspection or the application of predefined rules (Staron
    et al., [2020](#bib.bib131); Bacchelli and Bird, [2013](#bib.bib8); Carlsson and
    Baca, [2005](#bib.bib19); Shar and Tan, [2012](#bib.bib128), [2010](#bib.bib127)).
    In contrast, ML/DL approaches can evaluate enormous volumes of data in parallel
    and generate predictions fast, dramatically shortening the time necessary to find
    vulnerabilities.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 性能：ML/DL 方法提供了更快的分析速度。传统的漏洞检测方法依赖手动检查或预定义规则的应用（Staron et al., [2020](#bib.bib131);
    Bacchelli and Bird, [2013](#bib.bib8); Carlsson and Baca, [2005](#bib.bib19);
    Shar and Tan, [2012](#bib.bib128), [2010](#bib.bib127)）。相对而言，ML/DL 方法可以并行评估大量数据并快速生成预测，大大缩短了找到漏洞所需的时间。
- en: 'Detection effectiveness: ML/DL models can uncover previously unknown vulnerabilities,
    commonly known as zero-day vulnerabilities (Bilge and Dumitraş, [2012](#bib.bib11)).
    These models may uncover signs of vulnerabilities even when they have not been
    specifically trained on them by learning patterns and generalizing from labeled
    data. This capability improves the overall security posture by helping to identify
    and address unknown weaknesses in software before they are exploited by attackers (Abri
    et al., [2019](#bib.bib3)).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 检测有效性：机器学习/深度学习模型能够发现以前未知的漏洞，通常被称为零日漏洞 (Bilge 和 Dumitraş, [2012](#bib.bib11))。这些模型即使没有专门针对这些漏洞进行训练，通过学习模式和从标记数据中进行泛化，也可能发现漏洞迹象。这种能力通过帮助识别和解决软件中的未知弱点，从而在攻击者利用这些漏洞之前提高整体安全态势
    (Abri 等, [2019](#bib.bib3))。
- en: 2.2\. Related work
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 相关工作
- en: There have been several existing survey papers on software vulnerabilities in
    the literature. In this section, we analyze the existing papers based on different
    aspects as shown in Table [1](#S2.T1 "Table 1 ‣ 2.2\. Related work ‣ 2\. Background
    and Related Work ‣ A Survey on Automated Software Vulnerability Detection Using
    Machine Learning and Deep Learning").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 文献中已有几篇关于软件漏洞的调查论文。在本节中，我们根据不同的方面分析现有的论文，如表 [1](#S2.T1 "Table 1 ‣ 2.2\. Related
    work ‣ 2\. Background and Related Work ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning") 所示。
- en: Table 1. Comparison of contributions between our survey and the existing related
    surveys/reviews.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1. 我们的调查与现有相关调查/评论之间的贡献比较。
- en: '| No | Studies | Data Source | Representation | Embedding | Models | Vulnerability
    Types | Interpretability |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 研究 | 数据来源 | 表示 | 嵌入 | 模型 | 漏洞类型 | 可解释性 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | Triet et al. (Le et al., [2021a](#bib.bib78)) | ✓ | $\times$ | $\checkmark$
    | $\checkmark$ | $\times$ | $\times$ |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Triet 等 (Le 等, [2021a](#bib.bib78)) | ✓ | $\times$ | $\checkmark$ | $\checkmark$
    | $\times$ | $\times$ |'
- en: '| 2 | Ghaffarian et al. (Ghaffarian and Shahriari, [2017](#bib.bib49)) | $\checkmark$
    | $\checkmark$ | $\checkmark$ | $\checkmark$ | $\times$ | $\times$ |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Ghaffarian 等 (Ghaffarian 和 Shahriari, [2017](#bib.bib49)) | $\checkmark$
    | $\checkmark$ | $\checkmark$ | $\checkmark$ | $\times$ | $\times$ |'
- en: '| 3 | Lin et al. (Lin et al., [2020](#bib.bib90)) | $\checkmark$ | $\checkmark$
    | $\checkmark$ | $\checkmark$ | $\times$ | $\times$ |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Lin 等 (Lin 等, [2020](#bib.bib90)) | $\checkmark$ | $\checkmark$ | $\checkmark$
    | $\checkmark$ | $\times$ | $\times$ |'
- en: '| 4 | Zeng et al. (Zeng et al., [2020](#bib.bib152)) | $\checkmark$ | $\checkmark$
    | $\checkmark$ | $\checkmark$ | $\times$ | $\times$ |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Zeng 等 (Zeng 等, [2020](#bib.bib152)) | $\checkmark$ | $\checkmark$ |
    $\checkmark$ | $\checkmark$ | $\times$ | $\times$ |'
- en: '| 5 | Semasaba et al. (Semasaba et al., [2020](#bib.bib126)) | $\checkmark$
    | $\checkmark$ | $\times$ | $\checkmark$ | $\checkmark$ | $\times$ |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 5 | Semasaba 等 (Semasaba 等, [2020](#bib.bib126)) | $\checkmark$ | $\checkmark$
    | $\times$ | $\checkmark$ | $\checkmark$ | $\times$ |'
- en: '| 6 | Sun et al. (Sun et al., [2018](#bib.bib133)) | $\checkmark$ | $\times$
    | $\times$ | $\times$ | $\checkmark$ | $\times$ |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 6 | Sun 等 (Sun 等, [2018](#bib.bib133)) | $\checkmark$ | $\times$ | $\times$
    | $\times$ | $\checkmark$ | $\times$ |'
- en: '| 7 | Kritikos et al. (Kritikos et al., [2019](#bib.bib72)) | $\checkmark$
    | $\times$ | $\times$ | $\times$ | $\checkmark$ | $\times$ |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 7 | Kritikos 等 (Kritikos 等, [2019](#bib.bib72)) | $\checkmark$ | $\times$
    | $\times$ | $\times$ | $\checkmark$ | $\times$ |'
- en: '| 8 | Khan et al. (Khan and Parkinson, [2018](#bib.bib70)) | $\times$ | $\times$
    | $\times$ | $\times$ | $\times$ | $\times$ |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 8 | Khan 等 (Khan 和 Parkinson, [2018](#bib.bib70)) | $\times$ | $\times$ |
    $\times$ | $\times$ | $\times$ | $\times$ |'
- en: '| 9 | Nong et al. (Nong et al., [2022](#bib.bib112)) | $\times$ | $\times$
    | $\times$ | $\times$ | $\times$ | $\times$ |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 9 | Nong 等 (Nong 等, [2022](#bib.bib112)) | $\times$ | $\times$ | $\times$
    | $\times$ | $\times$ | $\times$ |'
- en: '| 10 | Chakraborty et al. (Chakraborty et al., [2021](#bib.bib20)) | $\times$
    | $\times$ | $\times$ | $\times$ | $\times$ | $\times$ |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 10 | Chakraborty 等 (Chakraborty 等, [2021](#bib.bib20)) | $\times$ | $\times$
    | $\times$ | $\times$ | $\times$ | $\times$ |'
- en: '| 11 | Liu et al. (Liu et al., [2021a](#bib.bib94)) | $\times$ | $\times$ |
    $\times$ | $\times$ | $\times$ | $\times$ |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 11 | Liu 等 (Liu 等, [2021a](#bib.bib94)) | $\times$ | $\times$ | $\times$
    | $\times$ | $\times$ | $\times$ |'
- en: '| 12 | Bi et al. (Bi et al., [2023](#bib.bib10)) | $\times$ | $\times$ | $\times$
    | $\times$ | $\times$ | $\times$ |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 12 | Bi 等 (Bi 等, [2023](#bib.bib10)) | $\times$ | $\times$ | $\times$ | $\times$
    | $\times$ | $\times$ |'
- en: '| 12 | Our survey | $\checkmark$ | $\checkmark$ | $\checkmark$ | $\checkmark$
    | $\checkmark$ | $\checkmark$ |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 我们的调查 | $\checkmark$ | $\checkmark$ | $\checkmark$ | $\checkmark$ |
    $\checkmark$ | $\checkmark$ |'
- en: The columns in the table represent different aspects of the surveys, such as
    the data source used, representation, feature embedding, ML/DL models, vulnerability
    types, and interpretability of ML/DL models. Data Source indicates whether the
    survey reviewed vulnerability detection data sources. Representation discusses
    whether the survey considered source code representation in its analysis. Embedding
    deals with whether the survey is analyzed feature embedding in its analysis. The
    table also considers ML/DL models in the sixth column as ML Models. The table
    also checks whether the survey considers vulnerability types based on Common Weakness
    Enumeration (CWE) number. The last column indicates whether the survey takes into
    account the interpretability of ML/DL models.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的列代表了调查的不同方面，例如使用的数据源、表示方法、特征嵌入、机器学习/深度学习模型、漏洞类型以及机器学习/深度学习模型的可解释性。数据源列表示调查是否回顾了漏洞检测的数据源。表示方法列讨论了调查是否在分析中考虑了源代码表示。嵌入列处理了调查是否在分析中考虑了特征嵌入。表格的第六列将机器学习/深度学习模型列为**ML
    Models**。表格还检查了调查是否基于**Common Weakness Enumeration (CWE)** 编号考虑了漏洞类型。最后一列表示调查是否考虑了机器学习/深度学习模型的可解释性。
- en: 'Ghaffarian et al. (Ghaffarian and Shahriari, [2017](#bib.bib49)) is the closest
    survey to ours when it comes to data-driven security vulnerability detection.
    In their survey, they analyzed data-driven software vulnerability detection from
    various aspects including Data Sources, Representation, Embedding types, and different
    ML/DL models as shown in Table [1](#S2.T1 "Table 1 ‣ 2.2\. Related work ‣ 2\.
    Background and Related Work ‣ A Survey on Automated Software Vulnerability Detection
    Using Machine Learning and Deep Learning"). However, there are a couple of differences
    compared to our work. Specifically, this work also surveys vulnerability detection
    from the following aspects: Comprehensive Coverage: Understanding the many sorts
    of vulnerabilities allows researchers to create and develop effective vulnerability
    detection models that can thoroughly discover security vulnerabilities. To guarantee
    that their detection systems cover as many vulnerability types as possible, researchers
    must be familiar with the various methods of attack and potential weaknesses in
    software systems. Customization of Detection Techniques: Different sorts of vulnerabilities
    necessitate distinct detection methods. To build specialized detection systems
    that can discover certain types of vulnerabilities, researchers must first understand
    the subtleties of each vulnerability type. Prioritization of Mitigation Efforts:
    Researchers can prioritize mitigation efforts depending on the severity and effect
    of each vulnerability by understanding the many types of vulnerabilities. Critical
    vulnerabilities that pose the greatest danger to the system or organization can
    be prioritized by researchers. Better Understanding of Attack Patterns: Understanding
    the different types of vulnerabilities provides researchers with insights into
    the different attack patterns used by attackers. This knowledge helps researchers
    design detection techniques that can detect not only known attack patterns but
    also new, unknown patterns. Interpretability refers to the ability to explain
    how a model makes a particular decision or prediction. This is particularly important
    in the context of software vulnerability detection because security researchers
    need to be able to understand why a model is flagging a particular piece of code
    as potentially vulnerable. Additionally, interpretability can help improve trust
    in the model’s predictions. If developers and security researchers can understand
    how a model is making its decisions, they are more likely to trust its output
    and take appropriate actions based on its recommendations.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Ghaffarian 等人（Ghaffarian 和 Shahriari，[2017](#bib.bib49)）的研究是在数据驱动的安全漏洞检测方面最接近我们的调查。在他们的调查中，他们从数据源、表示方式、嵌入类型和不同的
    ML/DL 模型等各个方面分析了数据驱动的软件漏洞检测，如表[1](#S2.T1 "Table 1 ‣ 2.2\. Related work ‣ 2\. Background
    and Related Work ‣ A Survey on Automated Software Vulnerability Detection Using
    Machine Learning and Deep Learning")所示。然而，与我们的工作相比，有几个区别。具体来说，本研究还从以下方面对漏洞检测进行了调查：**全面覆盖**：了解各种漏洞类型使研究人员能够创建和开发有效的漏洞检测模型，从而彻底发现安全漏洞。为了确保他们的检测系统覆盖尽可能多的漏洞类型，研究人员必须熟悉各种攻击方法和软件系统中的潜在弱点。**检测技术的定制化**：不同类型的漏洞需要不同的检测方法。为了建立能够发现特定类型漏洞的专用检测系统，研究人员必须首先了解每种漏洞类型的细微差别。**缓解工作优先级**：通过了解多种漏洞类型，研究人员可以根据每种漏洞的严重程度和影响来优先考虑缓解工作。研究人员可以优先处理对系统或组织构成最大威胁的关键漏洞。**对攻击模式的更好理解**：了解不同类型的漏洞为研究人员提供了攻击者使用的不同攻击模式的见解。这种知识帮助研究人员设计检测技术，能够检测到已知的攻击模式以及新的、未知的模式。**可解释性**指的是解释模型如何做出特定决策或预测的能力。这在软件漏洞检测中尤其重要，因为安全研究人员需要了解模型为什么将特定代码标记为潜在的漏洞。此外，可解释性可以帮助提高对模型预测的信任。如果开发人员和安全研究人员能够理解模型如何做出决策，他们更有可能信任其输出并根据其建议采取适当的行动。
- en: Triet et al. (Le et al., [2021a](#bib.bib78)) reviewed data-driven vulnerability
    assessment and prioritization studies. They conduct a review of prior research
    on software assessment and prioritization that leverages machine learning and
    data mining methods. They examine various types of research in this area, discuss
    the strengths and weaknesses of each approach, and highlight some unresolved issues
    and potential areas for future research. The major difference to ours is that
    we review vulnerability detection approaches while they survey assessment and
    prioritization techniques. Vulnerability detection, vulnerability assessment,
    and vulnerability prioritization are all important components of the vulnerability
    management life-cycle, but they involve different stages of the vulnerability
    management process. Our work focuses on Vulnerability detection which refers to
    the process of identifying potential vulnerabilities in software systems. The
    goal of vulnerability detection is to identify all vulnerabilities that exist
    within the system, regardless of their severity. Vulnerability assessment, on
    the other hand, involves evaluating the severity and potential impact of each
    identified vulnerability. This assessment can involve analyzing factors such as
    the likelihood of the vulnerability being exploited and the potential harm that
    could result. Vulnerability prioritization involves ranking the identified vulnerabilities
    based on their level of risk or criticality. This ranking is typically based on
    the results of the vulnerability assessment, as well as other factors such as
    the availability of resources to address the vulnerabilities.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Triet 等人（Le 等人，[2021a](#bib.bib78)）回顾了基于数据的脆弱性评估和优先排序研究。他们对利用机器学习和数据挖掘方法的软件评估和优先排序的先前研究进行了综述。他们考察了该领域的各种研究类型，讨论了每种方法的优缺点，并突出了尚未解决的问题和未来研究的潜在方向。我们工作的主要区别在于，我们回顾了脆弱性检测方法，而他们调查了评估和优先排序技术。脆弱性检测、脆弱性评估和脆弱性优先排序都是脆弱性管理生命周期中的重要组成部分，但它们涉及脆弱性管理过程中的不同阶段。我们的工作侧重于脆弱性检测，即识别软件系统中潜在脆弱性的过程。脆弱性检测的目标是识别系统中存在的所有脆弱性，无论其严重性如何。另一方面，脆弱性评估涉及评估每个已识别脆弱性的严重性和潜在影响。这种评估可能涉及分析脆弱性被利用的可能性和可能造成的潜在伤害等因素。脆弱性优先排序涉及根据脆弱性的风险或重要性对识别出的脆弱性进行排序。这种排序通常基于脆弱性评估的结果，以及解决这些脆弱性所需的资源等其他因素。
- en: Lin et al. (Lin et al., [2020](#bib.bib90)) examined the literature on using
    deep learning and neural network-based approaches for detecting software vulnerabilities.
    There are a couple of differences compared to our survey. First, the study of
    conventional source code representation techniques (Static code attributes) for
    software vulnerability detection. In our survey, we neglect to review such representation
    techniques for a couple of reasons. Static code attributes, such as code length
    or complexity, may not be effective for vulnerability detection because they do
    not capture the dynamic behavior of the code at runtime. Vulnerabilities can manifest
    themselves in unexpected ways that are not apparent in the static code, making
    it difficult to detect them through static analysis alone. Additionally, static
    code attributes may not be able to capture the context of the code, which is important
    for understanding how the code interacts with other components in a system. Finally,
    static analysis tools may produce a high rate of false positives, which can be
    time-consuming to verify and may cause developers to ignore important vulnerabilities.
    Second, we examine the trend analysis of papers published in software vulnerability
    detection in a journal and conference papers because it provides a comprehensive
    understanding of the publishing patterns in a particular field or area of research.
    The trend analysis can shed light on the distribution of research output across
    various publication venues and the shifting preferences of researchers and authors.
    This information can be useful for stakeholders such as publishers, academic institutions,
    and researchers in making strategic decisions related to publishing, funding,
    and research collaborations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 林等（林等， [2020](#bib.bib90)）研究了使用深度学习和基于神经网络的方法检测软件漏洞的文献。与我们的调查相比，有几点不同。首先，该研究了传统的源代码表示技术（静态代码属性）用于软件漏洞检测。在我们的调查中，由于几个原因，我们忽略了对这些表示技术的评审。静态代码属性，例如代码长度或复杂性，可能在漏洞检测中效果不佳，因为它们未能捕捉代码在运行时的动态行为。漏洞可能以在静态代码中不明显的方式表现出来，这使得仅通过静态分析来检测它们变得困难。此外，静态代码属性可能无法捕捉代码的上下文，这对理解代码如何与系统中的其他组件交互非常重要。最后，静态分析工具可能产生较高的假阳性率，这可能耗时进行验证，并可能导致开发人员忽视重要的漏洞。其次，我们考察了在期刊和会议论文中发表的关于软件漏洞检测的论文的趋势分析，因为这提供了对特定领域或研究领域出版模式的全面理解。趋势分析可以揭示研究输出在各个出版场所的分布以及研究人员和作者的偏好变化。这些信息对于出版商、学术机构和研究人员等利益相关者在做出与出版、资金和研究合作相关的战略决策时具有参考价值。
- en: Zeng et al. (Zeng et al., [2020](#bib.bib152)) discussed the increasing attention
    towards exploitable vulnerabilities in software and the development of vulnerability
    detection methods, specifically the application of ML techniques. The paper reviews
    22 recent studies that use deep learning to detect vulnerabilities and identifies
    four game changers that have significantly impacted this field. The survey further
    compares the game changers based on different aspects in software vulnerability
    detection including data source, feature representation, DL models, and detection
    granularity. There are a couple of differences compared to our survey. First,
    we analyze the trend patterns of papers on software vulnerability detection that
    have been published in journals and conferences. This analysis helps us gain a
    thorough comprehension of the publication trends in a specific area of research
    or field. Second, we cover more aspects of software vulnerability detection. While
    they only cover data source, feature representation, DL models, and detection
    granularity, we cover more aspects including vulnerability types and interpretability
    of ML/DL models. Additionally, we provide a more granular analysis of different
    aspects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 曾等（曾等， [2020](#bib.bib152)）讨论了对软件中可利用漏洞的关注度不断增加以及漏洞检测方法的发展，特别是机器学习技术的应用。该论文回顾了22项使用深度学习检测漏洞的最新研究，并识别了四个在该领域产生显著影响的关键因素。调查进一步比较了这些关键因素在软件漏洞检测中的不同方面，包括数据来源、特征表示、深度学习模型和检测粒度。与我们的调查相比，有几点不同。首先，我们分析了在期刊和会议上发表的关于软件漏洞检测的论文的趋势模式。这一分析帮助我们深入理解特定研究领域或领域的出版趋势。其次，我们涵盖了更多的软件漏洞检测方面。尽管他们只涵盖了数据来源、特征表示、深度学习模型和检测粒度，但我们还包括了漏洞类型和机器学习/深度学习模型的可解释性等更多方面。此外，我们对不同方面进行了更细致的分析。
- en: Kritikos et al. (Kritikos et al., [2019](#bib.bib72)) and Sun et al. (Sun et al.,
    [2018](#bib.bib133)) focused on cybersecurity and aim to improve cyber resilience.
    Sun et al. (Sun et al., [2018](#bib.bib133)) discussed the paradigm change in
    understanding and protecting against cyber threats from reactive detection to
    proactive prediction, with an emphasis on new research on cybersecurity incident
    prediction systems that use many types of data sources. Kritikos et al. (Kritikos
    et al., [2019](#bib.bib72)) discusses the challenges of migrating applications
    to the cloud and ensuring their security, with a focus on vulnerability management
    during the application lifecycle and the use of open-source tools and databases
    to better secure applications. While the topics of the two abstracts are different,
    they share a common goal of improving cybersecurity and resilience. Both highlight
    the importance of proactive measures to prevent or mitigate cyber threats, rather
    than relying solely on reactive detection and response. Additionally, both highlight
    the importance of utilizing various data sources and tools to improve cybersecurity
    measures. While both approaches aim to improve the security of applications, they
    differ in their focus and techniques used. They mainly focus on providing guidance
    and tools to support vulnerability management during the application lifecycle,
    while in our survey, we focus on software vulnerability detection using ML/DL
    techniques on source code which aim at automating the identification of vulnerabilities
    in the source code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Kritikos等人（Kritikos et al.，[2019](#bib.bib72)）和Sun等人（Sun et al.，[2018](#bib.bib133)）专注于网络安全，旨在提高网络韧性。Sun等人（Sun
    et al.，[2018](#bib.bib133)）讨论了理解和防御网络威胁的范式变化，从反应性检测转向主动预测，重点是新研究的网络安全事件预测系统，这些系统使用多种数据源。Kritikos等人（Kritikos
    et al.，[2019](#bib.bib72)）讨论了将应用程序迁移到云端并确保其安全的挑战，重点是应用程序生命周期中的漏洞管理，以及使用开源工具和数据库来更好地保护应用程序。虽然这两个摘要的主题不同，但它们有一个共同的目标，即提高网络安全性和韧性。两者都强调了采取主动措施以防止或缓解网络威胁的重要性，而不是仅仅依赖反应性检测和响应。此外，两者都强调了利用各种数据源和工具来改进网络安全措施的重要性。虽然两种方法都旨在提高应用程序的安全性，但它们在重点和使用的技术上有所不同。它们主要侧重于提供指导和工具，以支持应用程序生命周期中的漏洞管理，而在我们的调查中，我们专注于使用ML/DL技术在源代码中进行软件漏洞检测，旨在自动化识别源代码中的漏洞。
- en: Khan et al. (Khan and Parkinson, [2018](#bib.bib70)) focused on Vulnerability
    Assessment, which is the process of finding and fixing vulnerabilities in a computer
    system before they can be exploited by hackers. This highlights the necessity
    for more studies into automated vulnerability mitigation strategies that can effectively
    secure software systems. On the other hand, vulnerability identification with
    ML/DL approaches on source code entails analyzing an application’s source code
    in order to spot security flaws. Instead of evaluating the safety of the entire
    system, this method concentrates on finding vulnerabilities in the code itself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Khan等人（Khan and Parkinson，[2018](#bib.bib70)）专注于漏洞评估，这是在黑客利用漏洞之前找到并修复计算机系统中的漏洞的过程。这突出了对自动化漏洞缓解策略的更多研究的必要性，这些策略可以有效地保护软件系统。另一方面，使用ML/DL方法在源代码中进行漏洞识别涉及分析应用程序的源代码以发现安全缺陷。这种方法不是评估整个系统的安全性，而是集中在发现代码本身中的漏洞。
- en: Nong et al.(Nong et al., [2022](#bib.bib112)) explored the open-science aspects
    of studies on software vulnerability detection and argued there is a dearth of
    research on problems of open science in software engineering, particularly with
    regard to software vulnerability detection. The authors conducted an exhaustive
    literature study and identify 55 relevant works that propose deep learning-based
    vulnerability detection approaches. They investigated open science aspects including
    availability, executability, reproducibility, and replicability. The study reveals
    that 25.5% of the examined approaches provide open-source tools. Furthermore,
    some open-source tools lack adequate documentation and thorough implementation,
    rendering them inoperable or unreplicable. The use of unbalanced or intentionally
    produced datasets causes the approaches’ performance to be overstated, rendering
    them unreplicable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Nong 等人（Nong et al., [2022](#bib.bib112)）探讨了软件漏洞检测研究中的开放科学方面，并认为在软件工程中，特别是关于软件漏洞检测的开放科学问题研究不足。作者进行了详尽的文献研究，并确定了
    55 项相关工作，这些工作提出了基于深度学习的漏洞检测方法。他们调查了开放科学方面的问题，包括可用性、可执行性、可重复性和可复制性。研究揭示，25.5% 的被检查方法提供了开源工具。此外，一些开源工具缺乏充分的文档和详细的实现，导致其不可操作或不可复制。使用不平衡或故意产生的数据集导致方法的性能被夸大，从而使其不可复制。
- en: Chakraborty et al. (Chakraborty et al., [2021](#bib.bib20)) investigated the
    performance of cutting-edge DL-based vulnerability prediction approaches in real-world
    vulnerability prediction scenarios. They find that the performance of the state-of-the-art
    DL-based techniques drops by more than 50 percent in real-world scenarios. They
    also discover problems with training data (for example, data duplication and an
    unrealistic distribution of vulnerable classes) and model selection (for example,
    simplistic token-based models). Existing DL-based approaches often learn unrelated
    artifacts instead of features related to the cause of vulnerabilities. The significant
    difference compared to our survey study is that in our work, we focus on the usage
    of ML/DL models for software vulnerability detection and characterize the different
    stages in the pipeline of vulnerability detection. On the other hand, they focus
    on the issues related to the usage of state-of-the-art DL models for software
    vulnerability detection.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Chakraborty 等人（Chakraborty et al., [2021](#bib.bib20)）调查了前沿深度学习（DL）基于的漏洞预测方法在实际漏洞预测场景中的表现。他们发现，最先进的
    DL 技术在实际场景中的性能下降超过 50%。他们还发现了训练数据的问题（例如数据重复和漏洞类别的不现实分布）以及模型选择的问题（例如简化的基于 token
    的模型）。现有的 DL 基于方法往往学习到与漏洞原因无关的伪影。与我们的调查研究相比，显著的不同在于我们的工作集中于机器学习/深度学习（ML/DL）模型在软件漏洞检测中的使用，并描述了漏洞检测流程中的不同阶段。而他们则关注于最先进的
    DL 模型在软件漏洞检测中的使用问题。
- en: 'Liu et al. (Liu et al., [2021a](#bib.bib94)) discussed the increasing popularity
    of DL techniques in software engineering research due to their ability to address
    SE challenges without extensive manual feature engineering. The authors highlight
    two important factors often overlooked in DL studies: reproducibility and replicability.
    Reproducibility refers to whether other researchers can obtain the same results
    using the authors’ artifacts, while replicability refers to obtaining similar
    results with re-implemented artifacts and a different experimental setup. The
    major difference compared to our study is that we focus on the usage of ML/DL
    techniques in software vulnerability detection pipelines, while they emphasize
    replicability and reproducibility of the results reported in software engineering
    research studies.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Liu 等人（Liu et al., [2021a](#bib.bib94)）讨论了深度学习（DL）技术在软件工程研究中的日益流行，原因是它们能够在没有广泛的手动特征工程的情况下解决软件工程挑战。作者强调了
    DL 研究中常被忽视的两个重要因素：可重复性和可复制性。可重复性指的是其他研究者是否可以使用作者的工具获得相同的结果，而可复制性指的是在不同的实验设置下使用重新实现的工具获得类似的结果。与我们的研究相比，主要的不同在于我们关注
    ML/DL 技术在软件漏洞检测流程中的应用，而他们则强调软件工程研究中报告结果的可复制性和可重复性。
- en: Bi et al. (Bi et al., [2023](#bib.bib10)) emphasizes the importance of software
    vulnerability detection techniques as well as the absence of a systematic methodology
    to evaluate these approaches. The research is the first to look into and describe
    the current state of software vulnerability detection benchmarking. The assessment
    examines current literature on vulnerability detection benchmarking, including
    methodologies employed in technique-proposing publications and empirical research.
    The survey examines the difficulties associated with benchmarking software vulnerability
    detection approaches and suggests alternative solutions to these difficulties.
    They do not, however, give a characterization of datasets, representations, embedding
    techniques, and models employed in software vulnerability identification, unlike
    our work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Bi et al.（Bi et al., [2023](#bib.bib10)）强调了软件漏洞检测技术的重要性以及缺乏系统性评估这些方法的标准。该研究首次探讨并描述了软件漏洞检测基准测试的现状。评估检查了现有文献中的漏洞检测基准，包括在技术提出的出版物和实证研究中使用的方法。调查考察了与漏洞检测基准相关的困难，并建议了应对这些困难的替代解决方案。然而，他们并未像我们的工作那样对数据集、表示法、嵌入技术和用于软件漏洞识别的模型进行详细描述。
- en: 3\. Methodology of Systematic Survey
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3. 方法论的系统调查
- en: 3.1\. Sources of Information
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 信息来源
- en: 'In this paper, we conducted an empirical study following (Keele et al., [2007](#bib.bib69);
    Petersen et al., [2015](#bib.bib116)). The purpose of this study is to collect
    and examine papers from the year 2011 to 2022 focusing on vulnerability detection
    across various programming languages and source codes using machine learning and
    deep learning techniques. The period between 2011 and 2022 is an appropriate time
    interval for reviewing data-driven vulnerability detection for several reasons:
    a) Increase in the volume and diversity of software vulnerabilities: Over the
    past decade, there has been a significant increase in the number and diversity
    of software vulnerabilities that have been discovered and reported ²²2https://nvd.nist.gov/general/news.
    As of 2021, there exist 150,000 CVE records in the National Vulnerability Database
    (NVD)³³3https://nvd.nist.gov/general/brief-history. This increase has created
    a need for more sophisticated and effective methods for vulnerability detection,
    which has led to the development of new data-driven techniques. b) Advancements
    in ML/DL and data analytics: The past decade has seen significant advancements
    in machine learning, including the development of deep learning algorithms (Goodfellow
    et al., [2020](#bib.bib53); Hinton et al., [2006](#bib.bib60)), natural language
    processing techniques (Devlin et al., [2018](#bib.bib35); Liu et al., [2019b](#bib.bib97)),
    and other data-driven approaches that are highly effective in detecting software
    vulnerabilities.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们进行了实证研究，参考了（Keele et al., [2007](#bib.bib69); Petersen et al., [2015](#bib.bib116)）。本研究的目的是收集和审查2011年至2022年间关于利用机器学习和深度学习技术进行漏洞检测的各类编程语言和源代码的论文。2011年至2022年这一时间段适合回顾数据驱动的漏洞检测，原因有以下几点：a)
    软件漏洞的数量和多样性的增加：在过去十年里，发现和报告的软件漏洞数量及其多样性显著增加²²2https://nvd.nist.gov/general/news。截至2021年，国家漏洞数据库（NVD）中存在150,000个CVE记录³³3https://nvd.nist.gov/general/brief-history。这一增加促使需要更复杂有效的漏洞检测方法，从而推动了新的数据驱动技术的发展。b)
    机器学习/深度学习及数据分析的进展：过去十年中，机器学习取得了显著进展，包括深度学习算法的开发（Goodfellow et al., [2020](#bib.bib53);
    Hinton et al., [2006](#bib.bib60)）、自然语言处理技术（Devlin et al., [2018](#bib.bib35);
    Liu et al., [2019b](#bib.bib97)）以及其他在检测软件漏洞方面效果显著的数据驱动方法。
- en: While we start collecting papers, we search for relevant research papers from
    four available databases, which are ScienceDirect, IEEE Xplore, ACM digital library,
    and Google Scholar.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始收集论文时，我们从四个可用的数据库中搜索相关的研究论文，这些数据库是ScienceDirect、IEEE Xplore、ACM数字图书馆和Google
    Scholar。
- en: 3.2\. Search Terms
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2. 搜索词
- en: 'From earlier work, we identify key phrases used in the search (Le et al., [2021a](#bib.bib78);
    Lin et al., [2020](#bib.bib90); Zeng et al., [2020](#bib.bib152); Semasaba et al.,
    [2020](#bib.bib126)) and our experience with the subject area. The following are
    the search terms:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从早期的工作中，我们识别出用于搜索的关键短语（Le et al., [2021a](#bib.bib78); Lin et al., [2020](#bib.bib90);
    Zeng et al., [2020](#bib.bib152); Semasaba et al., [2020](#bib.bib126)）以及我们在该领域的经验。以下是搜索词：
- en: vulnerability detection OR security vulnerability detection OR vulnerability
    detection using machine learning OR vulnerability detection using deep learning
    OR source code security bug prediction OR source code vulnerability detection
    OR source code bug prediction
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞检测 OR 安全漏洞检测 OR 使用机器学习的漏洞检测 OR 使用深度学习的漏洞检测 OR 源代码安全错误预测 OR 源代码漏洞检测 OR 源代码错误预测
- en: 3.3\. Study Selection
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 研究选择
- en: 'The process of selecting studies to be included in our survey involves the
    following stages: (1) initially choosing studies based on their title, (2) selecting
    studies after reviewing their abstracts, and (3) making further selections after
    reading the full papers. Note that, the initial search results contain entries
    that are not related to security vulnerability detection. This might be caused
    by accidental keyword matching. We manually check each paper and remove these
    irrelevant papers to ensure the quality of our survey dataset. We also observe
    that there exist duplicate papers among search results since the same study could
    be indexed by multiple databases. We then discarded duplicate studies manually.
    To assist the selection of papers that have presented new ML or DL-based models
    for software vulnerability identification, we provide the following inclusion
    and exclusion criteria:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 选择纳入我们调查的研究的过程包括以下阶段：(1) 根据标题初步选择研究，(2) 在审查摘要后选择研究，(3) 阅读全文后进一步选择。请注意，初步搜索结果包含与安全漏洞检测无关的条目。这可能是由于偶然的关键词匹配造成的。我们手动检查每篇论文，并移除这些不相关的论文，以确保我们调查数据集的质量。我们还观察到搜索结果中存在重复的论文，因为相同的研究可能被多个数据库索引。然后我们手动丢弃重复的研究。为了帮助选择那些提出了新的基于ML或DL的模型用于软件漏洞识别的论文，我们提供了以下纳入和排除标准：
- en: •
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: The studies should have been peer-reviewed
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 研究应经过同行评审
- en: •
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: The studies should have experimental results
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 研究应具有实验结果
- en: •
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: The studies should employ an ML or DL technique
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 研究应采用ML或DL技术
- en: •
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: The studies improve existing data-driven vulnerability detection techniques
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 研究应改进现有的数据驱动漏洞检测技术
- en: •
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: The input to ML/DL models should be either source code, commit, or byte-codes
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ML/DL模型的输入应为源代码、提交记录或字节码
- en: 'Also, we have the following exclusion criteria to filter out irrelevant papers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还制定了以下排除标准以筛选出不相关的论文：
- en: •
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Studies focusing on other engineering domains
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关注其他工程领域的研究
- en: •
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Studies addressing static analysis, dynamic analysis, mutation testing, fault
    localization
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理静态分析、动态分析、突变测试、故障定位的研究
- en: •
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Review papers
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 综述论文
- en: •
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Studies focusing on vulnerability detection of web and Android applications
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关注网络和Android应用程序漏洞检测的研究
- en: •
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: 'Studies belonging to one of the following categories: books, chapters, tutorials,
    technical reports'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 研究属于以下类别之一：书籍、章节、教程、技术报告
- en: •
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Studies using code similarity or clone detection tools
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用代码相似性或克隆检测工具的研究
- en: •
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Studies focusing on malware detection on mobile devices, intrusion detection,
    and bug detection using static code attributes
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关注移动设备上的恶意软件检测、入侵检测以及使用静态代码属性的错误检测的研究
- en: Using these criteria, we narrow down our findings by examining each paper’s
    title, abstract, and contents to get the most relevant and high-quality research
    papers. To make human effort manageable, we developed a script to automatically
    get high-quality records close to the software vulnerability detection problem.
    To summarize, in the first stage, we began with a total of 3,154 papers obtained
    from the database search. From this initial pool, 880 papers were chosen for further
    evaluation in the second stage. During the second stage, these papers were reviewed
    based on their abstracts, resulting in the selection of 116 papers with relevant
    abstracts. Finally, in the third stage, after reading the full papers, 67 papers
    were ultimately chosen for inclusion in the study.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些标准，我们通过检查每篇论文的标题、摘要和内容来缩小我们的发现，以获取最相关和高质量的研究论文。为了使人工工作量可管理，我们开发了一个脚本来自动获取与软件漏洞检测问题相关的高质量记录。总之，在第一阶段，我们从数据库搜索中获得了总共3,154篇论文。从这个初步池中，选择了880篇论文进入第二阶段进一步评估。在第二阶段，这些论文根据其摘要进行了审查，最终选择了116篇摘要相关的论文。最后，在第三阶段，经过阅读全文，最终选择了67篇论文纳入研究。
- en: 3.4\. Study Quality Assessment
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 研究质量评估
- en: 'For each of the final selected studies, we answered the questions below to
    assess its quality:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每项最终选择的研究，我们回答了以下问题以评估其质量：
- en: •
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Is there a clearly stated research goal related to software vulnerability detection?
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是否有明确陈述的软件漏洞检测相关研究目标？
- en: •
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Is the proposed vulnerability detection approach used ML or DL techniques?
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提出的漏洞检测方法是否使用了**ML**或**DL**技术？
- en: •
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Is there a defined and repeatable technique?
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是否存在明确且可重复的技术？
- en: •
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Is there any explicit contribution to vulnerability detection?
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是否有明确的贡献于漏洞检测？
- en: •
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Is there a clear methodology for validating the technique?
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是否有明确的方法论用于验证该技术？
- en: •
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Are the subject projects selected for validation suitable for the research goals?
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选定用于验证的主题项目是否适合研究目标？
- en: •
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Are there control techniques or baselines to demonstrate the effectiveness of
    the vulnerability detection technique?
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是否有控制技术或基准来展示漏洞检测技术的有效性？
- en: •
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Are the evaluation metrics relevant (e.g., evaluate the effectiveness of the
    proposed technique) to the research objectives?
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 评估指标是否与研究目标相关（例如，评估提出技术的有效性）？
- en: •
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: Do the results presented in the study align with the research objectives and
    are they presented in a clear and relevant manner?
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 研究中呈现的结果是否符合研究目标，并且以清晰和相关的方式展示？
- en: 3.5\. Selection Verification
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5\. 选择验证
- en: The process of creating a taxonomy for the selected 67 primary studies involves
    several steps. Initially, the lead author establishes a preliminary taxonomy that
    groups the studies together based on their research questions. This taxonomy provides
    a basic framework for organizing the studies in a meaningful and systematic manner.
    Next, the lead author expands the taxonomy by assigning new papers to the preliminary
    taxonomy. If a new paper cannot fit into any of the existing categories within
    the taxonomy, a new category is created that reflects the unique characteristics
    of that paper. To ensure the accuracy of the taxonomy, the second and third authors
    (who are not involved in the taxonomy creation process) randomly select 20 papers
    from the workflow and check the created taxonomies for any discrepancies. They
    then mark any disagreements they find, and all three authors discuss and resolve
    these disagreements. Initially, the disagreement rate was 30%, but after a second
    round of review and cross-checking of the papers, the authors were able to eliminate
    all disagreements.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所选 67 项主要研究的分类法过程涉及几个步骤。最初，首席作者建立了一个初步分类法，将研究基于其研究问题进行分组。该分类法为以有意义和系统的方式组织研究提供了基本框架。接下来，首席作者通过将新论文分配到初步分类法中来扩展分类法。如果新论文无法适应分类法中的任何现有类别，则会创建一个反映该论文独特特征的新类别。为了确保分类法的准确性，第二和第三作者（未参与分类法创建过程）从工作流程中随机选择
    20 篇论文，检查创建的分类法是否存在任何差异。他们然后标记发现的任何分歧，所有三位作者讨论并解决这些分歧。最初，分歧率为 30%，但经过第二轮审查和论文交叉检查后，作者们能够消除所有分歧。
- en: '![Refer to caption](img/7283c42516e7cf1463a0cf8512b5f688.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![参考说明](img/7283c42516e7cf1463a0cf8512b5f688.png)'
- en: Figure 1. The workflow of our survey.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1. 我们调查的工作流程。
- en: 4\. Results
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4\. 结果
- en: We present our analyses and findings in this section to address the research
    questions we devised in Section [1](#S1 "1\. Introduction ‣ A Survey on Automated
    Software Vulnerability Detection Using Machine Learning and Deep Learning").
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一部分展示我们的分析和发现，以回答在第[1](#S1 "1\. 介绍 ‣ 基于机器学习和深度学习的自动化软件漏洞检测调查")节中提出的研究问题。
- en: 4.1\. RQ1\. What is the trend of studies using ML/DL models for vulnerability
    detection?
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. RQ1\. 使用**ML/DL**模型进行漏洞检测的研究趋势是什么？
- en: To comprehend the trend of publications, we examined the publication dates along
    with the venues in which they were presented.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解出版物的趋势，我们检查了出版日期以及它们发表的场所。
- en: 4.1.1\. RQ1.1\. What are the trends of studies in software vulnerability detection
    over time?
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. RQ1.1\. 随着时间推移，软件漏洞检测研究的趋势是什么？
- en: Figure [2](#S4.F2 "Figure 2 ‣ 4.1.1\. RQ1.1\. What are the trends of studies
    in software vulnerability detection over time? ‣ 4.1\. RQ1\. What is the trend
    of studies using ML/DL models for vulnerability detection? ‣ 4\. Results ‣ A Survey
    on Automated Software Vulnerability Detection Using Machine Learning and Deep
    Learning") demonstrates the publication trend of vulnerability detection studies
    published in eleven years, i.e., between 2011 and 2022\. It is observable that
    the number of publications has increased gradually over the years. There is only
    one publication from 2011 to 2016, and the number of publications increased to
    18 in 2021\. However, there is a decrease in the number of publications in 2022
    compared to the previous year. We have also examined the cumulative number of
    publications shown in Figure [2](#S4.F2 "Figure 2 ‣ 4.1.1\. RQ1.1\. What are the
    trends of studies in software vulnerability detection over time? ‣ 4.1\. RQ1\.
    What is the trend of studies using ML/DL models for vulnerability detection? ‣
    4\. Results ‣ A Survey on Automated Software Vulnerability Detection Using Machine
    Learning and Deep Learning"). It is noticeable that the curve fitting the distribution
    shows a significant increase in slope between 2018 and 2022 suggesting that the
    use of ML/DL techniques for software vulnerability detection has become a prevalent
    trend since 2017, and a broad range of studies have utilized ML/DL models to address
    challenges in this field.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2](#S4.F2 "Figure 2 ‣ 4.1.1\. RQ1.1\. What are the trends of studies in software
    vulnerability detection over time? ‣ 4.1\. RQ1\. What is the trend of studies
    using ML/DL models for vulnerability detection? ‣ 4\. Results ‣ A Survey on Automated
    Software Vulnerability Detection Using Machine Learning and Deep Learning")展示了2011年至2022年间，漏洞检测研究的出版趋势。可以观察到，出版数量逐年增加。从2011年到2016年只有一篇出版物，而到2021年，出版物数量增加到18篇。然而，与前一年相比，2022年的出版物数量有所减少。我们还检查了图[2](#S4.F2
    "Figure 2 ‣ 4.1.1\. RQ1.1\. What are the trends of studies in software vulnerability
    detection over time? ‣ 4.1\. RQ1\. What is the trend of studies using ML/DL models
    for vulnerability detection? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning")中显示的累计出版物数量。值得注意的是，拟合分布的曲线在2018年至2022年之间显示出显著的斜率增加，表明自2017年以来，使用**机器学习/深度学习**技术进行软件漏洞检测已成为一种普遍趋势，广泛的研究利用了**ML/DL**模型来应对这一领域的挑战。
- en: <svg   height="100.52" overflow="visible" version="1.1" width="248.12"><g transform="translate(0,100.52)
    matrix(1 0 0 -1 0 0) translate(25.47,0) translate(0,25.97) matrix(0.6 0.0 0.0
    0.6 -25.47 -25.97)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g transform="matrix(1
    0 0 1 0 0) translate(85.23,0) translate(0,54.26)"><g stroke="#000000" fill="#000000"
    stroke-width="0.4pt"><g transform="matrix(1.0 0.0 0.0 1.0 271.4 -30.7)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2022</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 242.88 -30.7)" fill="#000000" stroke="#000000"><foreignobject width="27.67"
    height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2021</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 214.35 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2020</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 185.83 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2019</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 157.31 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2018</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 128.78 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2017</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 100.26 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2016</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 71.73 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2015</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 43.21 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2014</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 14.69 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2013</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -13.84 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2011</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -54.59 -8.77)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -54.59 12.78)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$5$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -61.51 34.32)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$10$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -61.51 55.86)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$15$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -61.51 77.4)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$20$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 278.32 60.9)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="13.84" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$14$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 249.8 78.13)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$18$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 224.73 26.43)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$6$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 196.21 39.36)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$9$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 167.68 39.36)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$9$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 139.16 26.43)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$6$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 110.64 4.89)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 82.11 4.89)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 53.59 4.89)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 25.06 4.89)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -3.46 4.89)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 128.76 -49.65)" fill="#000000" stroke="#000000"><foreignobject width="27.71"
    height="9.46" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Year</foreignobject></g><g
    transform="matrix(0.0 1.0 -1.0 0.0 -71.01 -35.41)" fill="#000000" stroke="#000000"><foreignobject
    width="143.67" height="9.61" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Number
    of Publications</foreignobject></g></g></g></g></svg><svg height="101.67" overflow="visible"
    version="1.1" width="251.81"><g transform="translate(0,101.67) matrix(1 0 0 -1
    0 0) translate(29.16,0) translate(0,25.97) matrix(0.6 0.0 0.0 0.6 -29.16 -25.97)"
    fill="#000000" stroke="#000000" stroke-width="0.4pt"><g transform="matrix(1 0
    0 1 0 0) translate(91.38,0) translate(0,54.26)"><g stroke="#000000" fill="#000000"
    stroke-width="0.4pt"><g transform="matrix(1.0 0.0 0.0 1.0 -13.84 -30.7)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2011</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 14.69 -30.7)" fill="#000000" stroke="#000000"><foreignobject width="27.67"
    height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2013</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 43.21 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2014</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 71.73 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2015</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 100.26 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2016</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 128.78 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2017</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 157.31 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2018</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 185.83 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2019</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 214.35 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2020</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 242.88 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2021</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 271.4 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2022</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -54.59 -5.2)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -67.66 31.79)" fill="#000000" stroke="#000000"><foreignobject
    width="19.99" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0.5$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -54.59 68.78)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -18.6 4.89)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="37.21" height="11.41" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1\cdot 10^{-2}$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 9.92 5.63)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="37.21" height="11.41" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2\cdot
    10^{-2}$</foreignobject></g><g transform="matrix(1.0 0.0 0.0 1.0 38.44 7.11)"
    fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject width="37.21" height="11.41"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$4\cdot 10^{-2}$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 66.97 7.85)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="37.21" height="11.41" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$5\cdot 10^{-2}$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 95.49 9.33)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="37.21" height="11.41" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$7\cdot
    10^{-2}$</foreignobject></g><g transform="matrix(1.0 0.0 0.0 1.0 129.17 15.99)"
    fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject width="26.91" height="8.92"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0.16$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 157.69 25.6)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="26.91" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$0.29$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 186.21 35.96)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="26.91" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0.43$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 214.74 42.62)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="26.91" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$0.52$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 243.26 62.59)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="26.91" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0.79$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 281.78 78.13)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 128.76 -49.65)" fill="#000000" stroke="#000000"><foreignobject width="27.71"
    height="9.46" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Year</foreignobject></g><g
    transform="matrix(0.0 1.0 -1.0 0.0 -77.16 -37.33)" fill="#000000" stroke="#000000"><foreignobject
    width="148.67" height="9.61" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Cumulative
    Distribution</foreignobject></g></g></g></g></svg>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`<svg height="100.52" overflow="visible" version="1.1" width="248.12"><g transform="translate(0,100.52)
    matrix(1 0 0 -1 0 0) translate(25.47,0) translate(0,25.97) matrix(0.6 0.0 0.0
    0.6 -25.47 -25.97)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g transform="matrix(1
    0 0 1 0 0) translate(85.23,0) translate(0,54.26)"><g stroke="#000000" fill="#000000"
    stroke-width="0.4pt"><g transform="matrix(1.0 0.0 0.0 1.0 271.4 -30.7)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2022</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 242.88 -30.7)" fill="#000000" stroke="#000000"><foreignobject width="27.67"
    height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2021</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 214.35 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2020</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 185.83 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2019</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 157.31 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2018</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 128.78 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2017</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 100.26 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2016</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 71.73 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2015</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 43.21 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2014</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 14.69 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2013</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -13.84 -30.7)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2011</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -54.59 -8.77)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -54.59 12.78)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$5$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -61.51 34.32)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$10$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -61.51 55.86)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$15$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -61.51 77.4)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$20$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 278.32 60.9)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="13.84" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$14$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 249.8 78.13)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$18$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 224.73 26.43)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$6$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 196.21 39.36)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$9$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 167.68 39.36)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$9$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 139.16 26.43)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$6$</foreignobject></g><g
    transform="matrix(1.0'
- en: Figure 2. Publication trend of vulnerability detection studies.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2. 漏洞检测研究的发表趋势。
- en: Table 2. Conference publication venues for manual search.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表2. 手动搜索的会议发表场所。
- en: '| No | Acronym | Full name |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| No | 缩写 | 全称 |'
- en: '| --- | --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | ICSE | International Conference on Software Engineering |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ICSE | 软件工程国际会议 |'
- en: '| 2 | ECSE/FSE | ACM SIGSOFT Symposium on the Foundation of Software Engineering
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 2 | ECSE/FSE | ACM SIGSOFT软件工程基础研讨会 |'
- en: '| 3 | ASE | IEEE/ACM International Conference on Automated Software Engineering
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 3 | ASE | IEEE/ACM自动化软件工程国际会议 |'
- en: '| 4 | USENIX | USENIX |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 4 | USENIX | USENIX |'
- en: '| 5 | OOPSLA | Object-oriented Programming, Systems, Languages, and Applications
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 5 | OOPSLA | 面向对象编程、系统、语言与应用 |'
- en: '| 6 | ISSTA | ACM SIGSOFT International Symposium on Software Testing and Analysis
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 6 | ISSTA | ACM SIGSOFT软件测试与分析国际研讨会 |'
- en: '| 7 | MSR | IEEE Working Conference on Mining Software Repositories |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 7 | MSR | IEEE挖掘软件库工作会议 |'
- en: '| 8 | SANER | IEEE International Conference on Software Analysis, Evolution
    and Reengineering |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 8 | SANER | IEEE国际软件分析、演化与重构会议 |'
- en: '| 9 | ISSRE | IEEE International Symposium on Software Reliability Engineering
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 9 | ISSRE | IEEE软件可靠性工程国际研讨会 |'
- en: '| 10 | ICSME | IEEE International Conference on Software Maintenance and Evolution
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 10 | ICSME | IEEE国际软件维护与演化会议 |'
- en: '| 11 | IJCAI | International Joint Conferences on Artificial Intelligence Organization
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 11 | IJCAI | 国际人工智能联合会议组织 |'
- en: '| 12 | CCS | ACM SIGSAC Conference on Computer and Communications Security
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 12 | CCS | ACM SIGSAC计算机与通信安全会议 |'
- en: '| 13 | ICLR | International Conference on Learning Representations |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 13 | ICLR | 学习表征国际会议 |'
- en: '| 14 | NIPS | International Conference on Neural Information Processing Systems
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 14 | NIPS | 神经信息处理系统国际会议 |'
- en: '| 15 | MASCOT | Modelling, Analysis, and Simulation of Computer and Telecommunication
    Systems |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 15 | MASCOT | 计算机与电信系统的建模、分析与模拟 |'
- en: '| 16 | QRS | IEEE International Conference on Software Security and Reliability
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 16 | QRS | IEEE国际软件安全与可靠性会议 |'
- en: '| 17 | KDDM | Pacific-Asia Conference on Knowledge Discovery and Data Mining
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 17 | KDDM | 太平洋-亚洲知识发现与数据挖掘会议 |'
- en: '| 18 | NDSS | Network and Distributed Systems Security Symposium |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 18 | NDSS | 网络与分布式系统安全研讨会 |'
- en: '| 19 | ARES | ACM International Conference on Availability, Reliability and
    Security |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 19 | ARES | ACM国际可用性、可靠性与安全会议 |'
- en: '| 20 | INFOCOM | IEEE International Workshop on Security and Privacy in Big
    Data |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 20 | INFOCOM | IEEE大数据安全与隐私国际研讨会 |'
- en: '| 21 | ICTAI | IEEE International Conference on Tools with Artificial Intelligence
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 21 | ICTAI | IEEE人工智能工具国际会议 |'
- en: '| 22 | ICDM | IEEE International Conference on Data Mining |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 22 | ICDM | IEEE国际数据挖掘会议 |'
- en: '| 23 | GLOBCOM | IEEE Global Communications Conference |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 23 | GLOBCOM | IEEE全球通信会议 |'
- en: '| 24 | TrustCom | IEEE International Conference on Trust, Security and Privacy
    in Computing and Communications |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 24 | TrustCom | IEEE计算与通信中的信任、安全与隐私国际会议 |'
- en: '| 25 | DSAA | IEEE International Conference on Data Science and Advanced Analytic
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 25 | DSAA | IEEE国际数据科学与高级分析会议 |'
- en: Table 3. Journal publication venues for manual search.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 表3. 手动搜索的期刊发表场所。
- en: '| No | Journal Acronym | Full Name |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| No | 期刊缩写 | 全称 |'
- en: '| --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | TSE | IEEE Transaction on Software Engineering |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 1 | TSE | IEEE软件工程期刊 |'
- en: '| 2 | TOSEM | ACM Transaction on Software Engineering and Methodology |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 2 | TOSEM | ACM软件工程与方法学期刊 |'
- en: '| 3 | IST | Information and Software Technology |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 3 | IST | 信息与软件技术 |'
- en: '| 4 | ESM | Empirical Software Engineering |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 4 | ESM | 实证软件工程 |'
- en: '| 5 | JSS | Journal of System and Software |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 5 | JSS | 系统与软件期刊 |'
- en: '| 6 | TDSC | IEEE Transaction on Dependable and Secure Computing |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 6 | TDSC | IEEE可靠与安全计算期刊 |'
- en: '| 7 | CSJ | Computer and Security Journal |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 7 | CSJ | 计算机与安全期刊 |'
- en: '| 8 | TIFS | IEEE Transactions on Information Forensics and Security |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 8 | TIFS | IEEE信息取证与安全期刊 |'
- en: '| 9 | ISJ | Information Sciences Journal |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 9 | ISJ | 信息科学期刊 |'
- en: '| 10 | TFS | IEEE Transaction on Fuzzy Systems |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 10 | TFS | IEEE模糊系统期刊 |'
- en: '| 11 | TKDE | IEEE Transaction on Knowledge and Data Engineering |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 11 | TKDE | IEEE知识与数据工程期刊 |'
- en: '| 12 | KBS | Knowledge-Based Systems |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 12 | KBS | 知识基础系统 |'
- en: '4.1.2\. RQ1.2: What is the distribution of the publication venues?'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '4.1.2. RQ1.2: 发表场所的分布情况如何？'
- en: 'In this study, overall, we analyzed and reviewed 67 papers from various publication
    venues including 43 conference and symposium papers along with 24 journal papers.
    We have included the conference and journal acronyms and their complete names
    for reference in Table [2](#S4.T2 "Table 2 ‣ 4.1.1\. RQ1.1\. What are the trends
    of studies in software vulnerability detection over time? ‣ 4.1\. RQ1\. What is
    the trend of studies using ML/DL models for vulnerability detection? ‣ 4\. Results
    ‣ A Survey on Automated Software Vulnerability Detection Using Machine Learning
    and Deep Learning") and Table [3](#S4.T3 "Table 3 ‣ 4.1.1\. RQ1.1\. What are the
    trends of studies in software vulnerability detection over time? ‣ 4.1\. RQ1\.
    What is the trend of studies using ML/DL models for vulnerability detection? ‣
    4\. Results ‣ A Survey on Automated Software Vulnerability Detection Using Machine
    Learning and Deep Learning"). Table [4](#S4.T4 "Table 4 ‣ 4.1.2\. RQ1.2: What
    is the distribution of the publication venues? ‣ 4.1\. RQ1\. What is the trend
    of studies using ML/DL models for vulnerability detection? ‣ 4\. Results ‣ A Survey
    on Automated Software Vulnerability Detection Using Machine Learning and Deep
    Learning") shows the distribution of primary studies for each publication venue.
    64.1% of publications are published in conferences and symposiums while 35.8%
    of papers have been published as journal papers. It is observable that MSR, IJCAI,
    and ECSE/FSE are the most popular venues that have the highest number of primary
    studies, each of which contains 4 papers. Meanwhile, among the journals, TDSC
    and TSE include the highest number of studies, i.e., 6 and 4 studies respectively.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '在本研究中，我们总体上分析和回顾了来自不同出版场所的67篇论文，其中包括43篇会议和研讨会论文，以及24篇期刊论文。我们在表格[2](#S4.T2 "Table
    2 ‣ 4.1.1\. RQ1.1\. What are the trends of studies in software vulnerability detection
    over time? ‣ 4.1\. RQ1\. What is the trend of studies using ML/DL models for vulnerability
    detection? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection
    Using Machine Learning and Deep Learning")和表格[3](#S4.T3 "Table 3 ‣ 4.1.1\. RQ1.1\.
    What are the trends of studies in software vulnerability detection over time?
    ‣ 4.1\. RQ1\. What is the trend of studies using ML/DL models for vulnerability
    detection? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection
    Using Machine Learning and Deep Learning")中列出了会议和期刊的缩写及其完整名称。表格[4](#S4.T4 "Table
    4 ‣ 4.1.2\. RQ1.2: What is the distribution of the publication venues? ‣ 4.1\.
    RQ1\. What is the trend of studies using ML/DL models for vulnerability detection?
    ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection Using Machine
    Learning and Deep Learning")展示了每个出版场所的主要研究分布。64.1%的出版物发表在会议和研讨会上，而35.8%的论文发表在期刊上。可以观察到，MSR、IJCAI和ECSE/FSE是主要研究数量最多的热门场所，每个场所都有4篇论文。同时，在期刊中，TDSC和TSE包含的研究数量最多，分别为6篇和4篇。'
- en: <svg   height="151.41" overflow="visible" version="1.1" width="593.51"><g transform="translate(0,151.41)
    matrix(1 0 0 -1 0 0) translate(20.38,0) translate(0,110.32)"><g stroke="#000000"><g
    stroke-width="1.0pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 0 0)"><foreignobject width="552.76" height="99.63" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">(1) The results indicate that the application
    of ML/DL techniques for software vulnerability detection has had a remarkable
    rising trend in the past few years. (2) A large proportion of papers are published
    in recent two years, i.e., 2021 and 2022. (3) MSR, IJCAI, and ECSE/FSE are the
    most popular conference venues. On the other hand, TDSC and TSE are the most popular
    journal venues. <g stroke-width="0.5pt" fill="#FF9999"><path d="M 97.05 40.75
    L 5.19 40.75 C 2.13 40.75 -0.35 38.27 -0.35 35.21 L -0.35 24.91 C -0.35 21.86
    2.13 19.38 5.19 19.38 L 97.05 19.38 C 100.11 19.38 102.59 21.86 102.59 24.91 L
    102.59 35.21 C 102.59 38.27 100.11 40.75 97.05 40.75 Z M -0.35 19.38"></path></g><g
    stroke-width="0.5pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 4.27 26.68)"><foreignobject width="94.09" height="12.15" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">Answer to RQ1</foreignobject></g>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <svg height="151.41" overflow="visible" version="1.1" width="593.51"><g transform="translate(0,151.41)
    matrix(1 0 0 -1 0 0) translate(20.38,0) translate(0,110.32)"><g stroke="#000000"><g
    stroke-width="1.0pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 0 0)"><foreignobject width="552.76" height="99.63" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">(1) 结果表明，近年来应用**机器学习/深度学习**技术进行软件漏洞检测的趋势显著上升。
    (2) 大部分论文发表在最近两年，即2021年和2022年。 (3) MSR、IJCAI和ECSE/FSE是最受欢迎的会议场所。另一方面，TDSC和TSE是最受欢迎的期刊场所。
    <g stroke-width="0.5pt" fill="#FF9999"><path d="M 97.05 40.75 L 5.19 40.75 C 2.13
    40.75 -0.35 38.27 -0.35 35.21 L -0.35 24.91 C -0.35 21.86 2.13 19.38 5.19 19.38
    L 97.05 19.38 C 100.11 19.38 102.59 21.86 102.59 24.91 L 102.59 35.21 C 102.59
    38.27 100.11 40.75 97.05 40.75 Z M -0.35 19.38"></path></g><g stroke-width="0.5pt"
    fill="#000000" stroke="#000000" transform="matrix(1.0 0.0 0.0 1.0 4.27 26.68)"><foreignobject
    width="94.09" height="12.15" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">RQ1的答案</foreignobject></g>
- en: Table 4. Distribution of publications based on conference and journal venues.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Table 4. 会议和期刊的出版物分布。
- en: '| Conference Venue | # Studies | References | Journal Venue | # Studies | References
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 会议地点 | 研究数量 | 参考文献 | 期刊地点 | 研究数量 | 参考文献 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| MSR | 4 | (Chen et al., [2020b](#bib.bib25); Hoang et al., [2019](#bib.bib61);
    Hin et al., [2022](#bib.bib59); Fu and Tantithamthavorn, [2022](#bib.bib46)) |
    TDSC | 6 | (Liu et al., [2020](#bib.bib96); Zou et al., [2019](#bib.bib161); Lin
    et al., [2019](#bib.bib91); Li et al., [2021c](#bib.bib88), [b](#bib.bib87); Zou
    et al., [2022](#bib.bib160)) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| MSR | 4 | (Chen et al., [2020b](#bib.bib25); Hoang et al., [2019](#bib.bib61);
    Hin et al., [2022](#bib.bib59); Fu and Tantithamthavorn, [2022](#bib.bib46)) |
    TDSC | 6 | (Liu et al., [2020](#bib.bib96); Zou et al., [2019](#bib.bib161); Lin
    et al., [2019](#bib.bib91); Li et al., [2021c](#bib.bib88), [b](#bib.bib87); Zou
    et al., [2022](#bib.bib160)) |'
- en: '| IJCAI | 4 | (Choi et al., [2017](#bib.bib32); Zhuang et al., [2020](#bib.bib158);
    Duan et al., [2019](#bib.bib39); Liu et al., [2021b](#bib.bib98)) | TSE | 4 |
    (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33); Chen et al., [2021](#bib.bib26);
    Scandariato et al., [2014](#bib.bib125)) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| IJCAI | 4 | (Choi et al., [2017](#bib.bib32); Zhuang et al., [2020](#bib.bib158);
    Duan et al., [2019](#bib.bib39); Liu et al., [2021b](#bib.bib98)) | TSE | 4 |
    (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33); Chen et al., [2021](#bib.bib26);
    Scandariato et al., [2014](#bib.bib125)) |'
- en: '| ECSE/FSE | 4 | (Zhou and Sharma, [2017](#bib.bib156); Li et al., [2021a](#bib.bib85);
    Ni et al., [2022](#bib.bib111); Nguyen et al., [2022b](#bib.bib109)) | CSJ | 2
    | (Jeon and Kim, [2021](#bib.bib65); Yan et al., [2021](#bib.bib146)) |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| ECSE/FSE | 4 | (Zhou and Sharma, [2017](#bib.bib156); Li et al., [2021a](#bib.bib85);
    Ni et al., [2022](#bib.bib111); Nguyen et al., [2022b](#bib.bib109)) | CSJ | 2
    | (Jeon and Kim, [2021](#bib.bib65); Yan et al., [2021](#bib.bib146)) |'
- en: '| CCS | 3 | (Yamaguchi et al., [2013](#bib.bib145); Lin et al., [2017](#bib.bib92);
    Perl et al., [2015](#bib.bib115); Cheng et al., [2019](#bib.bib30)) | IST | 2
    | (Shippey et al., [2019](#bib.bib129); Tian et al., [2020](#bib.bib135)) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| CCS | 3 | (Yamaguchi et al., [2013](#bib.bib145); Lin et al., [2017](#bib.bib92);
    Perl et al., [2015](#bib.bib115); Cheng et al., [2019](#bib.bib30)) | IST | 2
    | (Shippey et al., [2019](#bib.bib129); Tian et al., [2020](#bib.bib135)) |'
- en: '| ISSRE | 3 | (Zheng et al., [2021](#bib.bib154); Wu et al., [2021](#bib.bib141);
    Zeng et al., [2021](#bib.bib151)) | TIFS | 2 | (Wang et al., [2020](#bib.bib137);
    Huang et al., [2021](#bib.bib62)) |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| ISSRE | 3 | (Zheng et al., [2021](#bib.bib154); Wu et al., [2021](#bib.bib141);
    Zeng et al., [2021](#bib.bib151)) | TIFS | 2 | (Wang et al., [2020](#bib.bib137);
    Huang et al., [2021](#bib.bib62)) |'
- en: '| ICLR | 2 | (Dinella et al., [2020](#bib.bib36); Le et al., [2018](#bib.bib77))
    | TOSEM | 2 | (Cheng et al., [2021](#bib.bib29); Zou et al., [2021](#bib.bib162))
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| ICLR | 2 | (Dinella et al., [2020](#bib.bib36); Le et al., [2018](#bib.bib77))
    | TOSEM | 2 | (Cheng et al., [2021](#bib.bib29); Zou et al., [2021](#bib.bib162))
    |'
- en: '| ICSE | 2 | (Cao et al., [2022](#bib.bib18); Wang et al., [2016](#bib.bib139))
    | ESM | 1 | (Riom et al., [2021](#bib.bib121)) |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| ICSE | 2 | (Cao et al., [2022](#bib.bib18); Wang et al., [2016](#bib.bib139))
    | ESM | 1 | (Riom et al., [2021](#bib.bib121)) |'
- en: '| OOPSLA | 2 | (Pradel and Sen, [2018](#bib.bib119); Li et al., [2019](#bib.bib86))
    | ISJ | 1 | (Ghaffarian and Shahriari, [2021](#bib.bib50)) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| OOPSLA | 2 | (Pradel and Sen, [2018](#bib.bib119); Li et al., [2019](#bib.bib86))
    | ISJ | 1 | (Ghaffarian and Shahriari, [2021](#bib.bib50)) |'
- en: '| NIPS | 2 | (Harer et al., [2018](#bib.bib56); Zhou et al., [2019](#bib.bib155))
    | JSS | 1 | (Pascarella et al., [2019](#bib.bib114)) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| NIPS | 2 | (Harer et al., [2018](#bib.bib56); Zhou et al., [2019](#bib.bib155))
    | JSS | 1 | (Pascarella et al., [2019](#bib.bib114)) |'
- en: '| ASE | 2 | (Le et al., [2021b](#bib.bib80); Zhang et al., [2022](#bib.bib153))
    | TFS | 1 | (Liu et al., [2019a](#bib.bib95)) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| ASE | 2 | (Le et al., [2021b](#bib.bib80); Zhang et al., [2022](#bib.bib153))
    | TFS | 1 | (Liu et al., [2019a](#bib.bib95)) |'
- en: '| QRS | 1 | (Li et al., [2017](#bib.bib83)) | TKDE | 1 | (Liu et al., [2021c](#bib.bib99))
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| QRS | 1 | (Li et al., [2017](#bib.bib83)) | TKDE | 1 | (Liu et al., [2021c](#bib.bib99))
    |'
- en: '| KDDM | 1 | (Nguyen et al., [2020](#bib.bib110)) | KBS | 1 | (Zhuang et al.,
    [2022](#bib.bib157)) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| KDDM | 1 | (Nguyen et al., [2020](#bib.bib110)) | KBS | 1 | (Zhuang et al.,
    [2022](#bib.bib157)) |'
- en: '| NDSS | 1 | (Li et al., [2018](#bib.bib89)) | SUM | 24 |  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| NDSS | 1 | (Li et al., [2018](#bib.bib89)) | SUM | 24 |  |'
- en: '| ARES | 1 | (Kronjee et al., [2018](#bib.bib73)) |  |  |  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| ARES | 1 | (Kronjee et al., [2018](#bib.bib73)) |  |  |  |'
- en: '| INFOCOM | 1 | (Ziems and Wu, [2021](#bib.bib159)) |  |  |  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| INFOCOM | 1 | (Ziems and Wu, [2021](#bib.bib159)) |  |  |  |'
- en: '| MASCOT | 1 | (Filus et al., [2020](#bib.bib43)) |  |  |  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| MASCOT | 1 | (Filus et al., [2020](#bib.bib43)) |  |  |  |'
- en: '| ICTAI | 1 | (Phan et al., [2017](#bib.bib117)) |  |  |  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| ICTAI | 1 | (Phan et al., [2017](#bib.bib117)) |  |  |  |'
- en: '| ICSME | 1 | (Sabetta and Bezzi, [2018](#bib.bib124)) |  |  |  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| ICSME | 1 | (Sabetta and Bezzi, [2018](#bib.bib124)) |  |  |  |'
- en: '| ICDM | 1 | (Huo et al., [2018](#bib.bib63)) |  |  |  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| ICDM | 1 | (Huo et al., [2018](#bib.bib63)) |  |  |  |'
- en: '| GLOBCOM | 1 | (Yang et al., [2017](#bib.bib148)) |  |  |  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| GLOBCOM | 1 | (Yang et al., [2017](#bib.bib148)) |  |  |  |'
- en: '| USENIX | 1 | (Yamaguchi et al., [2011](#bib.bib144)) |  |  |  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| USENIX | 1 | (Yamaguchi et al., [2011](#bib.bib144)) |  |  |  |'
- en: '| DSAA | 1 | (Nguyen et al., [2022b](#bib.bib109)) |  |  |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| DSAA | 1 | (阮等，[2022b](#bib.bib109)) |  |  |  |'
- en: '| ISSTA | 1 | (Cheng et al., [2022](#bib.bib31)) |  |  |  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| ISSTA | 1 | (程等，[2022](#bib.bib31)) |  |  |  |'
- en: '| SANER | 1 | (Ding et al., [2022](#bib.bib37)) |  |  |  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| SANER | 1 | (丁等，[2022](#bib.bib37)) |  |  |  |'
- en: '| TrustCom | 1 | (Yang et al., [2022](#bib.bib147)) |  |  |  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| TrustCom | 1 | (杨等，[2022](#bib.bib147)) |  |  |  |'
- en: '| SUM | 43 |  |  |  |  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 总计 | 43 |  |  |  |  |'
- en: 4.2\. RQ2\. What are the characteristics of software vulnerability detection
    datasets?
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. RQ2\. 软件漏洞检测数据集的特点是什么？
- en: Data is important for building and evaluating ML/DL-based software vulnerability
    detection models (Lin et al., [2019](#bib.bib91); Cheng et al., [2022](#bib.bib31);
    Lin et al., [2018](#bib.bib93); Du et al., [2020](#bib.bib38); Dam et al., [2017](#bib.bib33)).
    The quality of datasets can be assessed by different factors such as the source
    of data, data size and scale, data types, and preprocessing steps performed on
    data. For example, inappropriate preprocessing (representation) on data may result
    in poor performance of DL models (Ruospo et al., [2020](#bib.bib122)). In this
    section, we examine data used in vulnerability detection studies and conducted
    a comprehensive analysis of the steps of data source, data type, and data representation.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对构建和评估基于ML/DL的软件漏洞检测模型至关重要（Lin et al., [2019](#bib.bib91); Cheng et al., [2022](#bib.bib31);
    Lin et al., [2018](#bib.bib93); Du et al., [2020](#bib.bib38); Dam et al., [2017](#bib.bib33)）。数据集的质量可以通过不同的因素来评估，如数据来源、数据大小和规模、数据类型以及对数据进行的预处理步骤。例如，对数据的不当预处理（表示）可能导致DL模型性能不佳（Ruospo
    et al., [2020](#bib.bib122)）。在这一部分，我们审查了漏洞检测研究中使用的数据，并对数据来源、数据类型和数据表示的步骤进行了全面分析。
- en: 4.2.1\. RQ2.1\. What are the sources of datasets?
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. RQ2.1\. 数据集的来源是什么？
- en: One of the main challenges in ML/DL-based software vulnerability detection is
    the insufficient amount of data available for training operations (Chen et al.,
    [2020b](#bib.bib25); Lin et al., [2018](#bib.bib93)). Consequently, there exists
    a gap in research on how to obtain sufficient datasets to facilitate the training
    of ML/DL models for software security vulnerability detection. To this end, we
    analyze the sources of datasets in the studied 67 primary studies. Our analysis
    reveals that datasets for this purpose can be broadly classified into three categories,
    i.e., Benchmark, Collected, and Hybrid sources. Benchmark contains standardized
    datasets used to evaluate the performance of vulnerability detection methods and
    techniques (Sabetta and Bezzi, [2018](#bib.bib124); Dam et al., [2018](#bib.bib34),
    [2017](#bib.bib33); Wang et al., [2016](#bib.bib139); Jeon and Kim, [2021](#bib.bib65);
    Tian et al., [2020](#bib.bib135); Liu et al., [2020](#bib.bib96); Yamaguchi et al.,
    [2013](#bib.bib145); Liu et al., [2021c](#bib.bib99); Phan et al., [2017](#bib.bib117);
    Nguyen et al., [2020](#bib.bib110); Hoang et al., [2019](#bib.bib61); Kronjee
    et al., [2018](#bib.bib73); Zeng et al., [2021](#bib.bib151); Yan et al., [2021](#bib.bib146);
    Zou et al., [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Harer et al.,
    [2018](#bib.bib56)).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习/深度学习（ML/DL）基础的软件漏洞检测的主要挑战之一是用于训练操作的数据量不足（Chen et al., [2020b](#bib.bib25);
    Lin et al., [2018](#bib.bib93)）。因此，在如何获得足够的数据集以促进ML/DL模型用于软件安全漏洞检测的训练方面存在研究空白。为此，我们分析了所研究的67篇主要研究中的数据集来源。我们的分析揭示了用于此目的的数据集可以大致分为三类，即基准、收集和混合来源。基准包含用于评估漏洞检测方法和技术性能的标准化数据集（Sabetta
    和 Bezzi，[2018](#bib.bib124); Dam et al., [2018](#bib.bib34), [2017](#bib.bib33);
    Wang et al., [2016](#bib.bib139); Jeon 和 Kim，[2021](#bib.bib65); Tian et al.,
    [2020](#bib.bib135); Liu et al., [2020](#bib.bib96); Yamaguchi et al., [2013](#bib.bib145);
    Liu et al., [2021c](#bib.bib99); Phan et al., [2017](#bib.bib117); Nguyen et al.,
    [2020](#bib.bib110); Hoang et al., [2019](#bib.bib61); Kronjee et al., [2018](#bib.bib73);
    Zeng et al., [2021](#bib.bib151); Yan et al., [2021](#bib.bib146); Zou et al.,
    [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Harer et al., [2018](#bib.bib56))。
- en: Benchmark datasets for software vulnerability detection are often built from
    three main sources. The first source of data is collecting code snippets from
    open sources. This can include open-source software projects (Jimenez et al.,
    [2016](#bib.bib68)), public vulnerability databases (Black, [2017](#bib.bib12)),
    and bug repositories (Bugzilla’s, [2021](#bib.bib15)). The goal is to gather a
    diverse set of programs or code snippets that represent different application
    domains, programming languages, and vulnerability types. From the collected data,
    specific programs or code snippets are selected to be included in the benchmark
    dataset. The selection process considers factors such as program complexity, vulnerability
    diversity, and code quality. The aim is to create a dataset that covers a wide
    range of vulnerabilities and represents real-world scenarios. In some cases, benchmark
    datasets may include automatically generated synthetic programs (Booth et al.,
    [2013](#bib.bib13)). These programs are typically created using code generation
    techniques and follow certain patterns or templates. Synthetic generation allows
    for the creation of large-scale datasets and can help cover a broader range of
    vulnerabilities systematically. Alongside synthetic programs, benchmark datasets
    often include real-world software applications or code snippets written by hand.
    These manually created cases ensure that the dataset contains realistic vulnerabilities
    that reflect actual coding practices. Manual creation involves identifying vulnerable
    points in the code, introducing appropriate weaknesses, and maintaining a balance
    between code quality and realism.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 软件漏洞检测的基准数据集通常来自三个主要来源。第一个数据来源是从开放源代码中收集代码片段。这可以包括开源软件项目（Jimenez et al., [2016](#bib.bib68)）、公共漏洞数据库（Black,
    [2017](#bib.bib12)）和漏洞库（Bugzilla’s, [2021](#bib.bib15)）。目标是收集代表不同应用领域、编程语言和漏洞类型的多样化程序或代码片段。从收集的数据中，特定的程序或代码片段会被挑选进基准数据集中。选择过程考虑因素包括程序复杂性、漏洞多样性和代码质量。目标是创建一个覆盖广泛漏洞并代表现实场景的数据集。在某些情况下，基准数据集可能包括自动生成的合成程序（Booth
    et al., [2013](#bib.bib13)）。这些程序通常使用代码生成技术创建，并遵循特定的模式或模板。合成生成允许创建大规模数据集，并系统地覆盖更广泛的漏洞。除了合成程序，基准数据集通常还包括手工编写的真实软件应用程序或代码片段。这些手工创建的案例确保数据集中包含反映实际编码实践的现实漏洞。手工创建涉及识别代码中的易受攻击点，引入适当的弱点，并保持代码质量和现实之间的平衡。
- en: Collected datasets are gathered from publicly available projects hosted on repository
    websites such as Github or Stack Overflow (Chen et al., [2020b](#bib.bib25); Zhou
    and Sharma, [2017](#bib.bib156); Liu et al., [2019a](#bib.bib95); Pradel and Sen,
    [2018](#bib.bib119); Cheng et al., [2021](#bib.bib29); Zhou et al., [2019](#bib.bib155)).
    Also, some studies use the combination of different sources for vulnerability
    detection to increase the external validity of their findings (Chen et al., [2020b](#bib.bib25);
    Zhou and Sharma, [2017](#bib.bib156); Russell et al., [2018](#bib.bib123); Wang
    et al., [2020](#bib.bib137); Le et al., [2021b](#bib.bib80); Hin et al., [2022](#bib.bib59);
    Li et al., [2021a](#bib.bib85)), which refers to Hybrid source in this work.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 收集的数据集来自于在诸如 Github 或 Stack Overflow 等代码托管网站上公开可用的项目（Chen et al., [2020b](#bib.bib25);
    Zhou and Sharma, [2017](#bib.bib156); Liu et al., [2019a](#bib.bib95); Pradel
    and Sen, [2018](#bib.bib119); Cheng et al., [2021](#bib.bib29); Zhou et al., [2019](#bib.bib155)）。此外，一些研究使用不同来源的组合进行漏洞检测，以提高其发现结果的外部有效性（Chen
    et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156); Russell et
    al., [2018](#bib.bib123); Wang et al., [2020](#bib.bib137); Le et al., [2021b](#bib.bib80);
    Hin et al., [2022](#bib.bib59); Li et al., [2021a](#bib.bib85)），在本研究中称之为混合来源。
- en: The distribution of dataset sources in the primary studies is illustrated in
    figure [3](#S4.F3 "Figure 3 ‣ 4.2.1\. RQ2.1\. What are the sources of datasets?
    ‣ 4.2\. RQ2\. What are the characteristics of software vulnerability detection
    datasets? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection
    Using Machine Learning and Deep Learning"). As we can see, 65.7% of primary studies
    have utilized Benchmark datasets for software vulnerability detection. The rationale
    behind this trend is that benchmark datasets are readily accessible to all researchers
    and can facilitate the reproducibility of prior studies. Researchers often used
    Collected datasets in evaluating the proposed ML or DL-based security vulnerability
    detection models. According to our observation, 25.4% of studies build vulnerability
    detection models using collected datasets. There are a couple of reasons, first
    of all, open-source repositories like GitHub contain a vast amount of real-world
    code written by developers from diverse backgrounds. This data reflects the real-world
    coding practices, patterns, and vulnerabilities present in software projects.
    By analyzing such data, researchers can gain insights into the prevalent types
    of vulnerabilities and their occurrence frequencies in real-world software. Second,
    open-source repositories offer the opportunity to identify new vulnerabilities
    that may not be present in benchmark datasets. By analyzing diverse codebases,
    researchers can uncover previously unknown vulnerabilities or variations of known
    vulnerabilities, which helps in advancing the state-of-the-art in vulnerability
    detection and expanding the knowledge base of software security.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 主要研究中的数据集来源分布如图 [3](#S4.F3 "Figure 3 ‣ 4.2.1\. RQ2.1\. What are the sources
    of datasets? ‣ 4.2\. RQ2\. What are the characteristics of software vulnerability
    detection datasets? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning") 所示。可以看出，65.7% 的主要研究使用了用于软件漏洞检测的基准数据集。这一趋势的原因在于，基准数据集对所有研究人员都易于获取，并且可以促进先前研究的可重复性。研究人员通常使用收集的数据集来评估所提出的基于机器学习（ML）或深度学习（DL）的安全漏洞检测模型。根据我们的观察，25.4%
    的研究使用了收集的数据集来构建漏洞检测模型。原因有几个，首先，像 GitHub 这样的开源代码库包含了大量由来自不同背景的开发人员编写的真实世界代码。这些数据反映了实际的编码实践、模式以及软件项目中的漏洞。通过分析这些数据，研究人员可以获得对真实世界中常见漏洞类型及其发生频率的洞察。其次，开源代码库提供了识别基准数据集中可能不存在的新漏洞的机会。通过分析多样的代码库，研究人员可以发现先前未知的漏洞或已知漏洞的变种，这有助于推动漏洞检测的最前沿，并扩展软件安全的知识基础。
- en: <svg   height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <svg height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
- en: Figure 3. The source of the datasets used in primary study papers.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3. 主要研究论文中使用的数据集来源。
- en: The third major source of data is Hybrid accounting for 9% of primary studies
    which is the combination of different sources. Researchers often use hybrid sources
    for software vulnerability detection to address some of the limitations of individual
    data sources and to obtain more diverse and comprehensive datasets. For example,
    researchers may combine data from benchmark datasets with data from other sources
    such as Github, open-source projects, or data from commercial companies to create
    a hybrid dataset that is more representative of real-world scenarios. By doing
    so, they can improve the generalizability of their models and increase their chances
    of detecting a wider range of vulnerabilities.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第三大数据来源是混合型，占主要研究的 9%，即不同来源的组合。研究人员常常使用混合来源进行软件漏洞检测，以解决单一数据源的一些限制，并获得更多样化和全面的数据集。例如，研究人员可能会将基准数据集的数据与
    GitHub、开源项目或商业公司提供的数据结合起来，创建一个更能代表真实世界场景的混合数据集。这样做可以提高模型的泛化能力，并增加检测更广泛漏洞的机会。
- en: Table [5](#S4.T5 "Table 5 ‣ 4.2.1\. RQ2.1\. What are the sources of datasets?
    ‣ 4.2\. RQ2\. What are the characteristics of software vulnerability detection
    datasets? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection
    Using Machine Learning and Deep Learning") shows the detailed distribution of
    benchmark data used in the primary studies. As it is observable, NVD and SARD
    is the most widely used source of data in the Benchmark category. This is because
    SARD and NVD are publicly available benchmark sources to which researchers have
    unrestricted access. They give a lot of vulnerability data, allowing researchers
    to get a broad variety of vulnerabilities for their experiments and analyses.
    The availability of these materials promotes repeatability and collaboration among
    researchers in software vulnerability detection. Overall, there are 35 unique
    primary studies that use benchmark datasets from different sources.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 表 [5](#S4.T5 "表 5 ‣ 4.2.1\. RQ2.1\. 数据集的来源是什么？ ‣ 4.2\. RQ2\. 软件漏洞检测数据集的特征是什么？
    ‣ 4\. 结果 ‣ 一项关于使用机器学习和深度学习的自动化软件漏洞检测的调查") 显示了主要研究中使用的基准数据的详细分布。如图所示，NVD 和 SARD
    是基准类别中使用最广泛的数据源。这是因为 SARD 和 NVD 是公开可用的基准数据源，研究人员可以自由访问。它们提供了大量的漏洞数据，允许研究人员获取各种漏洞用于实验和分析。这些材料的可用性促进了软件漏洞检测领域的重复性和合作。总体而言，有
    35 项独特的主要研究使用了来自不同来源的基准数据集。
- en: Table [6](#S4.T6 "Table 6 ‣ 4.2.1\. RQ2.1\. What are the sources of datasets?
    ‣ 4.2\. RQ2\. What are the characteristics of software vulnerability detection
    datasets? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection
    Using Machine Learning and Deep Learning") shows the detailed distribution of
    the Collected source of data. As shown, Github is the most popular source of data
    for software vulnerability detection, accounting for 14 primary studies. Researchers
    can collect datasets from Github by crawling the platform and extracting relevant
    code repositories or by using Github’s API to access data programmatically. One
    advantage of using GitHub as a source of data is that it provides access to real-world
    code written by developers, which can be used to train and test vulnerability
    detection models. This data can be particularly useful for detecting new and emerging
    vulnerabilities that may not be covered by benchmark datasets. Jira, CVE, and
    Bugzilla come after with 2 primary studies for each. Overall, there are 17 unique
    primary studies that use collected sources of data for software vulnerability
    detection.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 表 [6](#S4.T6 "表 6 ‣ 4.2.1\. RQ2.1\. 数据集的来源是什么？ ‣ 4.2\. RQ2\. 软件漏洞检测数据集的特征是什么？
    ‣ 4\. 结果 ‣ 一项关于使用机器学习和深度学习的自动化软件漏洞检测的调查") 显示了收集的数据源的详细分布。如图所示，Github 是进行软件漏洞检测时最受欢迎的数据源，占据了
    14 项主要研究。研究人员可以通过爬取平台并提取相关代码库，或使用 Github 的 API 以编程方式访问数据来从 Github 收集数据。使用 GitHub
    作为数据源的一个优点是，它提供了由开发人员编写的真实代码，可用于训练和测试漏洞检测模型。这些数据对检测可能未被基准数据集覆盖的新兴漏洞特别有用。Jira、CVE
    和 Bugzilla 紧随其后，每个有 2 项主要研究。总体而言，有 17 项独特的主要研究使用了用于软件漏洞检测的收集数据源。
- en: Table 5. Detailed distribution of benchmark sources.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5. 基准数据源的详细分布。
- en: '| No | Source | # Studies | References |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 序号 | 来源 | 研究数量 | 参考文献 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | SARD | 17 | (Jeon and Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135);
    Liu et al., [2020](#bib.bib96); Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Zou et al., [2019](#bib.bib161); Cao et al., [2022](#bib.bib18);
    Ziems and Wu, [2021](#bib.bib159); Lin et al., [2019](#bib.bib91); Li et al.,
    [2021c](#bib.bib88); Filus et al., [2020](#bib.bib43); Li et al., [2021b](#bib.bib87);
    Zou et al., [2019](#bib.bib161); Li et al., [2021a](#bib.bib85); Duan et al.,
    [2019](#bib.bib39); Zheng et al., [2021](#bib.bib154); Yang et al., [2022](#bib.bib147))
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 1 | SARD | 17 | (Jeon 和 Kim, [2021](#bib.bib65); Tian 等, [2020](#bib.bib135);
    Liu 等, [2020](#bib.bib96); Wang 等, [2020](#bib.bib137); Cheng 等, [2021](#bib.bib29);
    Zou 等, [2019](#bib.bib161); Cao 等, [2022](#bib.bib18); Ziems 和 Wu, [2021](#bib.bib159);
    Lin 等, [2019](#bib.bib91); Li 等, [2021c](#bib.bib88); Filus 等, [2020](#bib.bib43);
    Li 等, [2021b](#bib.bib87); Zou 等, [2019](#bib.bib161); Li 等, [2021a](#bib.bib85);
    Duan 等, [2019](#bib.bib39); Zheng 等, [2021](#bib.bib154); Yang 等, [2022](#bib.bib147))
    |'
- en: '| 2 | NVD | 13 | (Jeon and Kim, [2021](#bib.bib65); Liu et al., [2020](#bib.bib96);
    Wang et al., [2020](#bib.bib137); Le et al., [2021b](#bib.bib80); Kronjee et al.,
    [2018](#bib.bib73); Hin et al., [2022](#bib.bib59); Zou et al., [2019](#bib.bib161);
    Cao et al., [2022](#bib.bib18); Li et al., [2021c](#bib.bib88); Filus et al.,
    [2020](#bib.bib43); Li et al., [2021b](#bib.bib87); Zou et al., [2019](#bib.bib161);
    Zheng et al., [2021](#bib.bib154)) |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 2 | NVD | 13 | (Jeon and Kim, [2021](#bib.bib65); Liu et al., [2020](#bib.bib96);
    Wang et al., [2020](#bib.bib137); Le et al., [2021b](#bib.bib80); Kronjee et al.,
    [2018](#bib.bib73); Hin et al., [2022](#bib.bib59); Zou et al., [2019](#bib.bib161);
    Cao et al., [2022](#bib.bib18); Li et al., [2021c](#bib.bib88); Filus et al.,
    [2020](#bib.bib43); Li et al., [2021b](#bib.bib87); Zou et al., [2019](#bib.bib161);
    Zheng et al., [2021](#bib.bib154)) |'
- en: '| 3 | ESC and VSC | 3 | (Liu et al., [2021c](#bib.bib99); Zhuang et al., [2020](#bib.bib158);
    Liu et al., [2021b](#bib.bib98)) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 3 | ESC 和 VSC | 3 | (Liu et al., [2021c](#bib.bib99); Zhuang et al., [2020](#bib.bib158);
    Liu et al., [2021b](#bib.bib98)) |'
- en: '| 4 | SmartBugs Wild | 3 | (Wu et al., [2021](#bib.bib141); Nguyen et al.,
    [2022b](#bib.bib109), [a](#bib.bib108)) |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 4 | SmartBugs Wild | 3 | (Wu et al., [2021](#bib.bib141); Nguyen et al.,
    [2022b](#bib.bib109), [a](#bib.bib108)) |'
- en: '| 5 | Juliet test suit | 3 | (Yan et al., [2021](#bib.bib146); Li et al., [2021a](#bib.bib85);
    Ding et al., [2022](#bib.bib37)) |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 5 | Juliet 测试套件 | 3 | (Yan et al., [2021](#bib.bib146); Li et al., [2021a](#bib.bib85);
    Ding et al., [2022](#bib.bib37)) |'
- en: '| 6 | SmartBugs | 2 | (Nguyen et al., [2022b](#bib.bib109), [a](#bib.bib108))
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 6 | SmartBugs | 2 | (Nguyen et al., [2022b](#bib.bib109), [a](#bib.bib108))
    |'
- en: '| 7 | PROMISE | 2 | (Wang et al., [2016](#bib.bib139); Zeng et al., [2021](#bib.bib151))
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 7 | PROMISE | 2 | (Wang et al., [2016](#bib.bib139); Zeng et al., [2021](#bib.bib151))
    |'
- en: '| 8 | D2A | 2 | (Cheng et al., [2022](#bib.bib31); Ding et al., [2022](#bib.bib37))
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 8 | D2A | 2 | (Cheng et al., [2022](#bib.bib31); Ding et al., [2022](#bib.bib37))
    |'
- en: '| 9 | NDSS | 2 | (Le et al., [2018](#bib.bib77); Nguyen et al., [2020](#bib.bib110))
    |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 9 | NDSS | 2 | (Le et al., [2018](#bib.bib77); Nguyen et al., [2020](#bib.bib110))
    |'
- en: '| 10 | NIST | 1 | (Harer et al., [2018](#bib.bib56)) |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 10 | NIST | 1 | (Harer et al., [2018](#bib.bib56)) |'
- en: '| 11 | OWASP | 1 | (Harer et al., [2018](#bib.bib56)) |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 11 | OWASP | 1 | (Harer et al., [2018](#bib.bib56)) |'
- en: '| 12 | SAMATE | 1 | (Kronjee et al., [2018](#bib.bib73)) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 12 | SAMATE | 1 | (Kronjee et al., [2018](#bib.bib73)) |'
- en: '| 13 | Mozilla Firefox projects | 1 | (Yang et al., [2017](#bib.bib148)) |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 13 | Mozilla Firefox 项目 | 1 | (Yang et al., [2017](#bib.bib148)) |'
- en: '| 14 | ICLR2019 | 1 | (Yang et al., [2017](#bib.bib148)) |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 14 | ICLR2019 | 1 | (Yang et al., [2017](#bib.bib148)) |'
- en: '| 15 | FQ | 1 | (Cheng et al., [2022](#bib.bib31)) |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 15 | FQ | 1 | (Cheng et al., [2022](#bib.bib31)) |'
- en: '| 16 | Bugs Wild Dataset | 1 | (Zhang et al., [2022](#bib.bib153)) |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 16 | Bugs Wild 数据集 | 1 | (Zhang et al., [2022](#bib.bib153)) |'
- en: '| 17 | Others | 1 | (Nguyen et al., [2020](#bib.bib110)) |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 其他 | 1 | (Nguyen et al., [2020](#bib.bib110)) |'
- en: '| - | SUM | 53 (35) | - |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| - | SUM | 53 (35) | - |'
- en: Table 6. Detailed distribution of Collected sources.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6. 收集来源的详细分布。
- en: '| No | Source | # Studies | References |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 来源 | 研究数量 | 参考文献 |'
- en: '| 1 | Github | 14 | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156);
    Liu et al., [2019a](#bib.bib95); Pradel and Sen, [2018](#bib.bib119); Cheng et al.,
    [2021](#bib.bib29); Zhou et al., [2019](#bib.bib155); Pascarella et al., [2019](#bib.bib114);
    Dinella et al., [2020](#bib.bib36); Li et al., [2019](#bib.bib86); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Chen et al., [2021](#bib.bib26); Perl et al., [2015](#bib.bib115);
    Riom et al., [2021](#bib.bib121); Ni et al., [2022](#bib.bib111)) |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Github | 14 | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156);
    Liu et al., [2019a](#bib.bib95); Pradel and Sen, [2018](#bib.bib119); Cheng et
    al., [2021](#bib.bib29); Zhou et al., [2019](#bib.bib155); Pascarella et al.,
    [2019](#bib.bib114); Dinella et al., [2020](#bib.bib36); Li et al., [2019](#bib.bib86);
    Fu and Tantithamthavorn, [2022](#bib.bib46); Chen et al., [2021](#bib.bib26);
    Perl et al., [2015](#bib.bib115); Riom et al., [2021](#bib.bib121); Ni et al.,
    [2022](#bib.bib111)) |'
- en: '| 2 | Jira | 2 | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156))
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Jira | 2 | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156))
    |'
- en: '| 3 | CVE | 2 | (Chen et al., [2020b](#bib.bib25); Zou et al., [2022](#bib.bib160))
    |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CVE | 2 | (Chen et al., [2020b](#bib.bib25); Zou et al., [2022](#bib.bib160))
    |'
- en: '| 4 | Bugzilla | 2 | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156))
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Bugzilla | 2 | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156))
    |'
- en: '| 6 | Others | 2 | (Huang et al., [2021](#bib.bib62); Hoang et al., [2019](#bib.bib61))
    |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 其他 | 2 | (Huang et al., [2021](#bib.bib62); Hoang et al., [2019](#bib.bib61))
    |'
- en: '| - | SUM | 22 (17) | - |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| - | SUM | 22 (17) | - |'
- en: 4.2.2\. RQ2.2\. What are the types of software vulnerability detection datasets
    used in prior studies?
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. RQ2.2\. 以前研究中使用的软件漏洞检测数据集有哪些类型？
- en: When it comes to detecting software vulnerabilities, datasets can have varying
    data types, e.g., existing software vulnerability detection models can find vulnerabilities
    in source code or commits. It is crucial to carefully examine the data types,
    as they require different preprocessing techniques and must be represented differently
    when using ML/DL models. Additionally, distinct data types necessitate different
    architectural approaches for ML/DL models. This section provides an overview of
    the various data types and their distributions. We classified the data types of
    employed datasets into three broad categories, i.e., code-based, repository-based,
    and hybrid.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测软件漏洞时，数据集可以具有不同的数据类型，例如，现有的软件漏洞检测模型可以在源代码或提交记录中发现漏洞。仔细检查数据类型至关重要，因为它们需要不同的预处理技术，并且在使用机器学习/深度学习模型时必须以不同的方式表示。此外，不同的数据类型需要不同的机器学习/深度学习模型架构。
    本节概述了各种数据类型及其分布。我们将所用数据集的数据类型分为三大类，即基于代码的、基于仓库的和混合型。
- en: Figure [4](#S4.F4 "Figure 4 ‣ 4.2.2\. RQ2.2\. What are the types of software
    vulnerability detection datasets used in prior studies? ‣ 4.2\. RQ2\. What are
    the characteristics of software vulnerability detection datasets? ‣ 4\. Results
    ‣ A Survey on Automated Software Vulnerability Detection Using Machine Learning
    and Deep Learning") shows the distribution of the data types in primary studies.
    We can observe that the majority of primary studies (70.1%) primarily focus on
    analyzing the source code for software vulnerability detection. This indicates
    the significance of code-level analysis in identifying vulnerabilities. The utilization
    of repository-level data, such as commit history and change logs, is also prominent,
    representing a substantial portion (25.4%) of primary studies. This suggests that
    repository-level information is considered valuable in vulnerability detection.
    Additionally, a smaller portion (4.5%) of the studies adopt a hybrid approach,
    combining both code-level analysis and repository-level information. These techniques
    leverage the strengths of both data sources to improve the accuracy and effectiveness
    of vulnerability detection.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [4](#S4.F4 "图 4 ‣ 4.2.2\. RQ2.2\. 以前研究中使用的软件漏洞检测数据集类型是什么？ ‣ 4.2\. RQ2\. 软件漏洞检测数据集的特征是什么？
    ‣ 4\. 结果 ‣ 关于使用机器学习和深度学习的自动化软件漏洞检测的调查") 显示了初级研究中数据类型的分布。我们可以观察到，大多数初级研究（70.1%）主要集中在分析源代码以检测软件漏洞。这表明代码级分析在识别漏洞方面的重要性。仓库级数据（如提交历史和变更日志）的利用也很突出，占初级研究的相当一部分（25.4%）。这表明仓库级信息在漏洞检测中被认为是有价值的。此外，较小的一部分（4.5%）的研究采用了混合方法，结合了代码级分析和仓库级信息。这些技术利用了两种数据源的优点，以提高漏洞检测的准确性和有效性。
- en: <svg   height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <svg   height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
- en: Figure 4. The type of datasets in primary studies.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4. 初级研究中的数据集类型。
- en: Table 7. Data types of datasets involved in primary studies.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7. 初级研究中涉及的数据集的数据类型。
- en: '| Category | Data Type | #Studies | Total | References |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 数据类型 | 研究数量 | 总计 | 参考文献 |'
- en: '| Code-based | Source code | 42 | 47 | (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33);
    Shippey et al., [2019](#bib.bib129); Wang et al., [2016](#bib.bib139); Jeon and
    Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135); Liu et al., [2020](#bib.bib96);
    Yamaguchi et al., [2013](#bib.bib145); Liu et al., [2021c](#bib.bib99); Kronjee
    et al., [2018](#bib.bib73); Choi et al., [2017](#bib.bib32); Zeng et al., [2021](#bib.bib151);
    Zou et al., [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Harer et al.,
    [2018](#bib.bib56); Zou et al., [2019](#bib.bib161); Cao et al., [2022](#bib.bib18);
    Ghaffarian and Shahriari, [2021](#bib.bib50); Wu et al., [2021](#bib.bib141);
    Lin et al., [2017](#bib.bib92); Scandariato et al., [2014](#bib.bib125); Ziems
    and Wu, [2021](#bib.bib159); Zhuang et al., [2020](#bib.bib158); Li et al., [2017](#bib.bib83);
    Lin et al., [2019](#bib.bib91); Li et al., [2021c](#bib.bib88); Filus et al.,
    [2020](#bib.bib43); Li et al., [2021b](#bib.bib87), [2018](#bib.bib89), [a](#bib.bib85);
    Yamaguchi et al., [2011](#bib.bib144); Duan et al., [2019](#bib.bib39); Zheng
    et al., [2021](#bib.bib154); Zhuang et al., [2022](#bib.bib157); Cheng et al.,
    [2022](#bib.bib31); Liu et al., [2021b](#bib.bib98); Ding et al., [2022](#bib.bib37);
    Zhang et al., [2022](#bib.bib153); Yang et al., [2022](#bib.bib147); Zou et al.,
    [2022](#bib.bib160); Nguyen et al., [2022b](#bib.bib109), [a](#bib.bib108)) |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 基于代码的 | 源代码 | 42 | 47 | (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33);
    Shippey et al., [2019](#bib.bib129); Wang et al., [2016](#bib.bib139); Jeon and
    Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135); Liu et al., [2020](#bib.bib96);
    Yamaguchi et al., [2013](#bib.bib145); Liu et al., [2021c](#bib.bib99); Kronjee
    et al., [2018](#bib.bib73); Choi et al., [2017](#bib.bib32); Zeng et al., [2021](#bib.bib151);
    Zou et al., [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Harer et al.,
    [2018](#bib.bib56); Zou et al., [2019](#bib.bib161); Cao et al., [2022](#bib.bib18);
    Ghaffarian and Shahriari, [2021](#bib.bib50); Wu et al., [2021](#bib.bib141);
    Lin et al., [2017](#bib.bib92); Scandariato et al., [2014](#bib.bib125); Ziems
    and Wu, [2021](#bib.bib159); Zhuang et al., [2020](#bib.bib158); Li et al., [2017](#bib.bib83);
    Lin et al., [2019](#bib.bib91); Li et al., [2021c](#bib.bib88); Filus et al.,
    [2020](#bib.bib43); Li et al., [2021b](#bib.bib87), [2018](#bib.bib89), [a](#bib.bib85);
    Yamaguchi et al., [2011](#bib.bib144); Duan et al., [2019](#bib.bib39); Zheng
    et al., [2021](#bib.bib154); Zhuang et al., [2022](#bib.bib157); Cheng et al.,
    [2022](#bib.bib31); Liu et al., [2021b](#bib.bib98); Ding et al., [2022](#bib.bib37);
    Zhang et al., [2022](#bib.bib153); Yang et al., [2022](#bib.bib147); Zou et al.,
    [2022](#bib.bib160); Nguyen et al., [2022b](#bib.bib109), [a](#bib.bib108)) |'
- en: '|  | Binary code | 5 |  | (Phan et al., [2017](#bib.bib117); Nguyen et al.,
    [2020](#bib.bib110); Yan et al., [2021](#bib.bib146); Huang et al., [2021](#bib.bib62);
    Le et al., [2018](#bib.bib77)) |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|  | 二进制代码 | 5 |  | (Phan et al., [2017](#bib.bib117); Nguyen et al., [2020](#bib.bib110);
    Yan et al., [2021](#bib.bib146); Huang et al., [2021](#bib.bib62); Le et al.,
    [2018](#bib.bib77)) |'
- en: '| Repository-based | Code change | 8 | 13 | (Liu et al., [2019a](#bib.bib95);
    Pradel and Sen, [2018](#bib.bib119); Zhou et al., [2019](#bib.bib155); Dinella
    et al., [2020](#bib.bib36); Li et al., [2019](#bib.bib86); Hin et al., [2022](#bib.bib59);
    Fu and Tantithamthavorn, [2022](#bib.bib46); Chen et al., [2021](#bib.bib26))
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 基于仓库的 | 代码变更 | 8 | 13 | (Liu et al., [2019a](#bib.bib95); Pradel and Sen,
    [2018](#bib.bib119); Zhou et al., [2019](#bib.bib155); Dinella et al., [2020](#bib.bib36);
    Li et al., [2019](#bib.bib86); Hin et al., [2022](#bib.bib59); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Chen et al., [2021](#bib.bib26)) |'
- en: '|  | Commit | 5 |  | (Pascarella et al., [2019](#bib.bib114); Perl et al.,
    [2015](#bib.bib115); Riom et al., [2021](#bib.bib121); Yang et al., [2017](#bib.bib148);
    Ni et al., [2022](#bib.bib111)) |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  | 提交记录 | 5 |  | (Pascarella et al., [2019](#bib.bib114); Perl et al., [2015](#bib.bib115);
    Riom et al., [2021](#bib.bib121); Yang et al., [2017](#bib.bib148); Ni et al.,
    [2022](#bib.bib111)) |'
- en: '| Hybrid | Source Code+Code change | 3 | 7 | (Wang et al., [2020](#bib.bib137);
    Le et al., [2021b](#bib.bib80); Cheng et al., [2021](#bib.bib29)) |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 混合 | 源代码+代码变更 | 3 | 7 | (Wang et al., [2020](#bib.bib137); Le et al., [2021b](#bib.bib80);
    Cheng et al., [2021](#bib.bib29)) |'
- en: '|  | Commits+Code Change | 2 |  | (Sabetta and Bezzi, [2018](#bib.bib124);
    Hoang et al., [2019](#bib.bib61)) |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|  | 提交记录+代码变更 | 2 |  | (Sabetta and Bezzi, [2018](#bib.bib124); Hoang et al.,
    [2019](#bib.bib61)) |'
- en: '|  | Commits+Bug reports | 1 |  | (Zhou and Sharma, [2017](#bib.bib156)) |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|  | 提交记录+错误报告 | 1 |  | (Zhou and Sharma, [2017](#bib.bib156)) |'
- en: '|  | Bug report+Commits+Emails | 1 |  | (Chen et al., [2020b](#bib.bib25))
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|  | 错误报告+提交记录+电子邮件 | 1 |  | (Chen et al., [2020b](#bib.bib25)) |'
- en: '| SUM | - | - | 67(67) | - |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 总计 | - | - | 67(67) | - |'
- en: Table [7](#S4.T7 "Table 7 ‣ 4.2.2\. RQ2.2\. What are the types of software vulnerability
    detection datasets used in prior studies? ‣ 4.2\. RQ2\. What are the characteristics
    of software vulnerability detection datasets? ‣ 4\. Results ‣ A Survey on Automated
    Software Vulnerability Detection Using Machine Learning and Deep Learning") elaborates
    the detailed data types categories used in primary studies. The table shows that
    42 primary studies used code-based category and the major data type of this category
    is Source code (Zheng et al., [2021](#bib.bib154); Duan et al., [2019](#bib.bib39);
    Yamaguchi et al., [2011](#bib.bib144); Li et al., [2021a](#bib.bib85); Zou et al.,
    [2019](#bib.bib161); Li et al., [2021b](#bib.bib87); Filus et al., [2020](#bib.bib43);
    Li et al., [2021c](#bib.bib88); Lin et al., [2019](#bib.bib91); Li et al., [2017](#bib.bib83);
    Zhuang et al., [2020](#bib.bib158); Ziems and Wu, [2021](#bib.bib159)). Binary
    code is the second major data type in code-based category (Phan et al., [2017](#bib.bib117);
    Huang et al., [2021](#bib.bib62); Yan et al., [2021](#bib.bib146); Nguyen et al.,
    [2020](#bib.bib110)) accounting for 5 primary studies. Regarding the Repository
    based category, 13 primary studies focused on extracting useful information and
    patterns by crawling different artifacts from software repositories from open
    source. The major artifact is Code change accounting for 8 primary studies (Chen
    et al., [2021](#bib.bib26); Fu and Tantithamthavorn, [2022](#bib.bib46); Hin et al.,
    [2022](#bib.bib59); Li et al., [2019](#bib.bib86); Dinella et al., [2020](#bib.bib36);
    Zhou et al., [2019](#bib.bib155); Pradel and Sen, [2018](#bib.bib119); Liu et al.,
    [2019a](#bib.bib95)), and Commit comes as the second with 5 primary studies. The
    last category of data types is Hybrid where the studies used a combination of
    different data types for software security vulnerability detection, accounting
    for 7 primary studies. As can be seen, Source code+Code change is the most dominant
    data type combination (Wang et al., [2020](#bib.bib137); Le et al., [2021b](#bib.bib80);
    Cheng et al., [2021](#bib.bib29)).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 表格[7](#S4.T7 "表格 7 ‣ 4.2.2\. RQ2.2\. 之前的研究中使用了哪些类型的软件漏洞检测数据集？ ‣ 4.2\. RQ2\.
    软件漏洞检测数据集的特征是什么？ ‣ 4\. 结果 ‣ 使用机器学习和深度学习的自动化软件漏洞检测调查") 详细说明了主要研究中使用的数据类型类别。该表显示，42项主要研究使用了基于代码的类别，其中该类别的主要数据类型是源代码（Zheng
    et al., [2021](#bib.bib154); Duan et al., [2019](#bib.bib39); Yamaguchi et al.,
    [2011](#bib.bib144); Li et al., [2021a](#bib.bib85); Zou et al., [2019](#bib.bib161);
    Li et al., [2021b](#bib.bib87); Filus et al., [2020](#bib.bib43); Li et al., [2021c](#bib.bib88);
    Lin et al., [2019](#bib.bib91); Li et al., [2017](#bib.bib83); Zhuang et al.,
    [2020](#bib.bib158); Ziems and Wu, [2021](#bib.bib159))。二进制代码是基于代码类别中的第二大数据类型（Phan
    et al., [2017](#bib.bib117); Huang et al., [2021](#bib.bib62); Yan et al., [2021](#bib.bib146);
    Nguyen et al., [2020](#bib.bib110)），占5项主要研究。关于基于存储库的类别，13项主要研究集中在通过爬取来自开源软件存储库的不同文档来提取有用信息和模式。主要文档是代码变更，占8项主要研究（Chen
    et al., [2021](#bib.bib26); Fu and Tantithamthavorn, [2022](#bib.bib46); Hin et
    al., [2022](#bib.bib59); Li et al., [2019](#bib.bib86); Dinella et al., [2020](#bib.bib36);
    Zhou et al., [2019](#bib.bib155); Pradel and Sen, [2018](#bib.bib119); Liu et
    al., [2019a](#bib.bib95)），提交是第二大数据类型，占5项主要研究。最后一个数据类型类别是混合，其中研究使用了不同数据类型的组合来进行软件安全漏洞检测，占7项主要研究。可以看出，源代码+代码变更是最主要的数据类型组合（Wang
    et al., [2020](#bib.bib137); Le et al., [2021b](#bib.bib80); Cheng et al., [2021](#bib.bib29)）。
- en: 4.2.3\. RQ2.3\. How input data are represented?
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. RQ2.3\. 输入数据是如何表示的？
- en: 'As noted in earlier sections, research studies focused on software vulnerability
    detection rely on diverse sources of data and data types. This heterogeneity necessitates
    the use of varied representation techniques, which in turn requires different
    architectural approaches and design assumptions for ML/DL models. We classified
    the input representation of employed datasets into five broad categories, i.e.,
    Graph-based, Tree-based, Token-based, Metric-based and Hybrid. Figure [5](#S4.F5
    "Figure 5 ‣ 4.2.3\. RQ2.3\. How input data are represented? ‣ 4.2\. RQ2\. What
    are the characteristics of software vulnerability detection datasets? ‣ 4\. Results
    ‣ A Survey on Automated Software Vulnerability Detection Using Machine Learning
    and Deep Learning") shows the distribution of different input representations
    used in primary studies. From the pie chart, we can observe that the most popular
    input representation is the use of Graph/Tree-based representation, accounting
    for the largest slice (i.e., 38.8% for Graph-based and 16.4% for Tree-based).
    Token-based representation follows closely, representing a substantial portion
    (29.9%) of primary studies. Hybrid representation combines multiple representations
    or approaches, which makes up a smaller portion (10.4%). Finally, the use of Commit
    Metrics in vulnerability detection has the smallest portion (4.5%). In the following
    paragraphs, we elaborate on each category in detail. Graph/Tree-based representation (Jeon
    and Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135); Liu et al., [2021c](#bib.bib99);
    Phan et al., [2017](#bib.bib117); Cheng et al., [2021](#bib.bib29); Zhou et al.,
    [2019](#bib.bib155); Kronjee et al., [2018](#bib.bib73); Zeng et al., [2021](#bib.bib151);
    Huang et al., [2021](#bib.bib62); Li et al., [2019](#bib.bib86); Zou et al., [2019](#bib.bib161);
    Cao et al., [2022](#bib.bib18); Ghaffarian and Shahriari, [2021](#bib.bib50);
    Wu et al., [2021](#bib.bib141); Zhuang et al., [2020](#bib.bib158); Li et al.,
    [2021c](#bib.bib88); Zou et al., [2019](#bib.bib161); Duan et al., [2019](#bib.bib39);
    Zheng et al., [2021](#bib.bib154); Cheng et al., [2022](#bib.bib31); Liu et al.,
    [2021b](#bib.bib98); Ding et al., [2022](#bib.bib37); Yang et al., [2022](#bib.bib147);
    Zou et al., [2022](#bib.bib160); Nguyen et al., [2022b](#bib.bib109), [a](#bib.bib108)):
    allows for the detection of complex patterns and relationships between different
    code elements. By representing source code as a graph or tree, it becomes possible
    to capture not only the syntax and structure of the code but also its semantics,
    control flow, and data flow. There are many graph/tree-based representation techniques
    like Abstract Syntax Trees (AST) (Mao et al., [2020](#bib.bib103); Yamaguchi et al.,
    [2012](#bib.bib143); Dinella et al., [2020](#bib.bib36); Lin et al., [2017](#bib.bib92),
    [2019](#bib.bib91); Li et al., [2021b](#bib.bib87)) and Code Property Graph (CPG)
    (Zhou et al., [2019](#bib.bib155); Ghaffarian and Shahriari, [2021](#bib.bib50);
    Duan et al., [2019](#bib.bib39)) used to transform source code into AST and CPG
    representations.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如早期部分所述，专注于软件漏洞检测的研究依赖于多种数据源和数据类型。这种异质性需要使用不同的表示技术，这反过来又要求对 ML/DL 模型采用不同的架构方法和设计假设。我们将使用的数据集的输入表示分为五个大类，即基于图的、基于树的、基于标记的、基于度量的和混合的。图
    [5](#S4.F5 "Figure 5 ‣ 4.2.3\. RQ2.3\. How input data are represented? ‣ 4.2\.
    RQ2\. What are the characteristics of software vulnerability detection datasets?
    ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection Using Machine
    Learning and Deep Learning") 显示了主要研究中使用的不同输入表示的分布。从饼图中，我们可以观察到，最受欢迎的输入表示是使用基于图/树的表示，占据了最大份额（即基于图的
    38.8% 和基于树的 16.4%）。紧随其后的是基于标记的表示，占据了主要研究中的相当一部分（29.9%）。混合表示结合了多种表示或方法，占据了较小的份额（10.4%）。最后，漏洞检测中使用的提交度量所占份额最小（4.5%）。在接下来的段落中，我们将详细阐述每一类。基于图/树的表示（Jeon
    和 Kim，[2021](#bib.bib65)；Tian 等，[2020](#bib.bib135)；Liu 等，[2021c](#bib.bib99)；Phan
    等，[2017](#bib.bib117)；Cheng 等，[2021](#bib.bib29)；Zhou 等，[2019](#bib.bib155)；Kronjee
    等，[2018](#bib.bib73)；Zeng 等，[2021](#bib.bib151)；Huang 等，[2021](#bib.bib62)；Li
    等，[2019](#bib.bib86)；Zou 等，[2019](#bib.bib161)；Cao 等，[2022](#bib.bib18)；Ghaffarian
    和 Shahriari，[2021](#bib.bib50)；Wu 等，[2021](#bib.bib141)；Zhuang 等，[2020](#bib.bib158)；Li
    等，[2021c](#bib.bib88)；Zou 等，[2019](#bib.bib161)；Duan 等，[2019](#bib.bib39)；Zheng
    等，[2021](#bib.bib154)；Cheng 等，[2022](#bib.bib31)；Liu 等，[2021b](#bib.bib98)；Ding
    等，[2022](#bib.bib37)；Yang 等，[2022](#bib.bib147)；Zou 等，[2022](#bib.bib160)；Nguyen
    等，[2022b](#bib.bib109)，[a](#bib.bib108))：可以检测不同代码元素之间的复杂模式和关系。通过将源代码表示为图或树，可以捕捉到代码的语法、结构、语义、控制流和数据流。有许多基于图/树的表示技术，如抽象语法树（AST）（Mao
    等，[2020](#bib.bib103)；Yamaguchi 等，[2012](#bib.bib143)；Dinella 等，[2020](#bib.bib36)；Lin
    等，[2017](#bib.bib92)，[2019](#bib.bib91)；Li 等，[2021b](#bib.bib87)）和代码属性图（CPG）（Zhou
    等，[2019](#bib.bib155)；Ghaffarian 和 Shahriari，[2021](#bib.bib50)；Duan 等，[2019](#bib.bib39)），用于将源代码转换为
    AST 和 CPG 表示。
- en: t! <svg   height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: t! <svg height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
- en: Figure 5. Different representation used by primary studies.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图5. 初级研究中使用的不同表示方法。
- en: 'Token-based representation (Aivatoglou et al., [2021](#bib.bib4); Zhou and
    Sharma, [2017](#bib.bib156); Russell et al., [2018](#bib.bib123); Dam et al.,
    [2018](#bib.bib34); Yamaguchi et al., [2013](#bib.bib145); Du et al., [2020](#bib.bib38);
    Nguyen et al., [2020](#bib.bib110); Liu et al., [2019a](#bib.bib95); Pradel and
    Sen, [2018](#bib.bib119); Le et al., [2021b](#bib.bib80); Hoang et al., [2019](#bib.bib61)):
    treat the source code as string token sequences and then transforms source code
    into tokens vectors. The input data is first split into a sequence of tokens,
    which are then converted into numerical vectors that can be processed by machine
    learning algorithms. Tokenization involves breaking down a string of text or source
    code into smaller units, or tokens, which can then be used as the basis for further
    analysis. In the case of source code, tokens might include keywords, operators,
    variables, and other elements of the programming language syntax.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 基于标记的表示（Aivatoglou 等，[2021](#bib.bib4); Zhou 和 Sharma，[2017](#bib.bib156); Russell
    等，[2018](#bib.bib123); Dam 等，[2018](#bib.bib34); Yamaguchi 等，[2013](#bib.bib145);
    Du 等，[2020](#bib.bib38); Nguyen 等，[2020](#bib.bib110); Liu 等，[2019a](#bib.bib95);
    Pradel 和 Sen，[2018](#bib.bib119); Le 等，[2021b](#bib.bib80); Hoang 等，[2019](#bib.bib61))：将源代码视为字符串标记序列，然后将源代码转换为标记向量。输入数据首先被拆分为标记序列，然后转换为可以由机器学习算法处理的数值向量。标记化涉及将一串文本或源代码拆分成较小的单位或标记，这些标记可以作为进一步分析的基础。在源代码的情况下，标记可能包括关键字、操作符、变量以及编程语言语法中的其他元素。
- en: 'Commit Metrics (Ni et al., [2022](#bib.bib111); Yang et al., [2017](#bib.bib148);
    Pascarella et al., [2019](#bib.bib114)): leverages the metrics extracted from
    commits to represent code commits. Features derived from commits, such as the
    size of code changes, the number of modified lines, the complexity of the changes,
    or the programming language used, can be used as inputs to train ML/DL models.
    These models can then learn patterns and relationships between commit characteristics
    and the presence of vulnerabilities, enabling automated detection based on new
    commits.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 提交度量（Ni 等，[2022](#bib.bib111); Yang 等，[2017](#bib.bib148); Pascarella 等，[2019](#bib.bib114)）：利用从提交中提取的度量来表示代码提交。从提交中得出的特征，如代码更改的大小、修改的行数、更改的复杂性或使用的编程语言，可以作为输入来训练
    ML/DL 模型。这些模型可以学习提交特征与漏洞存在之间的模式和关系，从而基于新的提交实现自动检测。
- en: 'Hybrid representation (Russell et al., [2018](#bib.bib123); Wang et al., [2020](#bib.bib137);
    Le et al., [2021b](#bib.bib80); Cheng et al., [2021](#bib.bib29); Sabetta and
    Bezzi, [2018](#bib.bib124); Hoang et al., [2019](#bib.bib61); Zhou and Sharma,
    [2017](#bib.bib156); Chen et al., [2020b](#bib.bib25)): uses a combination of
    different representations for software security vulnerability detection. Combining
    different representations of input data can lead to a more comprehensive and richer
    input representation of source code, which can improve the performance of vulnerability
    detection models in tasks such as prediction or detection. Combining different
    representations such as token-based representations and graph-based representations
    can help capture both the syntax and semantics of the code, as well as the relationships
    between different components of the code.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 混合表示（Russell 等，[2018](#bib.bib123); Wang 等，[2020](#bib.bib137); Le 等，[2021b](#bib.bib80);
    Cheng 等，[2021](#bib.bib29); Sabetta 和 Bezzi，[2018](#bib.bib124); Hoang 等，[2019](#bib.bib61);
    Zhou 和 Sharma，[2017](#bib.bib156); Chen 等，[2020b](#bib.bib25)）：使用多种表示方法的组合进行软件安全漏洞检测。结合不同的输入数据表示可以导致更全面和丰富的源代码输入表示，从而提高漏洞检测模型在预测或检测任务中的性能。结合标记基础表示和基于图的表示等不同表示方法可以帮助捕捉代码的语法和语义，以及代码中不同组件之间的关系。
- en: Table [8](#S4.T8 "Table 8 ‣ 4.2.3\. RQ2.3\. How input data are represented?
    ‣ 4.2\. RQ2\. What are the characteristics of software vulnerability detection
    datasets? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection
    Using Machine Learning and Deep Learning") shows the representation techniques
    distributed by different artifacts used by ML/DL models. It is observable that
    Graph/Tree-based representation is the most dominant technique used by primary
    studies, accounting for 32 unique primary studies in total. These studies represent
    the input to ML/DL models via Source code as a graph, Source code as a tree, and
    Binary code as a graph. Source code as a graph is the major representation technique
    used by primary studies (Jeon and Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135);
    Liu et al., [2021c](#bib.bib99); Phan et al., [2017](#bib.bib117); Cheng et al.,
    [2021](#bib.bib29); Zhou et al., [2019](#bib.bib155); Kronjee et al., [2018](#bib.bib73);
    Zeng et al., [2021](#bib.bib151); Huang et al., [2021](#bib.bib62); Li et al.,
    [2019](#bib.bib86); Zou et al., [2019](#bib.bib161); Cao et al., [2022](#bib.bib18);
    Ghaffarian and Shahriari, [2021](#bib.bib50); Wu et al., [2021](#bib.bib141);
    Zhuang et al., [2020](#bib.bib158); Li et al., [2021c](#bib.bib88); Zou et al.,
    [2019](#bib.bib161); Duan et al., [2019](#bib.bib39); Zheng et al., [2021](#bib.bib154);
    Cheng et al., [2022](#bib.bib31); Liu et al., [2021b](#bib.bib98); Ding et al.,
    [2022](#bib.bib37); Yang et al., [2022](#bib.bib147); Zou et al., [2022](#bib.bib160);
    Nguyen et al., [2022b](#bib.bib109), [a](#bib.bib108)) accounting for 22 studies.
    Source code as a tree (Dam et al., [2017](#bib.bib33); Shippey et al., [2019](#bib.bib129);
    Wang et al., [2016](#bib.bib139); Liu et al., [2020](#bib.bib96); Wang et al.,
    [2020](#bib.bib137); Dinella et al., [2020](#bib.bib36); Lin et al., [2017](#bib.bib92);
    Li et al., [2017](#bib.bib83); Lin et al., [2019](#bib.bib91); Li et al., [2021b](#bib.bib87);
    Zhuang et al., [2022](#bib.bib157)) is the second major representation technique
    accounting for 9 primary studies. Some researchers used Binary code as a graph (Phan
    et al., [2017](#bib.bib117); Huang et al., [2021](#bib.bib62)) to build binary-level
    vulnerability detection models, accounting for 2 primary studies. There are 14
    primary studies that used Token-based representation, in which 10 primary studies
    represented source code as a token sequence, three primary studies modeled binary
    code as a token, and one study represented text as token sequences (Zhou and Sharma,
    [2017](#bib.bib156)). Hybrid representation has 5 different types accounting for
    8 primary studies. Token Sequence+Commit Metrics is the major artifact used to
    enhance the input representation in software vulnerability detection, accounting
    for 4 primary studies. It combines information from the token sequence of the
    code and additional metrics derived from software commits. This approach leverages
    both the structural and historical aspects of the code to provide a more comprehensive
    representation for building vulnerability detection models.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 表[8](#S4.T8 "Table 8 ‣ 4.2.3\. RQ2.3\. How input data are represented? ‣ 4.2\.
    RQ2\. What are the characteristics of software vulnerability detection datasets?
    ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection Using Machine
    Learning and Deep Learning")展示了ML/DL模型所使用的不同工件分布的表示技术。可以观察到，基于图/树的表示是主要研究中最占主导地位的技术，总计32项独特的主要研究。这些研究通过将源代码作为图、源代码作为树以及二进制代码作为图来表示输入到ML/DL模型中的内容。源代码作为图是主要研究中使用的主要表示技术（Jeon和Kim，[2021](#bib.bib65)；Tian等，[2020](#bib.bib135)；Liu等，[2021c](#bib.bib99)；Phan等，[2017](#bib.bib117)；Cheng等，[2021](#bib.bib29)；Zhou等，[2019](#bib.bib155)；Kronjee等，[2018](#bib.bib73)；Zeng等，[2021](#bib.bib151)；Huang等，[2021](#bib.bib62)；Li等，[2019](#bib.bib86)；Zou等，[2019](#bib.bib161)；Cao等，[2022](#bib.bib18)；Ghaffarian和Shahriari，[2021](#bib.bib50)；Wu等，[2021](#bib.bib141)；Zhuang等，[2020](#bib.bib158)；Li等，[2021c](#bib.bib88)；Zou等，[2019](#bib.bib161)；Duan等，[2019](#bib.bib39)；Zheng等，[2021](#bib.bib154)；Cheng等，[2022](#bib.bib31)；Liu等，[2021b](#bib.bib98)；Ding等，[2022](#bib.bib37)；Yang等，[2022](#bib.bib147)；Zou等，[2022](#bib.bib160)；Nguyen等，[2022b](#bib.bib109)，[a](#bib.bib108)）共计22项研究。源代码作为树（Dam等，[2017](#bib.bib33)；Shippey等，[2019](#bib.bib129)；Wang等，[2016](#bib.bib139)；Liu等，[2020](#bib.bib96)；Wang等，[2020](#bib.bib137)；Dinella等，[2020](#bib.bib36)；Lin等，[2017](#bib.bib92)；Li等，[2017](#bib.bib83)；Lin等，[2019](#bib.bib91)；Li等，[2021b](#bib.bib87)；Zhuang等，[2022](#bib.bib157)）是第二大主要表示技术，共计9项主要研究。一些研究者使用二进制代码作为图（Phan等，[2017](#bib.bib117)；Huang等，[2021](#bib.bib62)）来构建二进制级别的漏洞检测模型，共计2项主要研究。有14项主要研究使用了基于Token的表示，其中10项主要研究将源代码表示为token序列，三项主要研究将二进制代码建模为token，一项研究将文本表示为token序列（Zhou和Sharma，[2017](#bib.bib156)）。混合表示有5种不同类型，共计8项主要研究。Token
    Sequence+Commit Metrics是用于增强软件漏洞检测中输入表示的主要工件，占4项主要研究。这种方法结合了来自代码的token序列和软件提交派生的附加指标的信息。这种方法利用了代码的结构性和历史性方面，以提供更全面的表示来构建漏洞检测模型。
- en: Commits is the fourth least input representation used by 3 primary studies.
    In this representation, commit characteristics are used to build software vulnerability
    detection models.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 提交是3项主要研究中使用的第四少的输入表示。在这种表示方法中，提交特征用于构建软件漏洞检测模型。
- en: Table 8. Distribution of input representations in primary studies.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 表8. 主要研究中输入表示的分布。
- en: '| Category | Artifact | #Studies | Total | References |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 结果 | #研究 | 总计 | 参考文献 |'
- en: '| Graph/Tree-based | Source code as a graph | 22 | 32(32) | (Jeon and Kim,
    [2021](#bib.bib65); Tian et al., [2020](#bib.bib135); Liu et al., [2021c](#bib.bib99);
    Kronjee et al., [2018](#bib.bib73); Zeng et al., [2021](#bib.bib151); Li et al.,
    [2019](#bib.bib86); Zou et al., [2019](#bib.bib161); Cao et al., [2022](#bib.bib18);
    Ghaffarian and Shahriari, [2021](#bib.bib50); Wu et al., [2021](#bib.bib141);
    Zhuang et al., [2020](#bib.bib158); Li et al., [2021c](#bib.bib88), [2018](#bib.bib89);
    Duan et al., [2019](#bib.bib39); Zheng et al., [2021](#bib.bib154); Cheng et al.,
    [2022](#bib.bib31); Liu et al., [2021b](#bib.bib98); Ding et al., [2022](#bib.bib37);
    Yang et al., [2022](#bib.bib147); Zou et al., [2022](#bib.bib160); Nguyen et al.,
    [2022b](#bib.bib109), [a](#bib.bib108)) |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 基于图/树 | 源代码作为图 | 22 | 32(32) | (Jeon and Kim, [2021](#bib.bib65); Tian et
    al., [2020](#bib.bib135); Liu et al., [2021c](#bib.bib99); Kronjee et al., [2018](#bib.bib73);
    Zeng et al., [2021](#bib.bib151); Li et al., [2019](#bib.bib86); Zou et al., [2019](#bib.bib161);
    Cao et al., [2022](#bib.bib18); Ghaffarian and Shahriari, [2021](#bib.bib50);
    Wu et al., [2021](#bib.bib141); Zhuang et al., [2020](#bib.bib158); Li et al.,
    [2021c](#bib.bib88), [2018](#bib.bib89); Duan et al., [2019](#bib.bib39); Zheng
    et al., [2021](#bib.bib154); Cheng et al., [2022](#bib.bib31); Liu et al., [2021b](#bib.bib98);
    Ding et al., [2022](#bib.bib37); Yang et al., [2022](#bib.bib147); Zou et al.,
    [2022](#bib.bib160); Nguyen et al., [2022b](#bib.bib109), [a](#bib.bib108)) |'
- en: '|  | Source code as a tree | 9 |  | (Dam et al., [2017](#bib.bib33); Shippey
    et al., [2019](#bib.bib129); Wang et al., [2016](#bib.bib139); Liu et al., [2020](#bib.bib96);
    Lin et al., [2017](#bib.bib92); Li et al., [2017](#bib.bib83); Lin et al., [2019](#bib.bib91);
    Li et al., [2021b](#bib.bib87); Zhuang et al., [2022](#bib.bib157)) |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|  | 源代码作为树 | 9 |  | (Dam et al., [2017](#bib.bib33); Shippey et al., [2019](#bib.bib129);
    Wang et al., [2016](#bib.bib139); Liu et al., [2020](#bib.bib96); Lin et al.,
    [2017](#bib.bib92); Li et al., [2017](#bib.bib83); Lin et al., [2019](#bib.bib91);
    Li et al., [2021b](#bib.bib87); Zhuang et al., [2022](#bib.bib157)) |'
- en: '|  | Binary code as graph | 2 |  | (Phan et al., [2017](#bib.bib117); Huang
    et al., [2021](#bib.bib62)) |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|  | 二进制代码作为图 | 2 |  | (Phan et al., [2017](#bib.bib117); Huang et al., [2021](#bib.bib62))
    |'
- en: '| Token-based | Source code as a token | 10 | 14(14) | (Dam et al., [2018](#bib.bib34);
    Yamaguchi et al., [2013](#bib.bib145); Hoang et al., [2019](#bib.bib61); Zou et al.,
    [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Harer et al., [2018](#bib.bib56);
    Scandariato et al., [2014](#bib.bib125); Ziems and Wu, [2021](#bib.bib159); Filus
    et al., [2020](#bib.bib43); Yamaguchi et al., [2011](#bib.bib144)) |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 基于令牌 | 源代码作为令牌 | 10 | 14(14) | (Dam et al., [2018](#bib.bib34); Yamaguchi
    et al., [2013](#bib.bib145); Hoang et al., [2019](#bib.bib61); Zou et al., [2021](#bib.bib162);
    Huo et al., [2018](#bib.bib63); Harer et al., [2018](#bib.bib56); Scandariato
    et al., [2014](#bib.bib125); Ziems and Wu, [2021](#bib.bib159); Filus et al.,
    [2020](#bib.bib43); Yamaguchi et al., [2011](#bib.bib144)) |'
- en: '|  | Binary code as a token | 3 |  | (Nguyen et al., [2020](#bib.bib110); Yan
    et al., [2021](#bib.bib146); Le et al., [2018](#bib.bib77)) |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '|  | 二进制代码作为令牌 | 3 |  | (Nguyen et al., [2020](#bib.bib110); Yan et al., [2021](#bib.bib146);
    Le et al., [2018](#bib.bib77)) |'
- en: '|  | Text as a token | 1 |  | (Zhou and Sharma, [2017](#bib.bib156)) |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|  | 文本作为令牌 | 1 |  | (Zhou and Sharma, [2017](#bib.bib156)) |'
- en: '| Hybrid | Token Sequence+Commit Metrics | 4 | 8(8) | (Chen et al., [2020b](#bib.bib25);
    Perl et al., [2015](#bib.bib115); Riom et al., [2021](#bib.bib121); Ni et al.,
    [2022](#bib.bib111)) |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 混合 | 令牌序列+提交指标 | 4 | 8(8) | (Chen et al., [2020b](#bib.bib25); Perl et al.,
    [2015](#bib.bib115); Riom et al., [2021](#bib.bib121); Ni et al., [2022](#bib.bib111))
    |'
- en: '|  | Token Sequence+Term frequency | 1 |  | (Sabetta and Bezzi, [2018](#bib.bib124))
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|  | 令牌序列+词频 | 1 |  | (Sabetta and Bezzi, [2018](#bib.bib124)) |'
- en: '|  | Token Sequence+ Graph | 1 |  | (Fu and Tantithamthavorn, [2022](#bib.bib46))
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|  | 令牌序列+图 | 1 |  | (Fu and Tantithamthavorn, [2022](#bib.bib46)) |'
- en: '|  | Graph+Tree+Token Sequence | 1 |  | (Li et al., [2021a](#bib.bib85)) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  | 图+树+令牌序列 | 1 |  | (Li et al., [2021a](#bib.bib85)) |'
- en: '|  | Token+Tree | 1 |  | (Zhang et al., [2022](#bib.bib153)) |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|  | 令牌+树 | 1 |  | (Zhang et al., [2022](#bib.bib153)) |'
- en: '| Commits | Commit Metrics | 3 | 3 | (Pascarella et al., [2019](#bib.bib114);
    Yang et al., [2017](#bib.bib148); Ni et al., [2022](#bib.bib111)) |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 提交 | 提交指标 | 3 | 3 | (Pascarella et al., [2019](#bib.bib114); Yang et al.,
    [2017](#bib.bib148); Ni et al., [2022](#bib.bib111)) |'
- en: '| SUM | - | - | 57(55) | (Pascarella et al., [2019](#bib.bib114); Yang et al.,
    [2017](#bib.bib148); Ni et al., [2022](#bib.bib111)) | <svg height="154.3" overflow="visible"
    version="1.1" width="224.26"><g transform="translate(0,154.3) matrix(1 0 0 -1
    0 0) translate(14,0) translate(0,14.36) matrix(0.6 0.0 0.0 0.6 -14 -14.36)" fill="#000000"
    stroke="#000000" stroke-width="0.4pt"><g transform="matrix(1 0 0 1 0 0) translate(45.82,0)
    translate(0,23.93)"><g stroke="#000000" fill="#000000" stroke-width="0.4pt"><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 -27.63 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2011</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 -5.14 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2013</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 17.34 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2014</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 39.83 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2015</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 62.31 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2016</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 84.8 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2017</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 107.28 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2018</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 129.77 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2019</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 152.25 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2020</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 174.74 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2021</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 197.22 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2022</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 -34.29 -4.46)" fill="#000000" stroke="#000000"><foreignobject width="6.92"
    height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -34.29 51.58)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$5$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 107.62)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$10$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 163.66)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$15$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 219.7)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$20$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 86.48 1.15)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 108.97 51.58)" fill="#660066" stroke="#660066" color="#660066"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 131.45 90.81)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 153.94 85.2)" fill="#660066" stroke="#660066" color="#660066"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 176.42 57.19)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 198.9 186.08)" fill="#660066" stroke="#660066" color="#660066"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 221.39 141.24)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 -3.46 1.15)" fill="#000000" stroke="#000000" color="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 19.03 1.15)" fill="#000000" stroke="#000000"
    color="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 41.51 1.15)" fill="#000000" stroke="#000000" color="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 108.97 29.17)" fill="#000000" stroke="#000000"
    color="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 131.45 62.79)" fill="#000000" stroke="#000000" color="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$4$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 153.94 57.19)" fill="#000000" stroke="#000000"
    color="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 176.42 40.37)" fill="#000000" stroke="#000000" color="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 198.9 152.45)" fill="#000000" stroke="#000000"
    color="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$4$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 221.39 118.83)" fill="#000000" stroke="#000000" color="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 64 1.15)" fill="#734D26" stroke="#734D26" color="#734D26"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 131.45 34.77)" fill="#734D26" stroke="#734D26"
    color="#734D26"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 176.42 23.56)" fill="#734D26" stroke="#734D26" color="#734D26"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 198.9 118.83)" fill="#734D26" stroke="#734D26"
    color="#734D26"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 221.39 96.41)" fill="#734D26" stroke="#734D26" color="#734D26"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 108.97 12.35)" fill="#FF0000" stroke="#FF0000"
    color="#FF0000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 131.45 12.35)" fill="#FF0000" stroke="#FF0000" color="#FF0000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 153.94 23.56)" fill="#FF0000" stroke="#FF0000"
    color="#FF0000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 176.42 6.75)" fill="#FF0000" stroke="#FF0000" color="#FF0000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 195.45 51.58)" fill="#FF0000" stroke="#FF0000"
    color="#FF0000"><foreignobject width="13.84" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$10$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 221.39 45.98)" fill="#FF0000" stroke="#FF0000" color="#FF0000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$7$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 108.97 1.15)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 153.94 1.15)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 221.39 1.15)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g fill="#FFFFFF" stroke="#000000"
    transform="matrix(1.0 0.0 0.0 1.0 254.46 78.1)"><g  transform="matrix(1 0 0 -1
    0 77.325)"><g  transform="matrix(1 0 0 1 0 8.58)"><g transform="matrix(1 0 0 -1
    22.9 0) translate(16.05,0) matrix(1.0 0.0 0.0 1.0 -13.28 -3.69)" fill="#000000"
    stroke="#000000"><foreignobject width="26.56" height="9.46" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">Tree</foreignobject></g></g><g transform="matrix(1
    0 0 1 0 25.72)"><g transform="matrix(1 0 0 -1 17.93 0) translate(21.02,0) matrix(1.0
    0.0 0.0 1.0 -18.26 -3.77)" fill="#000000" stroke="#000000"><foreignobject width="36.9"
    height="9.61" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Token</foreignobject></g></g><g
    transform="matrix(1 0 0 1 0 42.94)"><g class="ltx_tikzmatrix_col ltx_nopad_l ltx_nopad_r"
    transform="matrix(1 0 0 -1 15.02 0) translate(23.93,0) matrix(1.0 0.0 0.0 1.0
    -21.16 -3.77)" fill="#000000" stroke="#000000"><foreignobject width="42.32" height="12.3"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Hybrid</foreignobject></g></g><g
    transform="matrix(1 0 0 1 0 60.16)"><g class="ltx_tikzmatrix_col ltx_nopad_l ltx_nopad_r"
    transform="matrix(1 0 0 -1 16.9 0) translate(22.05,0) matrix(1.0 0.0 0.0 1.0 -19.29
    -3.77)" fill="#000000" stroke="#000000"><foreignobject width="38.57" height="12.3"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Graph</foreignobject></g></g><g
    transform="matrix(1 0 0 1 0 77.35)"><g class="ltx_tikzmatrix_col ltx_nopad_l ltx_nopad_r"
    transform="matrix(1 0 0 -1 8.86 0) translate(30.1,0) matrix(1.0 0.0 0.0 1.0 -27.33
    -3.69)" fill="#000000" stroke="#000000"><foreignobject width="54.66" height="9.46"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Commits</foreignobject></g></g></g></g></g></g></g></svg>'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '| 总计 | - | - | 57(55) | (Pascarella 等，[2019](#bib.bib114)；Yang 等，[2017](#bib.bib148)；Ni
    等，[2022](#bib.bib111)) | <svg height="154.3" overflow="visible" version="1.1"
    width="224.26"><g transform="translate(0,154.3) matrix(1 0 0 -1 0 0) translate(14,0)
    translate(0,14.36) matrix(0.6 0.0 0.0 0.6 -14 -14.36)" fill="#000000" stroke="#000000"
    stroke-width="0.4pt"><g transform="matrix(1 0 0 1 0 0) translate(45.82,0) translate(0,23.93)"><g
    stroke="#000000" fill="#000000" stroke-width="0.4pt"><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 -27.63 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2011</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 -5.14 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2013</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 17.34 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2014</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 39.83 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2015</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 62.31 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2016</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 84.8 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2017</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 107.28 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2018</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 129.77 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2019</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 152.25 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2020</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 174.74 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2021</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 197.22 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2022</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -34.29 -4.46)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -34.29 51.58)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$5$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 107.62)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$10$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 163.66)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$15$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 219.7)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$20$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 86.48 1.15)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 108.97 51.58)" fill="#660066" stroke="#660066" color="#660066"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 131.45 90.81)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 153.94 85.2)" fill="#660066" stroke="#660066" color="#660066"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 176.42 57.19)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.'
- en: Figure 6. Distribution of data type representations in software vulnerability
    detection studies over time.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图6. 软件漏洞检测研究中数据类型表示的时间分布。
- en: Figure [6](#S4.F6 "Figure 6 ‣ 4.2.3\. RQ2.3\. How input data are represented?
    ‣ 4.2\. RQ2\. What are the characteristics of software vulnerability detection
    datasets? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection
    Using Machine Learning and Deep Learning") shows the distribution of data type
    representation in software vulnerability detection studies over time. As shown
    in the figure, Graph-based representation shows a substantial presence compared
    to other input representation techniques. There are a couple of reasons for this
    trend. First, graphs provide a natural and intuitive way to represent the structural
    relationships within the source code. By modeling the code as a graph, the relationships
    between functions, classes, methods, and variables can be captured effectively.
    This allows vulnerability detection algorithms to analyze the code at a higher
    level of abstraction and capture complex dependencies and interactions between
    code elements. Second, graph-based representations enable a better understanding
    of the context in which vulnerabilities may exist. By considering the surrounding
    code structure and dependencies, graph-based approaches can capture the flow of
    information and identify potential paths that can lead to vulnerabilities. This
    contextual understanding helps in identifying code patterns, control flow paths,
    and data dependencies that may introduce security vulnerabilities. Token-based
    representation has also gained popularity, with a peak occurrence in 2021\. This
    is because it provides a fine-grained representation of the code. It simplifies
    the code analysis process by reducing the complexity of the code to a sequence
    of tokens, making it easier to apply traditional natural language processing techniques
    or ML models. It is also easily applicable to a wide range of programming languages.
    While the tokens themselves may differ across languages, the concept of breaking
    the code into discrete units remains the same. This versatility allows vulnerability
    detection techniques based on token representation to be applied to different
    programming languages and codebases, which further increases the external validity
    of vulnerability detection models. However, there is a slight decline in 2022,
    indicating potential shifts or diversification in the selection of input representations.
    Hybrid representation is gained attention since 2021, which suggests that combining
    different representations is favored by researchers in software vulnerability
    detection, potentially due to the complementary benefits provided by multiple
    representations.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [6](#S4.F6 "图 6 ‣ 4.2.3\. RQ2.3\. 输入数据如何表示？ ‣ 4.2\. RQ2\. 软件漏洞检测数据集的特征是什么？
    ‣ 4\. 结果 ‣ 关于使用机器学习和深度学习进行自动化软件漏洞检测的调查") 显示了软件漏洞检测研究中数据类型表示的时间分布。如图所示，基于图的表示相比其他输入表示技术显示了显著的存在。这种趋势有几个原因。首先，图提供了一种自然直观的方式来表示源代码中的结构关系。通过将代码建模为图，可以有效地捕捉函数、类、方法和变量之间的关系。这使得漏洞检测算法能够在更高的抽象层次上分析代码，捕捉代码元素之间的复杂依赖和交互。其次，基于图的表示可以更好地理解可能存在漏洞的上下文。通过考虑周围的代码结构和依赖关系，基于图的方法可以捕捉信息流并识别可能导致漏洞的潜在路径。这种上下文理解有助于识别可能引入安全漏洞的代码模式、控制流路径和数据依赖。基于标记的表示也获得了越来越高的关注，2021年达到了峰值。这是因为它提供了代码的细粒度表示。它通过将代码简化为标记序列来简化代码分析过程，使得应用传统的自然语言处理技术或机器学习模型变得更加容易。它也适用于广泛的编程语言。尽管标记本身在不同语言中可能有所不同，但将代码拆分成离散单位的概念保持不变。这种多样性允许基于标记的漏洞检测技术应用于不同的编程语言和代码库，从而进一步提高漏洞检测模型的外部有效性。然而，2022年略有下降，表明输入表示的选择可能出现潜在的变化或多样化。混合表示自2021年以来受到关注，这表明将不同表示结合起来受到软件漏洞检测研究人员的青睐，这可能是由于多种表示提供的互补好处。
- en: 4.2.4\. RQ2.4\. How input data are embedded for feature space?
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4\. RQ2.4\. 输入数据如何嵌入特征空间？
- en: 'In the previous section, we discussed various representation techniques, and
    in this section, we further look at embedding methods that can transform these
    representations into inputs that can be understood by ML/DL models. The representation
    techniques are in a human-readable format, they cannot be directly interpreted
    by machines. Therefore, researchers use different embedding techniques to convert
    these representations into a numeric format. We discuss the embedding techniques
    in the following paragraphs based on the distribution shown in Figure [7](#S4.F7
    "Figure 7 ‣ 4.2.4\. RQ2.4\. How input data are embedded for feature space? ‣ 4.2\.
    RQ2\. What are the characteristics of software vulnerability detection datasets?
    ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability Detection Using Machine
    Learning and Deep Learning"). The figure illustrates the distribution of feature
    embedding techniques used in primary studies. The chart shows the following categories
    and their corresponding percentages: Word2vec (25.4%), Graph embedding (25.4%),
    Token vector embedding (11.9%), Others (16.4%), Hybrid (7.5%), One hot embedding
    (6.0%), Code token embedding (4.5%), and N-gram features (3.0%).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们讨论了各种表示技术，在这一节中，我们进一步探讨了可以将这些表示转换为ML/DL模型能够理解的输入的嵌入方法。表示技术以人类可读的格式存在，机器无法直接解释。因此，研究人员使用不同的嵌入技术将这些表示转换为数字格式。我们将基于图[7](#S4.F7
    "图7 ‣ 4.2.4\. RQ2.4\. 输入数据如何嵌入特征空间？ ‣ 4.2\. RQ2\. 软件漏洞检测数据集的特征是什么？ ‣ 4\. 结果 ‣
    基于机器学习和深度学习的自动化软件漏洞检测综述")中所示的分布讨论嵌入技术。该图展示了主要研究中使用的特征嵌入技术的分布。图表显示了以下类别及其相应的百分比：Word2vec（25.4%）、图嵌入（25.4%）、标记向量嵌入（11.9%）、其他（16.4%）、混合（7.5%）、独热编码（6.0%）、代码标记嵌入（4.5%）和N-gram特征（3.0%）。
- en: <svg   height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <svg   height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
- en: Figure 7. Different feature embedding techniques used in primary studies.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图7. 不同特征嵌入技术在主要研究中的应用。
- en: 'Word2vec (Chen et al., [2020b](#bib.bib25); Sabetta and Bezzi, [2018](#bib.bib124);
    Zhou and Sharma, [2017](#bib.bib156); Jeon and Kim, [2021](#bib.bib65); Yamaguchi
    et al., [2013](#bib.bib145); Du et al., [2020](#bib.bib38); Lin et al., [2018](#bib.bib93);
    Liu et al., [2019a](#bib.bib95); Pradel and Sen, [2018](#bib.bib119); Zhou et al.,
    [2019](#bib.bib155); Yan et al., [2021](#bib.bib146); Li et al., [2019](#bib.bib86);
    Zou et al., [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Zou et al., [2019](#bib.bib161);
    Scandariato et al., [2014](#bib.bib125); Riom et al., [2021](#bib.bib121); Lin
    et al., [2019](#bib.bib91); Perl et al., [2015](#bib.bib115); Li et al., [2021a](#bib.bib85)):
    is one of the most widely-used embedding techniques for source code embedding
    in the examined papers, accounting for 25.4% of primary studies. This can be because
    it has been shown to be effective in capturing the semantics and relationships
    between different code components. Word2vec can be trained on code corpus to learn
    embeddings for different code components, such as variables, functions, and operators.
    By considering the context in which these components appear, Word2vec can capture
    the semantic relationships between them. Furthermore, Word2vec is a computationally
    efficient and scalable technique, which can be trained on large code corpora.
    This is important for source code embedding, as the code corpus can be much larger
    than the text corpus typically used in natural language processing.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'Word2vec (Chen et al., [2020b](#bib.bib25); Sabetta and Bezzi, [2018](#bib.bib124);
    Zhou and Sharma, [2017](#bib.bib156); Jeon and Kim, [2021](#bib.bib65); Yamaguchi
    et al., [2013](#bib.bib145); Du et al., [2020](#bib.bib38); Lin et al., [2018](#bib.bib93);
    Liu et al., [2019a](#bib.bib95); Pradel and Sen, [2018](#bib.bib119); Zhou et
    al., [2019](#bib.bib155); Yan et al., [2021](#bib.bib146); Li et al., [2019](#bib.bib86);
    Zou et al., [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Zou et al., [2019](#bib.bib161);
    Scandariato et al., [2014](#bib.bib125); Riom et al., [2021](#bib.bib121); Lin
    et al., [2019](#bib.bib91); Perl et al., [2015](#bib.bib115); Li et al., [2021a](#bib.bib85)):
    是在研究文献中最广泛使用的源代码嵌入技术之一，占主要研究的25.4%。这可能是因为它已被证明在捕捉不同代码组件之间的语义和关系方面有效。Word2vec 可以在代码语料库上进行训练，以学习不同代码组件的嵌入，例如变量、函数和操作符。通过考虑这些组件出现的上下文，Word2vec
    可以捕捉它们之间的语义关系。此外，Word2vec 是一种计算高效且可扩展的技术，能够在大规模代码语料库上进行训练。这对源代码嵌入非常重要，因为代码语料库可能比自然语言处理中的文本语料库要大得多。'
- en: 'Graph embedding (Liu et al., [2021c](#bib.bib99); Wang et al., [2020](#bib.bib137);
    Phan et al., [2017](#bib.bib117); Zeng et al., [2021](#bib.bib151); Dinella et al.,
    [2020](#bib.bib36); Cao et al., [2022](#bib.bib18); Ghaffarian and Shahriari,
    [2021](#bib.bib50); Wu et al., [2021](#bib.bib141); Zhuang et al., [2020](#bib.bib158);
    Duan et al., [2019](#bib.bib39); Zheng et al., [2021](#bib.bib154)): is another
    widely-used embedding technique among the primary studies, accounting for 25.4%
    of primary studies, which is mostly used by graph neural networks. This can be
    because it can capture the structural relationships between different code components,
    such as functions, classes, and methods. In contrast to token-based representations
    or sequence-based representations, graph embedding can explicitly represent the
    connections and dependencies between different code components. In a graph-based
    representation, code components are represented as nodes, and the relationships
    between them are represented as edges. This allows for a more fine-grained representation
    of the code structure.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'Graph embedding (Liu et al., [2021c](#bib.bib99); Wang et al., [2020](#bib.bib137);
    Phan et al., [2017](#bib.bib117); Zeng et al., [2021](#bib.bib151); Dinella et
    al., [2020](#bib.bib36); Cao et al., [2022](#bib.bib18); Ghaffarian and Shahriari,
    [2021](#bib.bib50); Wu et al., [2021](#bib.bib141); Zhuang et al., [2020](#bib.bib158);
    Duan et al., [2019](#bib.bib39); Zheng et al., [2021](#bib.bib154)): 是另一种在主要研究中广泛使用的嵌入技术，占主要研究的25.4%，主要被图神经网络使用。这可能是因为它能够捕捉不同代码组件之间的结构关系，例如函数、类和方法。与基于标记的表示或基于序列的表示不同，图嵌入可以明确表示不同代码组件之间的连接和依赖关系。在基于图的表示中，代码组件被表示为节点，它们之间的关系被表示为边。这允许对代码结构进行更精细的表示。'
- en: 'Token vector embedding  (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33);
    Liu et al., [2020](#bib.bib96); Wang et al., [2016](#bib.bib139); Hoang et al.,
    [2019](#bib.bib61); Mao et al., [2020](#bib.bib103); Yamaguchi et al., [2012](#bib.bib143);
    Hin et al., [2022](#bib.bib59); Fu and Tantithamthavorn, [2022](#bib.bib46); Chen
    et al., [2021](#bib.bib26); Lin et al., [2017](#bib.bib92); Yamaguchi et al.,
    [2011](#bib.bib144)): is also a popular technique used by primary studies accounting
    for 11.9% of examined papers. In this technique, input is converted into a sequence
    of tokens and each token is transformed into a numeric value. Then, these values
    are fed into ML/DL models for further computations.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '令牌向量嵌入 (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33); Liu et al., [2020](#bib.bib96);
    Wang et al., [2016](#bib.bib139); Hoang et al., [2019](#bib.bib61); Mao et al.,
    [2020](#bib.bib103); Yamaguchi et al., [2012](#bib.bib143); Hin et al., [2022](#bib.bib59);
    Fu and Tantithamthavorn, [2022](#bib.bib46); Chen et al., [2021](#bib.bib26);
    Lin et al., [2017](#bib.bib92); Yamaguchi et al., [2011](#bib.bib144)): 也是一种流行的技术，占主要研究的
    11.9%。在这种技术中，输入被转换为令牌序列，每个令牌被转换为一个数值。这些数值然后被输入到 ML/DL 模型中进行进一步计算。'
- en: 'One hot embedding (Nguyen et al., [2020](#bib.bib110); Hoang et al., [2019](#bib.bib61);
    Harer et al., [2018](#bib.bib56); Le et al., [2018](#bib.bib77)): is a typical
    way for encoding categorical data, in which each category is represented by a
    binary vector of zeros and ones. This method can also be used to encode source
    code for vulnerability detection, which accounts for 6% of studies.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '独热编码 (Nguyen et al., [2020](#bib.bib110); Hoang et al., [2019](#bib.bib61);
    Harer et al., [2018](#bib.bib56); Le et al., [2018](#bib.bib77)): 是一种编码分类数据的典型方法，其中每个类别由一个由零和一组成的二进制向量表示。这种方法也可用于编码源代码以进行漏洞检测，占研究的
    6%。'
- en: 'Code token embedding (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33); Liu
    et al., [2020](#bib.bib96)): is used to represent source code tokens as dense
    vectors in a continuous vector space. Code token embedding captures the semantic
    and syntactic links between tokens by transferring them to a lower-dimensional
    vector space, as opposed to one hot encoding, which represents each token as a
    sparse binary vector.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '代码令牌嵌入 (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33); Liu et al., [2020](#bib.bib96)):
    用于将源代码令牌表示为连续向量空间中的密集向量。代码令牌嵌入通过将令牌转移到低维向量空间，捕捉令牌之间的语义和语法联系，而不是使用独热编码，该方法将每个令牌表示为稀疏的二进制向量。'
- en: 'N-gram features (Shippey et al., [2019](#bib.bib129); Le et al., [2021b](#bib.bib80)):
    is a method of expressing code snippets as fixed-length dense vectors, each vector
    representing an n-gram of tokens. N-grams are sequences of `n` tokens, such as
    words or letters, that capture local context and interdependence between neighboring
    tokens. We observed that 3% of primary studies use N-gram features for embedding.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'N-gram 特征 (Shippey et al., [2019](#bib.bib129); Le et al., [2021b](#bib.bib80)):
    是一种将代码片段表示为固定长度密集向量的方法，每个向量代表一个 n-gram 令牌序列。N-gram 是由`n`个令牌（如单词或字母）组成的序列，用于捕捉局部上下文和相邻令牌之间的相互依赖。我们观察到
    3% 的主要研究使用 N-gram 特征进行嵌入。'
- en: 'Hybrid  (Jeon and Kim, [2021](#bib.bib65); Cheng et al., [2021](#bib.bib29);
    Zhou et al., [2019](#bib.bib155); Li et al., [2019](#bib.bib86), [2021a](#bib.bib85)):
    We find that 7.5% of primary studies use multiple embedding techniques to convert
    inputs to ML/DL models. Different embedding techniques capture different aspects
    of the data. By combining multiple techniques, researchers can leverage the complementary
    information provided by each technique. For example, some embedding techniques
    may focus on syntax, while others may capture semantic or contextual information.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '混合 (Jeon and Kim, [2021](#bib.bib65); Cheng et al., [2021](#bib.bib29); Zhou
    et al., [2019](#bib.bib155); Li et al., [2019](#bib.bib86), [2021a](#bib.bib85)):
    我们发现 7.5% 的主要研究使用多种嵌入技术将输入转换为 ML/DL 模型。不同的嵌入技术捕捉数据的不同方面。通过结合多种技术，研究人员可以利用每种技术提供的互补信息。例如，一些嵌入技术可能专注于语法，而另一些则可能捕捉语义或上下文信息。'
- en: 'Others (Sabetta and Bezzi, [2018](#bib.bib124); Kronjee et al., [2018](#bib.bib73);
    Pascarella et al., [2019](#bib.bib114); Huang et al., [2021](#bib.bib62); Ziems
    and Wu, [2021](#bib.bib159); Filus et al., [2020](#bib.bib43); Yang et al., [2017](#bib.bib148);
    Zhuang et al., [2022](#bib.bib157); Cheng et al., [2022](#bib.bib31); Zhang et al.,
    [2022](#bib.bib153); Ni et al., [2022](#bib.bib111)): The remaining 16.4% that
    emerge seldom and do not belong to any group are classified as Others. For example,
    Zhang et al. (Zhang et al., [2022](#bib.bib153)) customizes the graphCodeBERT (Guo
    et al., [2020](#bib.bib55)) to propose a graph-guided masked attention mechanism
    for vulnerability detection in which it captures variable dependency relationships
    and integrates the graph structure into the Transformer model.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 其他（Sabetta 和 Bezzi, [2018](#bib.bib124); Kronjee 等, [2018](#bib.bib73); Pascarella
    等, [2019](#bib.bib114); Huang 等, [2021](#bib.bib62); Ziems 和 Wu, [2021](#bib.bib159);
    Filus 等, [2020](#bib.bib43); Yang 等, [2017](#bib.bib148); Zhuang 等, [2022](#bib.bib157);
    Cheng 等, [2022](#bib.bib31); Zhang 等, [2022](#bib.bib153); Ni 等, [2022](#bib.bib111))：剩余的
    16.4% 既不属于任何一组也很少出现，因此被归类为“其他”。例如，Zhang 等（Zhang 等, [2022](#bib.bib153)）定制了 `graphCodeBERT`（Guo
    等, [2020](#bib.bib55)），提出了一种图引导的掩码注意力机制用于漏洞检测，其中捕捉了变量依赖关系，并将图结构集成到 Transformer
    模型中。
- en: <svg   height="214.29" overflow="visible" version="1.1" width="593.51"><g transform="translate(0,214.29)
    matrix(1 0 0 -1 0 0) translate(20.38,0) translate(0,173.2)"><g stroke="#000000"><g
    stroke-width="1.0pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 0 0)"><foreignobject width="552.76" height="162.51" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">(1) 65.7% of primary studies use benchmark
    data for software vulnerability detection. This can be because benchmark datasets
    are readily accessible to all researchers and can facilitate the reproducibility
    of studies. (2) The most common data type among the examined vulnerability detection
    studies is Code-based data type, accounting for 47 studies. In this category,
    Source code is the most prominent sub-type accounting for 42 studies. (3) Graph-based
    and Token-based input representations are the most popular input representation
    techniques used by primary studies accounting for 38.8% and 29.9% of primary studies
    respectively. (4) Graph embedding and Word2vec are the two most widely used embedding
    techniques used in primary studies accounting for 25.4% of studies respectively.
    <g stroke-width="0.5pt" fill="#FF9999"><path d="M 97.05 40.75 L 5.19 40.75 C 2.13
    40.75 -0.35 38.27 -0.35 35.21 L -0.35 24.91 C -0.35 21.86 2.13 19.38 5.19 19.38
    L 97.05 19.38 C 100.11 19.38 102.59 21.86 102.59 24.91 L 102.59 35.21 C 102.59
    38.27 100.11 40.75 97.05 40.75 Z M -0.35 19.38"></path></g><g stroke-width="0.5pt"
    fill="#000000" stroke="#000000" transform="matrix(1.0 0.0 0.0 1.0 4.27 26.68)"><foreignobject
    width="94.09" height="12.15" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Answer
    to RQ2</foreignobject></g>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: <svg   height="214.29" overflow="visible" version="1.1" width="593.51"><g transform="translate(0,214.29)
    matrix(1 0 0 -1 0 0) translate(20.38,0) translate(0,173.2)"><g stroke="#000000"><g
    stroke-width="1.0pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 0 0)"><foreignobject width="552.76" height="162.51" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">(1) 65.7% 的初级研究使用基准数据进行软件漏洞检测。这是因为基准数据集对所有研究人员都是容易获取的，并且可以促进研究的可重复性。(2)
    在审查的漏洞检测研究中，最常见的数据类型是基于代码的数据类型，占 47 个研究。在这一类别中，源代码是最突出的子类型，占 42 个研究。(3) 基于图和基于令牌的输入表示是初级研究中最流行的输入表示技术，分别占
    38.8% 和 29.9%。(4) 图嵌入和 Word2vec 是初级研究中使用最广泛的嵌入技术，各占 25.4% 的研究。<g stroke-width="0.5pt"
    fill="#FF9999"><path d="M 97.05 40.75 L 5.19 40.75 C 2.13 40.75 -0.35 38.27 -0.35
    35.21 L -0.35 24.91 C -0.35 21.86 2.13 19.38 5.19 19.38 L 97.05 19.38 C 100.11
    19.38 102.59 21.86 102.59 24.91 L 102.59 35.21 C 102.59 38.27 100.11 40.75 97.05
    40.75 Z M -0.35 19.38"></path></g><g stroke-width="0.5pt" fill="#000000" stroke="#000000"
    transform="matrix(1.0 0.0 0.0 1.0 4.27 26.68)"><foreignobject width="94.09" height="12.15"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">RQ2 的答案</foreignobject></g>
- en: 4.3\. RQ3\. What are the ML/DL models used for software vulnerability detection?
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. RQ3\. 用于软件漏洞检测的 ML/DL 模型有哪些？
- en: In this section, we provide detailed information about the various ML/DL models
    utilized for software vulnerability detection. Initially, we present an analysis
    of the usage distribution of ML/DL models based on primary studies. Subsequently,
    we delve into the distribution of the usage of DL models used in primary studies
    over time. However, we have not extensively analyzed the distribution of ML models
    since their prevalence is relatively small compared to DL models. Nonetheless,
    we provide a comprehensive list of classic ML models that have been commonly employed
    in primary studies.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提供了关于用于软件漏洞检测的各种ML/DL模型的详细信息。最初，我们基于主要研究展示了ML/DL模型的使用分布分析。随后，我们*深入探讨*了主要研究中DL模型使用的时间分布。然而，由于ML模型的普及程度相对于DL模型较小，我们尚未广泛分析ML模型的分布。尽管如此，我们提供了一份在主要研究中常用的经典ML模型的*综合清单*。
- en: <svg   height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: <svg   height="1" overflow="visible" version="1.1" width="1"><g transform="translate(0,1)
    matrix(1 0 0 -1 0 0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><foreignobject
    width="0" height="0" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">\pie</foreignobject></g></svg>
- en: Figure 8. Distribution of models used in primary studies. DM stands for Distance
    Measure and LM stands for Language Model.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图8. 主要研究中使用的模型分布。DM代表距离度量，LM代表语言模型。
- en: From Figure [8](#S4.F8 "Figure 8 ‣ 4.3\. RQ3\. What are the ML/DL models used
    for software vulnerability detection? ‣ 4\. Results ‣ A Survey on Automated Software
    Vulnerability Detection Using Machine Learning and Deep Learning"), it is observable
    that 79.1% of studies are using DL models for software vulnerability detection
    (Russell et al., [2018](#bib.bib123); Dam et al., [2018](#bib.bib34), [2017](#bib.bib33);
    Wang et al., [2016](#bib.bib139); Jeon and Kim, [2021](#bib.bib65); An et al.,
    [2020](#bib.bib5); Tian et al., [2020](#bib.bib135); Liu et al., [2020](#bib.bib96),
    [2021c](#bib.bib99); Wang et al., [2020](#bib.bib137); Phan et al., [2017](#bib.bib117);
    Lin et al., [2018](#bib.bib93); Liu et al., [2019a](#bib.bib95); Pradel and Sen,
    [2018](#bib.bib119); Le et al., [2021b](#bib.bib80); Hoang et al., [2019](#bib.bib61);
    Cheng et al., [2021](#bib.bib29); Zhou et al., [2019](#bib.bib155)) while merely
    16.4% of studies use classic ML models (Nguyen et al., [2020](#bib.bib110); Kronjee
    et al., [2018](#bib.bib73); Pascarella et al., [2019](#bib.bib114); Yamaguchi
    et al., [2012](#bib.bib143); Scandariato et al., [2014](#bib.bib125); Riom et al.,
    [2021](#bib.bib121); Perl et al., [2015](#bib.bib115); Yamaguchi et al., [2011](#bib.bib144)).
    Also, a limited number of studies use Language models denoted as LM (Shippey et al.,
    [2019](#bib.bib129); Pang et al., [2015](#bib.bib113)) and Distance Measures denoted
    as DM (Yamaguchi et al., [2013](#bib.bib145); Huang et al., [2021](#bib.bib62)).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 从图[8](#S4.F8 "Figure 8 ‣ 4.3\. RQ3\. What are the ML/DL models used for software
    vulnerability detection? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning")可以看出，79.1%的研究使用了DL模型进行软件漏洞检测（Russell等，[2018](#bib.bib123)；Dam等，[2018](#bib.bib34)，[2017](#bib.bib33)；Wang等，[2016](#bib.bib139)；Jeon和Kim，[2021](#bib.bib65)；An等，[2020](#bib.bib5)；Tian等，[2020](#bib.bib135)；Liu等，[2020](#bib.bib96)，[2021c](#bib.bib99)；Wang等，[2020](#bib.bib137)；Phan等，[2017](#bib.bib117)；Lin等，[2018](#bib.bib93)；Liu等，[2019a](#bib.bib95)；Pradel和Sen，[2018](#bib.bib119)；Le等，[2021b](#bib.bib80)；Hoang等，[2019](#bib.bib61)；Cheng等，[2021](#bib.bib29)；Zhou等，[2019](#bib.bib155)），而仅有16.4%的研究使用经典ML模型（Nguyen等，[2020](#bib.bib110)；Kronjee等，[2018](#bib.bib73)；Pascarella等，[2019](#bib.bib114)；Yamaguchi等，[2012](#bib.bib143)；Scandariato等，[2014](#bib.bib125)；Riom等，[2021](#bib.bib121)；Perl等，[2015](#bib.bib115)；Yamaguchi等，[2011](#bib.bib144)）。此外，少量研究使用了语言模型（LM），如Shippey等，[2019](#bib.bib129)；Pang等，[2015](#bib.bib113)）以及距离度量（DM），如Yamaguchi等，[2013](#bib.bib145)；Huang等，[2021](#bib.bib62)。
- en: <svg   height="154.3" overflow="visible" version="1.1" width="239.13"><g transform="translate(0,154.3)
    matrix(1 0 0 -1 0 0) translate(14,0) translate(0,14.36) matrix(0.6 0.0 0.0 0.6
    -14 -14.36)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g  transform="matrix(1
    0 0 1 0 0) translate(45.82,0) translate(0,23.93)"><g stroke="#000000" fill="#000000"
    stroke-width="0.4pt"><g transform="matrix(0.90631 0.42262 -0.42262 0.90631 -27.63
    -17.8)" fill="#000000" stroke="#000000"><foreignobject width="27.67" height="8.92"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2016</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 9.85 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2017</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 47.32 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2018</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 84.8 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2019</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 122.27 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2020</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 159.74 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2021</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 197.22 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2022</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -34.29 -4.46)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -34.29 40.37)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$5$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 85.2)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$10$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 130.04)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$15$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 174.87)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$20$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 219.7)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$25$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 183.91 197.28)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 221.39 107.62)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 34.02 26.92)" fill="#00FF00" stroke="#00FF00"
    color="#00FF00"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 71.49 35.89)" fill="#00FF00" stroke="#00FF00" color="#00FF00"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 108.96 49.34)" fill="#00FF00" stroke="#00FF00"
    color="#00FF00"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 146.44 49.34)" fill="#00FF00" stroke="#00FF00" color="#00FF00"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$6$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 183.91 156.93)" fill="#00FF00" stroke="#00FF00"
    color="#00FF00"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$8$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 221.39 80.72)" fill="#00FF00" stroke="#00FF00" color="#00FF00"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 71.49 17.96)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 108.96 35.89)" fill="#660066" stroke="#660066" color="#660066"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 146.44 17.96)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 183.91 112.1)" fill="#660066" stroke="#660066" color="#660066"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -3.46 0.02)" fill="#000000" stroke="#000000"
    color="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 34.02 17.96)" fill="#000000" stroke="#000000" color="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 71.49 8.99)" fill="#000000" stroke="#000000"
    color="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 34.02 8.99)" fill="#734D26" stroke="#734D26" color="#734D26"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 108.96 26.92)" fill="#734D26" stroke="#734D26"
    color="#734D26"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 146.44 4.51)" fill="#734D26" stroke="#734D26" color="#734D26"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 180.45 53.82)" fill="#734D26" stroke="#734D26"
    color="#734D26"><foreignobject width="13.84" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$11$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 221.39 44.86)" fill="#734D26" stroke="#734D26" color="#734D26"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$5$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 34.02 0.02)" fill="#FF0000" stroke="#FF0000"
    color="#FF0000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 71.49 0.02)" fill="#FF0000" stroke="#FF0000" color="#FF0000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 108.96 17.96)" fill="#FF0000" stroke="#FF0000"
    color="#FF0000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 108.96 4.51)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 183.91 0.02)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 221.39 8.99)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g
    fill="#FFFFFF" stroke="#000000" transform="matrix(1.0 0.0 0.0 1.0 254.46 60.99)"><g
    transform="matrix(1 0 0 -1 0 111.555)"><g transform="matrix(1 0 0 1 0 8.61)"><g
    transform="matrix(1 0 0 -1 8.86 0) translate(42.49,0) matrix(1.0 0.0 0.0 1.0 -39.72
    -3.77)" fill="#000000" stroke="#000000"><foreignobject width="79.45" height="9.61"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Transformers</foreignobject></g></g><g
    transform="matrix(1 0 0 1 0 25.8)"><g class="ltx_tikzmatrix_col ltx_nopad_l ltx_nopad_r"
    transform="matrix(1 0 0 -1 33.11 0) translate(18.24,0) matrix(1.0 0.0 0.0 1.0
    -15.47 -3.69)" fill="#000000" stroke="#000000"><foreignobject width="30.94" height="9.46"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">RNN</foreignobject></g></g><g
    transform="matrix(1 0 0 1 0 42.94)"><g class="ltx_tikzmatrix_col ltx_nopad_l ltx_nopad_r"
    transform="matrix(1 0 0 -1 27.42 0) translate(23.93,0) matrix(1.0 0.0 0.0 1.0
    -21.16 -3.77)" fill="#000000" stroke="#000000"><foreignobject width="42.32" height="12.3"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Hybrid</foreignobject></g></g><g
    transform="matrix(1 0 0 1 0 60.16)"><g class="ltx_tikzmatrix_col ltx_nopad_l ltx_nopad_r"
    transform="matrix(1 0 0 -1 25.07 0) translate(26.28,0) matrix(1.0 0.0 0.0 1.0
    -23.51 -3.77)" fill="#000000" stroke="#000000"><foreignobject width="47.03" height="9.61"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">General</foreignobject></g></g><g
    transform="matrix(1 0 0 1 0 77.35)"><g class="ltx_tikzmatrix_col ltx_nopad_l ltx_nopad_r"
    transform="matrix(1 0 0 -1 32.77 0) translate(18.57,0) matrix(1.0 0.0 0.0 1.0
    -15.81 -3.69)" fill="#000000" stroke="#000000"><foreignobject width="31.61" height="9.46"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">GNN</foreignobject></g></g><g
    transform="matrix(1 0 0 1 0 94.46)"><g class="ltx_tikzmatrix_col ltx_nopad_l ltx_nopad_r"
    transform="matrix(1 0 0 -1 33.2 0) translate(18.14,0) matrix(1.0 0.0 0.0 1.0 -15.37
    -3.69)" fill="#000000" stroke="#000000"><foreignobject width="30.75" height="9.46"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">CNN</foreignobject></g></g><g
    transform="matrix(1 0 0 1 0 111.57)"><g class="ltx_tikzmatrix_col ltx_nopad_l
    ltx_nopad_r" transform="matrix(1 0 0 -1 19.56 0) translate(31.79,0) matrix(1.0
    0.0 0.0 1.0 -29.02 -3.69)" fill="#000000" stroke="#000000"><foreignobject width="58.42"
    height="9.46" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Attention</foreignobject></g></g></g></g></g></g></g></svg>
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: <svg height="154.3" overflow="visible" version="1.1" width="239.13"><g transform="translate(0,154.3)
    matrix(1 0 0 -1 0 0) translate(14,0) translate(0,14.36) matrix(0.6 0.0 0.0 0.6
    -14 -14.36)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g transform="matrix(1
    0 0 1 0 0) translate(45.82,0) translate(0,23.93)"><g stroke="#000000" fill="#000000"
    stroke-width="0.4pt"><g transform="matrix(0.90631 0.42262 -0.42262 0.90631 -27.63
    -17.8)" fill="#000000" stroke="#000000"><foreignobject width="27.67" height="8.92"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2016</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 9.85 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2017</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 47.32 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2018</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 84.8 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2019</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 122.27 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2020</foreignobject></g><g
    transform="matrix(0.90631 0.42262 -0.42262 0.90631 159.74 -17.8)" fill="#000000"
    stroke="#000000"><foreignobject width="27.67" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2021</foreignobject></g><g transform="matrix(0.90631
    0.42262 -0.42262 0.90631 197.22 -17.8)" fill="#000000" stroke="#000000"><foreignobject
    width="27.67" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2022</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -34.29 -4.46)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$0$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -34.29 40.37)" fill="#000000" stroke="#000000"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$5$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 85.2)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$10$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 130.04)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$15$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 174.87)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$20$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 -41.21 219.7)" fill="#000000" stroke="#000000"><foreignobject
    width="13.84" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$25$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 183.91 197.28)" fill="#0000FF" stroke="#0000FF"
    color="#0000FF"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 221.39 107.62)" fill="#0000FF" stroke="#0000FF" color="#0000FF"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 34.02 26.92)" fill="#00FF00" stroke="#00FF00"
    color="#00FF00"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$1$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 71.49 35.89)" fill="#00FF00" stroke="#00FF00" color="#00FF00"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 108.96 49.34)" fill="#00FF00" stroke="#00FF00"
    color="#00FF00"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$2$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 146.44 49.34)" fill="#00FF00" stroke="#00FF00" color="#00FF00"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$6$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 183.91 156.93)" fill="#00FF00" stroke="#00FF00"
    color="#00FF00"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">$8$</foreignobject></g><g transform="matrix(1.0
    0.0 0.0 1.0 221.39 80.72)" fill="#00FF00" stroke="#00FF00" color="#00FF00"><foreignobject
    width="6.92" height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">$3$</foreignobject></g><g
    transform="matrix(1.0 0.0 0.0 1.0 71.49 17.96)" fill="#660066" stroke="#660066"
    color="#660066"><foreignobject width="6.92"
- en: Figure 9. Trend of DL models over time.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9. DL 模型随时间变化的趋势。
- en: The graph in Figure [9](#S4.F9 "Figure 9 ‣ 4.3\. RQ3\. What are the ML/DL models
    used for software vulnerability detection? ‣ 4\. Results ‣ A Survey on Automated
    Software Vulnerability Detection Using Machine Learning and Deep Learning") illustrates
    the usage trend of DL models in detecting software vulnerabilities from 2016 to
    2022\. According to the trend, DL models were first introduced in 2016 for vulnerability
    detection, since then the use of RNNs for vulnerability detection showed an upward
    trend. The graph also demonstrates a rising trend in using GNNs for vulnerability
    detection from 2020 to 2022\. This can be because GNNs are more powerful than
    RNNs in detecting vulnerabilities, as they can capture more meaningful and semantic
    representations of input source code. Since vulnerability types often have complex
    structures, GNNs are an excellent fit for detecting hidden structural information.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [9](#S4.F9 "Figure 9 ‣ 4.3\. RQ3\. What are the ML/DL models used for software
    vulnerability detection? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning") 展示了从 2016 年到 2022 年，DL 模型在检测软件漏洞中的使用趋势。根据这一趋势，DL
    模型在 2016 年首次引入用于漏洞检测，此后，RNN 在漏洞检测中的使用显示出上升趋势。图中还展示了从 2020 年到 2022 年，使用 GNN 进行漏洞检测的上升趋势。这可能是因为
    GNN 在检测漏洞时比 RNN 更强大，因为 GNN 能够捕捉输入源代码中更有意义和语义性的表示。由于漏洞类型通常具有复杂的结构，GNN 非常适合检测隐藏的结构信息。
- en: Table [9](#S4.T9 "Table 9 ‣ 4.3\. RQ3\. What are the ML/DL models used for software
    vulnerability detection? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning") shows the distribution of
    DL models used in primary studies. As shown in the table, LSTM is the most frequently
    used recurrent model, appearing in 8 studies. BiLSTM and BGRU are also popular
    models with 8 and 6 studies respectively. It is also observable that GGNN is the
    most prevalent graph-based model, appearing in 4 studies. GCN, GAT, and DR-GCN
    are also commonly used accounting for 4, 3, and 2 studies respectively. The presence
    of these models highlights the importance of capturing graph structures and relationships
    between code elements in vulnerability detection. Attention models were also used
    in 7 primary studies. Attention mechanisms allow models to pay more attention
    to specific parts of the code or input that are more likely to contain vulnerability-related
    patterns. This ability to localize relevant information helps identify and understand
    the factors contributing to vulnerabilities more effectively. CNNs are used in
    6 studies. While not as prevalent as recurrent or graph models, CNNs are still
    considered effective for capturing local patterns and features in vulnerability
    detection tasks. General models like DBN, Auto Encoders, Memory Neural Networks,
    GAN, and Para2Vec are also used to a lesser extent, indicating the exploration
    of diverse deep learning techniques in vulnerability detection. Transformers are
    the least frequent family of DL models used in primary studies. This is because
    they have been recently introduced for software vulnerability detection. Transformers
    are effective in this domain since they generate contextualized representations
    for each token in the input sequence. By considering the surrounding tokens and
    their interactions, transformers capture rich contextual information, which is
    crucial for understanding vulnerabilities that depend on the overall context of
    the code or vulnerability-related text.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 表格[9](#S4.T9 "表格 9 ‣ 4.3\. RQ3\. 用于软件漏洞检测的 ML/DL 模型有哪些？ ‣ 4\. 结果 ‣ 基于机器学习和深度学习的自动化软件漏洞检测调查")展示了在主要研究中使用的深度学习模型的分布。如表所示，LSTM
    是使用频率最高的递归模型，出现于8项研究中。BiLSTM 和 BGRU 也是受欢迎的模型，分别出现在8项和6项研究中。还可以观察到，GGNN 是最常见的基于图的模型，出现在4项研究中。GCN、GAT
    和 DR-GCN 也被广泛使用，分别占4项、3项和2项研究。这些模型的存在突显了在漏洞检测中捕捉图结构和代码元素之间关系的重要性。注意力模型也在7项主要研究中使用。注意力机制使得模型可以更多地关注代码或输入中更可能包含漏洞相关模式的特定部分。这种定位相关信息的能力有助于更有效地识别和理解导致漏洞的因素。CNNs
    在6项研究中被使用。虽然不如递归模型或图模型普遍，CNNs 仍被认为在漏洞检测任务中有效捕捉局部模式和特征。像 DBN、自动编码器、记忆神经网络、GAN 和
    Para2Vec 等通用模型也被使用，但程度较少，这表明在漏洞检测中探索了多样化的深度学习技术。变换器是主要研究中使用最少的深度学习模型家族。这是因为它们最近才被引入用于软件漏洞检测。变换器在这一领域非常有效，因为它们为输入序列中的每个标记生成上下文化的表示。通过考虑周围的标记及其交互，变换器捕捉丰富的上下文信息，这对于理解依赖于代码或漏洞相关文本整体上下文的漏洞至关重要。
- en: Table [10](#S4.T10 "Table 10 ‣ 4.3\. RQ3\. What are the ML/DL models used for
    software vulnerability detection? ‣ 4\. Results ‣ A Survey on Automated Software
    Vulnerability Detection Using Machine Learning and Deep Learning") shows the distribution
    of ML models used in primary studies. As shown in the figure, Random Forest is
    the most frequently used ML model, appearing in 7 studies. SVM, Naive Bayes, and
    Logistic Regression are popular choices, with 6, 5, and 4 occurrences, respectively.
    N-Gram models are used in 1 study, indicating their application in capturing sequential
    patterns and language-based features in vulnerability detection. N-Gram models
    are commonly used for text analysis and have been adapted for code analysis tasks.
    Distance measures are utilized in 2 studies for vulnerability detection. These
    metrics help quantify the similarity or dissimilarity between code elements or
    features, enabling the identification of potentially vulnerable code segments
    based on their proximity to known vulnerabilities.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 表 [10](#S4.T10 "表 10 ‣ 4.3\. RQ3\. 用于软件漏洞检测的 ML/DL 模型有哪些？ ‣ 4\. 结果 ‣ 关于使用机器学习和深度学习的自动化软件漏洞检测的调查")
    显示了主要研究中使用的 ML 模型的分布。如图所示，随机森林是使用最频繁的 ML 模型，出现在 7 项研究中。SVM、朴素贝叶斯和逻辑回归是受欢迎的选择，分别出现了
    6 次、5 次和 4 次。N-Gram 模型在 1 项研究中被使用，这表明它们在捕捉顺序模式和基于语言的特征在漏洞检测中的应用。N-Gram 模型通常用于文本分析，并已被适应用于代码分析任务。距离度量在
    2 项研究中被用于漏洞检测。这些度量帮助量化代码元素或特征之间的相似性或差异性，从而基于其与已知漏洞的接近程度识别潜在的易受攻击代码段。
- en: Table 9. Distribution of DL models in primary studies.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9. 主要研究中的 DL 模型分布。
- en: '| Category | Model Name | # Studies | Total | References |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 模型名称 | 研究数量 | 总计 | 参考文献 |'
- en: '| Recurrent Models | LSTM | 8 | 31(21) | (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33);
    Wang et al., [2016](#bib.bib139); Tian et al., [2020](#bib.bib135); Liu et al.,
    [2020](#bib.bib96), [2019a](#bib.bib95); Ziems and Wu, [2021](#bib.bib159); Zhuang
    et al., [2022](#bib.bib157)) |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 循环模型 | LSTM | 8 | 31(21) | (Dam et al., [2018](#bib.bib34), [2017](#bib.bib33);
    Wang et al., [2016](#bib.bib139); Tian et al., [2020](#bib.bib135); Liu et al.,
    [2020](#bib.bib96), [2019a](#bib.bib95); Ziems and Wu, [2021](#bib.bib159); Zhuang
    et al., [2022](#bib.bib157)) |'
- en: '|  | BiLSTM | 8 |  | (Jeon and Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135);
    Zou et al., [2021](#bib.bib162), [2019](#bib.bib161); Lin et al., [2017](#bib.bib92),
    [2019](#bib.bib91); Li et al., [2021b](#bib.bib87), [2018](#bib.bib89)) |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|  | BiLSTM | 8 |  | (Jeon and Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135);
    Zou et al., [2021](#bib.bib162), [2019](#bib.bib161); Lin et al., [2017](#bib.bib92),
    [2019](#bib.bib91); Li et al., [2021b](#bib.bib87), [2018](#bib.bib89)) |'
- en: '|  | BGRU | 6 |  | (Jeon and Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135);
    Yan et al., [2021](#bib.bib146); Zou et al., [2021](#bib.bib162); Li et al., [2021c](#bib.bib88),
    [b](#bib.bib87)) |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|  | BGRU | 6 |  | (Jeon and Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135);
    Yan et al., [2021](#bib.bib146); Zou et al., [2021](#bib.bib162); Li et al., [2021c](#bib.bib88),
    [b](#bib.bib87)) |'
- en: '|  | GRU | 4 |  | (Jeon and Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135);
    Li et al., [2019](#bib.bib86); Hin et al., [2022](#bib.bib59)) |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '|  | GRU | 4 |  | (Jeon and Kim, [2021](#bib.bib65); Tian et al., [2020](#bib.bib135);
    Li et al., [2019](#bib.bib86); Hin et al., [2022](#bib.bib59)) |'
- en: '|  | RNN | 3 |  | (Tian et al., [2020](#bib.bib135); Le et al., [2018](#bib.bib77);
    Filus et al., [2020](#bib.bib43)) |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '|  | RNN | 3 |  | (Tian et al., [2020](#bib.bib135); Le et al., [2018](#bib.bib77);
    Filus et al., [2020](#bib.bib43)) |'
- en: '|  | BRNN | 2 |  | (Tian et al., [2020](#bib.bib135); Le et al., [2018](#bib.bib77))
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|  | BRNN | 2 |  | (Tian et al., [2020](#bib.bib135); Le et al., [2018](#bib.bib77))
    |'
- en: '| Graph Models | GGNN | 4 | 18(15) | (Wang et al., [2020](#bib.bib137); Dinella
    et al., [2020](#bib.bib36); Ding et al., [2022](#bib.bib37); Zou et al., [2022](#bib.bib160))
    |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 图模型 | GGNN | 4 | 18(15) | (Wang et al., [2020](#bib.bib137); Dinella et al.,
    [2020](#bib.bib36); Ding et al., [2022](#bib.bib37); Zou et al., [2022](#bib.bib160))
    |'
- en: '|  | GCN | 4 |  | (Cheng et al., [2021](#bib.bib29); Zeng et al., [2021](#bib.bib151);
    Ghaffarian and Shahriari, [2021](#bib.bib50); Li et al., [2021a](#bib.bib85))
    |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '|  | GCN | 4 |  | (Cheng et al., [2021](#bib.bib29); Zeng et al., [2021](#bib.bib151);
    Ghaffarian and Shahriari, [2021](#bib.bib50); Li et al., [2021a](#bib.bib85))
    |'
- en: '|  | GAT | 3 |  | (Cheng et al., [2021](#bib.bib29); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Ghaffarian and Shahriari, [2021](#bib.bib50)) |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|  | GAT | 3 |  | (Cheng et al., [2021](#bib.bib29); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Ghaffarian and Shahriari, [2021](#bib.bib50)) |'
- en: '|  | DR-GCN | 2 |  | (Liu et al., [2021c](#bib.bib99); Zhuang et al., [2020](#bib.bib158))
    |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|  | DR-GCN | 2 |  | (Liu et al., [2021c](#bib.bib99); Zhuang et al., [2020](#bib.bib158))
    |'
- en: '|  | RGCN | 1 |  | (Zheng et al., [2021](#bib.bib154)) |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|  | RGCN | 1 |  | (Zheng et al., [2021](#bib.bib154)) |'
- en: '|  | FS-GNN | 1 |  | (Cao et al., [2022](#bib.bib18)) |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|  | FS-GNN | 1 |  | (Cao et al., [2022](#bib.bib18)) |'
- en: '|  | K-GNN | 1 |  | (Cheng et al., [2021](#bib.bib29)) |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  | K-GNN | 1 |  | (Cheng et al., [2021](#bib.bib29)) |'
- en: '|  | DGCNN | 1 |  | (Phan et al., [2017](#bib.bib117)) |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  | DGCNN | 1 |  | (Phan et al., [2017](#bib.bib117)) |'
- en: '|  | GGRN | 1 |  | (Zhou et al., [2019](#bib.bib155)) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '|  | GGRN | 1 |  | (Zhou et al., [2019](#bib.bib155)) |'
- en: '| Attention Models | - | 7 | 7 | (Le et al., [2021b](#bib.bib80); Li et al.,
    [2019](#bib.bib86); Zou et al., [2019](#bib.bib161); Duan et al., [2019](#bib.bib39);
    Cheng et al., [2022](#bib.bib31); Liu et al., [2021b](#bib.bib98); Zhang et al.,
    [2022](#bib.bib153)) |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 注意力模型 | - | 7 | 7 | (Le et al., [2021b](#bib.bib80); Li et al., [2019](#bib.bib86);
    Zou et al., [2019](#bib.bib161); Duan et al., [2019](#bib.bib39); Cheng et al.,
    [2022](#bib.bib31); Liu et al., [2021b](#bib.bib98); Zhang et al., [2022](#bib.bib153))
    |'
- en: '| Convolutional Models | CNN | 6 | 6 | (Hoang et al., [2019](#bib.bib61); Yan
    et al., [2021](#bib.bib146); Zou et al., [2021](#bib.bib162); Huo et al., [2018](#bib.bib63);
    Li et al., [2017](#bib.bib83); Filus et al., [2020](#bib.bib43)) |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 卷积模型 | CNN | 6 | 6 | (Hoang et al., [2019](#bib.bib61); Yan et al., [2021](#bib.bib146);
    Zou et al., [2021](#bib.bib162); Huo et al., [2018](#bib.bib63); Li et al., [2017](#bib.bib83);
    Filus et al., [2020](#bib.bib43)) |'
- en: '| General Models | DBN | 1 | 5(4) | (Wang et al., [2016](#bib.bib139)) |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 一般模型 | DBN | 1 | 5(4) | (Wang et al., [2016](#bib.bib139)) |'
- en: '|  | Auto Encoders | 1 |  | (Le et al., [2018](#bib.bib77)) |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '|  | 自编码器 | 1 |  | (Le et al., [2018](#bib.bib77))'
- en: '|  | Memory Neural Network | 1 |  | (Hoang et al., [2019](#bib.bib61)) |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  | 记忆神经网络 | 1 |  | (Hoang et al., [2019](#bib.bib61)) |'
- en: '|  | GAN | 1 |  | (Harer et al., [2018](#bib.bib56)) |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|  | GAN | 1 |  | (Harer et al., [2018](#bib.bib56)) |'
- en: '|  | Para2Vec | 1 |  | (Le et al., [2018](#bib.bib77)) |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|  | Para2Vec | 1 |  | (Le et al., [2018](#bib.bib77)) |'
- en: '| Transformers | Seq2Seq Transformer | 1 | 4(4) | (Chen et al., [2021](#bib.bib26))
    |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| Transformers | Seq2Seq Transformer | 1 | 4(4) | (Chen et al., [2021](#bib.bib26))
    |'
- en: '|  | Graph CodeBERT | 1 |  | (Wu et al., [2021](#bib.bib141)) |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '|  | 图代码BERT | 1 |  | (Wu et al., [2021](#bib.bib141)) |'
- en: '|  | CodeBERT | 1 |  | (Ni et al., [2022](#bib.bib111)) |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|  | CodeBERT | 1 |  | (Ni et al., [2022](#bib.bib111)) |'
- en: '|  | HGT | 1 |  | (Yang et al., [2022](#bib.bib147)) |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  | HGT | 1 |  | (Yang et al., [2022](#bib.bib147)) |'
- en: '| SUM | - | - | 71(49) | - |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 总计 | - | - | 71(49) | - |'
- en: Table 10. Distribution of ML and other models in primary studies.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 表10. 主要研究中机器学习和其他模型的分布。
- en: '| Category | Model Name | Studies | Total | References |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 模型名称 | 研究数量 | 总计 | 参考文献 |'
- en: '| Classic ML Models | Random Forest | 7 | 35(11) | (Chen et al., [2020b](#bib.bib25);
    Sabetta and Bezzi, [2018](#bib.bib124); Zhou and Sharma, [2017](#bib.bib156);
    Kronjee et al., [2018](#bib.bib73); Pascarella et al., [2019](#bib.bib114); Scandariato
    et al., [2014](#bib.bib125); Yang et al., [2017](#bib.bib148)) |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 经典机器学习模型 | 随机森林 | 7 | 35(11) | (Chen et al., [2020b](#bib.bib25); Sabetta
    and Bezzi, [2018](#bib.bib124); Zhou and Sharma, [2017](#bib.bib156); Kronjee
    et al., [2018](#bib.bib73); Pascarella et al., [2019](#bib.bib114); Scandariato
    et al., [2014](#bib.bib125); Yang et al., [2017](#bib.bib148)) |'
- en: '|  | SVM | 6 |  | (Chen et al., [2020b](#bib.bib25); Sabetta and Bezzi, [2018](#bib.bib124);
    Zhou and Sharma, [2017](#bib.bib156); Scandariato et al., [2014](#bib.bib125);
    Perl et al., [2015](#bib.bib115); Riom et al., [2021](#bib.bib121)) |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  | SVM | 6 |  | (Chen et al., [2020b](#bib.bib25); Sabetta and Bezzi, [2018](#bib.bib124);
    Zhou and Sharma, [2017](#bib.bib156); Scandariato et al., [2014](#bib.bib125);
    Perl et al., [2015](#bib.bib115); Riom et al., [2021](#bib.bib121)) |'
- en: '|  | Naive Bayes | 5 |  | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma,
    [2017](#bib.bib156); Kronjee et al., [2018](#bib.bib73); Pascarella et al., [2019](#bib.bib114);
    Scandariato et al., [2014](#bib.bib125)) |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|  | 朴素贝叶斯 | 5 |  | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156);
    Kronjee et al., [2018](#bib.bib73); Pascarella et al., [2019](#bib.bib114); Scandariato
    et al., [2014](#bib.bib125)) |'
- en: '|  | Logistic Regression | 4 |  | (Sabetta and Bezzi, [2018](#bib.bib124);
    Zhou and Sharma, [2017](#bib.bib156); Kronjee et al., [2018](#bib.bib73); Pascarella
    et al., [2019](#bib.bib114)) |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  | 逻辑回归 | 4 |  | (Sabetta and Bezzi, [2018](#bib.bib124); Zhou and Sharma,
    [2017](#bib.bib156); Kronjee et al., [2018](#bib.bib73); Pascarella et al., [2019](#bib.bib114))
    |'
- en: '|  | K-NN | 3 |  | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156);
    Scandariato et al., [2014](#bib.bib125)) |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|  | K-NN | 3 |  | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156);
    Scandariato et al., [2014](#bib.bib125)) |'
- en: '|  | Gradient Boosting | 2 |  | (Chen et al., [2020b](#bib.bib25); Zhou and
    Sharma, [2017](#bib.bib156)) |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|  | 梯度提升 | 2 |  | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma, [2017](#bib.bib156))
    |'
- en: '|  | Decision Tree | 2 |  | (Kronjee et al., [2018](#bib.bib73); Scandariato
    et al., [2014](#bib.bib125)) |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|  | 决策树 | 2 |  | (Kronjee et al., [2018](#bib.bib73); Scandariato et al.,
    [2014](#bib.bib125)) |'
- en: '|  | AdaBoost | 2 |  | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma,
    [2017](#bib.bib156)) |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|  | AdaBoost | 2 |  | (Chen et al., [2020b](#bib.bib25); Zhou and Sharma,
    [2017](#bib.bib156)) |'
- en: '|  | PCA | 1 |  | (Yamaguchi et al., [2011](#bib.bib144)) |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '|  | PCA | 1 |  | (Yamaguchi et al., [2011](#bib.bib144)) |'
- en: '|  | Kernel Machine | 1 |  | (Nguyen et al., [2020](#bib.bib110)) |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '|  | 核机器 | 1 |  | (Nguyen et al., [2020](#bib.bib110)) |'
- en: '|  | ADTree | 1 |  | (Pascarella et al., [2019](#bib.bib114)) |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|  | ADTree | 1 |  | (Pascarella et al., [2019](#bib.bib114)) |'
- en: '|  | MLP | 1 |  | (Pascarella et al., [2019](#bib.bib114)) |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '|  | MLP | 1 |  | (Pascarella 等, [2019](#bib.bib114)) |'
- en: '| Language Models | N-Gram | 1 | 1 | (Shippey et al., [2019](#bib.bib129))
    |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 语言模型 | N-Gram | 1 | 1 | (Shippey 等, [2019](#bib.bib129)) |'
- en: '| Distance Metrics | Distance Measure | 2 | 2 | (Yamaguchi et al., [2013](#bib.bib145);
    Huang et al., [2021](#bib.bib62)) |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 距离度量 | 距离测量 | 2 | 2 | (Yamaguchi 等, [2013](#bib.bib145); Huang 等, [2021](#bib.bib62))
    |'
- en: '| SUM | - | - | 38(14) | - |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| SUM | - | - | 38(14) | - |'
- en: <svg   height="213.52" overflow="visible" version="1.1" width="593.51"><g transform="translate(0,213.52)
    matrix(1 0 0 -1 0 0) translate(20.38,0) translate(0,172.43)"><g stroke="#000000"><g
    stroke-width="1.0pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 0 0)"><foreignobject width="552.76" height="161.74" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">(1) 79.1% of primary studies use DL models
    for vulnerability detection while merely 16.4% of the primary studies use classic
    ML models. (2) RNNs and GNNs are by far the most popular DL-based models in software
    vulnerability detection accounting for 28% and 22% of primary studies. (3) LSTM
    is the most popular architecture in RNN-based models. (4) Graph-based models are
    the second most popular models used in software security vulnerability detection
    accounting for 15 studies. In this family, GGNN is the most popular architecture.
    (5) Besides DL models, ML models are popular for software vulnerability detection.
    Random Forest is the most popular model accounting for 7 studies. <g stroke-width="0.5pt"
    fill="#FF9999"><path d="M 97.05 40.75 L 5.19 40.75 C 2.13 40.75 -0.35 38.27 -0.35
    35.21 L -0.35 24.91 C -0.35 21.86 2.13 19.38 5.19 19.38 L 97.05 19.38 C 100.11
    19.38 102.59 21.86 102.59 24.91 L 102.59 35.21 C 102.59 38.27 100.11 40.75 97.05
    40.75 Z M -0.35 19.38"></path></g><g stroke-width="0.5pt" fill="#000000" stroke="#000000"
    transform="matrix(1.0 0.0 0.0 1.0 4.27 26.68)"><foreignobject width="94.09" height="12.15"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Answer to RQ3</foreignobject></g>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: <svg height="213.52" overflow="visible" version="1.1" width="593.51"><g transform="translate(0,213.52)
    matrix(1 0 0 -1 0 0) translate(20.38,0) translate(0,172.43)"><g stroke="#000000"><g
    stroke-width="1.0pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 0 0)"><foreignobject width="552.76" height="161.74" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">(1) 79.1% 的主要研究使用 DL 模型进行脆弱性检测，而仅有 16.4% 的主要研究使用经典
    ML 模型。(2) RNN 和 GNN 目前是软件脆弱性检测中最受欢迎的基于 DL 的模型，分别占主要研究的 28% 和 22%。(3) LSTM 是 RNN
    基于模型中最受欢迎的架构。(4) 基于图的模型是软件安全脆弱性检测中第二受欢迎的模型，共占 15 个研究。在这一领域中，GGNN 是最受欢迎的架构。(5)
    除了 DL 模型外，ML 模型在软件脆弱性检测中也很受欢迎。随机森林是最受欢迎的模型，占 7 个研究。<g stroke-width="0.5pt" fill="#FF9999"><path
    d="M 97.05 40.75 L 5.19 40.75 C 2.13 40.75 -0.35 38.27 -0.35 35.21 L -0.35 24.91
    C -0.35 21.86 2.13 19.38 5.19 19.38 L 97.05 19.38 C 100.11 19.38 102.59 21.86
    102.59 24.91 L 102.59 35.21 C 102.59 38.27 100.11 40.75 97.05 40.75 Z M -0.35
    19.38"></path></g><g stroke-width="0.5pt" fill="#000000" stroke="#000000" transform="matrix(1.0
    0.0 0.0 1.0 4.27 26.68)"><foreignobject width="94.09" height="12.15" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">回答 RQ3</foreignobject></g>
- en: 4.4\. RQ4\. What is the most frequent type of vulnerability covered in primary
    studies?
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4. RQ4. 在主要研究中，最常见的脆弱性类型是什么？
- en: Software vulnerability detection datasets support different vulnerability types.
    For example, NVD and SARD benchmark together support 96 types of vulnerabilities.
    This research question intends to summarize what is the most popular vulnerability
    types covered by primary studies and what is their frequency. Table [11](#S4.T11
    "Table 11 ‣ 4.4\. RQ4\. What is the most frequent type of vulnerability covered
    in primary studies? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning") shows the statistics regarding
    the vulnerability types. The column CWE-Type indicates the type of CWE⁴⁴4[https://cwe.mitre.org/](https://cwe.mitre.org/).
    There also exists a numerical score for some types of CWEs, which indicate the
    weakness’ severity. A larger value indicates a higher level of dangerousness and
    severity⁵⁵5[https://cwe.mitre.org/top25/archive/2021/2021_cwe_top25.html](https://cwe.mitre.org/top25/archive/2021/2021_cwe_top25.html).
    Please note that some frequent types do not have a CWE score, so we denote them
    as “-”. There are many categories on the CWE website for vulnerability categorization
    including categorization by software development, categorization by Hardware design,
    and categorization by research concepts. The categorization shown in Table [11](#S4.T11
    "Table 11 ‣ 4.4\. RQ4\. What is the most frequent type of vulnerability covered
    in primary studies? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning") is based on categorization
    by research concepts as this categorization is a perfect match for vulnerability
    types reported in primary studies.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 软件漏洞检测数据集支持不同类型的漏洞。例如，NVD 和 SARD 基准测试一起支持 96 种漏洞类型。本研究问题旨在总结主要研究中覆盖的最常见漏洞类型及其频率。表格[11](#S4.T11
    "Table 11 ‣ 4.4\. RQ4\. What is the most frequent type of vulnerability covered
    in primary studies? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning")显示了有关漏洞类型的统计数据。列CWE-Type表示CWE的类型⁴⁴4[https://cwe.mitre.org/](https://cwe.mitre.org/)。一些类型的CWE还存在数值评分，表示漏洞的严重性。较大的值表示更高的危险性和严重性⁵⁵5[https://cwe.mitre.org/top25/archive/2021/2021_cwe_top25.html](https://cwe.mitre.org/top25/archive/2021/2021_cwe_top25.html)。请注意，一些常见类型没有CWE评分，因此我们用“-”表示。CWE网站上有许多漏洞分类类别，包括按软件开发分类、按硬件设计分类和按研究概念分类。表[11](#S4.T11
    "Table 11 ‣ 4.4\. RQ4\. What is the most frequent type of vulnerability covered
    in primary studies? ‣ 4\. Results ‣ A Survey on Automated Software Vulnerability
    Detection Using Machine Learning and Deep Learning")中的分类基于研究概念分类，因为这种分类与主要研究中报告的漏洞类型完美匹配。
- en: Table [11](#S4.T11 "Table 11 ‣ 4.4\. RQ4\. What is the most frequent type of
    vulnerability covered in primary studies? ‣ 4\. Results ‣ A Survey on Automated
    Software Vulnerability Detection Using Machine Learning and Deep Learning") indicates
    that the vulnerability category that receives the highest attendance is related
    to the improper control of a resource through its lifetime (CWE-664), with a total
    of 42 studies (18 unique studies). This category primarily involves managing a
    system’s resources, which are created, utilized, and disposed of according to
    a predefined set of instructions. When a software system fails to follow these
    guidelines for resource usage, it can lead to unexpected behaviors that create
    potentially hazardous situations. Attackers can take advantage of these situations
    to exploit the software system for their own purposes. It is observable that CWE-119
    (Russell et al., [2018](#bib.bib123); Liu et al., [2020](#bib.bib96); Nguyen et al.,
    [2020](#bib.bib110); Cheng et al., [2021](#bib.bib29); Yan et al., [2021](#bib.bib146);
    Fu and Tantithamthavorn, [2022](#bib.bib46); Le et al., [2018](#bib.bib77); Cao
    et al., [2022](#bib.bib18); Chen et al., [2021](#bib.bib26); Lin et al., [2019](#bib.bib91);
    Filus et al., [2020](#bib.bib43); Li et al., [2018](#bib.bib89); Duan et al.,
    [2019](#bib.bib39); Wang et al., [2020](#bib.bib137)) is the most frequent vulnerability
    type addressed by the primary studies. This vulnerability occurs when a software
    system attempts to access or write to a memory location outside the permitted
    boundary of the system’s buffer. Attackers can exploit this vulnerability by controlling
    memory locations and executing their own code or commands, effectively manipulating
    the system’s memory. Although the score for this vulnerability type is not high,
    the frequency of primary studies addressing it can be a valuable indicator of
    its significance in terms of detecting and addressing the vulnerability. Within
    this category, the most severe vulnerability type with a score of 65.93 is CWE-787,
    which is discussed in 5 primary studies. This vulnerability is considered severe
    and critical because it can result in the corruption of data, system crashes,
    or the execution of malicious code. It occurs when a software system attempts
    to write data beyond the intended buffer, either before the beginning or past
    the end of the buffer. CWE-22 is another frequent vulnerability type addressed
    by primary studies accounting for 4 primary studies (Fu and Tantithamthavorn,
    [2022](#bib.bib46); Ghaffarian and Shahriari, [2021](#bib.bib50); Cheng et al.,
    [2021](#bib.bib29); Cao et al., [2022](#bib.bib18)). This vulnerability is referred
    to as “Path Traversal”, where attackers exploit special elements, such as “..”
    or “/”, to construct their own path and gain unauthorized access to restricted
    locations. This vulnerability is particularly critical because attackers can use
    it to modify restricted files or directories in vulnerable software systems, potentially
    leading to system crashes by uploading malicious code or commands. In critical
    financial software systems, attackers can even gain access to customers’ bank
    account information. Given the severity of this vulnerability type with a score
    of 14.69 and the frequency of papers covering it, detecting and addressing this
    vulnerability is of utmost importance. Therefore, more advanced ML/DL models are
    needed to effectively detect this type of vulnerability. The least frequent vulnerability
    type of this family is CWE-120 (Russell et al., [2018](#bib.bib123); Cao et al.,
    [2022](#bib.bib18)) which is a classic buffer overflow, accounting for 2 primary
    studies. This vulnerability occurs when the software attempts to copy a value
    to the output buffer without first validating its size. If the range of the value
    is too large for the length of the output buffer, a buffer overflow can occur.
    While the detection of buffer overflow can be challenging in some cases, static
    bug detection tools have already addressed this vulnerability, and detection methods
    are currently available.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 表[11](#S4.T11 "表 11 ‣ 4.4\. RQ4\. 最常见的漏洞类型是什么？ ‣ 4\. 结果 ‣ 一项关于使用机器学习和深度学习的自动化软件漏洞检测的调查")表明，获得最高关注的漏洞类别与资源生命周期中的不当控制（CWE-664）相关，总共有42项研究（18项独立研究）。这一类别主要涉及系统资源的管理，这些资源根据预定义的指令集进行创建、使用和处置。当软件系统未能遵循这些资源使用指南时，可能会导致意外行为，从而产生潜在的危险情况。攻击者可以利用这些情况来为自己的目的利用软件系统。可以观察到，CWE-119（Russell等，[2018](#bib.bib123)；Liu等，[2020](#bib.bib96)；Nguyen等，[2020](#bib.bib110)；Cheng等，[2021](#bib.bib29)；Yan等，[2021](#bib.bib146)；Fu和Tantithamthavorn，[2022](#bib.bib46)；Le等，[2018](#bib.bib77)；Cao等，[2022](#bib.bib18)；Chen等，[2021](#bib.bib26)；Lin等，[2019](#bib.bib91)；Filus等，[2020](#bib.bib43)；Li等，[2018](#bib.bib89)；Duan等，[2019](#bib.bib39)；Wang等，[2020](#bib.bib137)）是主要研究中处理的最常见漏洞类型。这种漏洞发生在软件系统尝试访问或写入超出系统缓冲区允许边界的内存位置时。攻击者可以通过控制内存位置并执行自己的代码或命令，从而有效地操控系统内存。尽管这种漏洞类型的得分不高，但主要研究的频率可以作为检测和解决此漏洞的重要指标。在此类别中，得分最高的严重漏洞类型是CWE-787，在5项主要研究中进行了讨论。这种漏洞被认为是严重和关键的，因为它可能导致数据损坏、系统崩溃或恶意代码执行。它发生在软件系统尝试在缓冲区之前或之后写入数据时。CWE-22是另一个频繁被主要研究讨论的漏洞类型，涉及4项主要研究（Fu和Tantithamthavorn，[2022](#bib.bib46)；Ghaffarian和Shahriari，[2021](#bib.bib50)；Cheng等，[2021](#bib.bib29)；Cao等，[2022](#bib.bib18)）。这种漏洞被称为“路径遍历”，攻击者利用特殊元素，如“..”或“/”，来构造自己的路径并获得对受限位置的未经授权的访问。此漏洞特别关键，因为攻击者可以利用它来修改受限的文件或目录，可能导致通过上传恶意代码或命令使系统崩溃。在关键的金融软件系统中，攻击者甚至可以访问客户的银行账户信息。鉴于这种漏洞类型的严重性（得分为14.69）以及涉及该漏洞的论文频率，检测和解决此漏洞至关重要。因此，需要更先进的ML/DL模型来有效检测这种类型的漏洞。此类别中最少见的漏洞类型是CWE-120（Russell等，[2018](#bib.bib123)；Cao等，[2022](#bib.bib18)），这是经典的缓冲区溢出，涉及2项主要研究。这种漏洞发生在软件尝试将值复制到输出缓冲区而未首先验证其大小时。如果值的范围超出了输出缓冲区的长度，就会发生缓冲区溢出。虽然在某些情况下检测缓冲区溢出可能具有挑战性，但静态漏洞检测工具已经解决了这个漏洞，并且目前已有检测方法可用。
- en: Table 11. Different vulnerability types covered in primary studies.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 表11. 初级研究中涵盖的不同漏洞类型。
- en: '| Category | CWE-Type | Severity Score | #Studies | Total | References |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | CWE 类型 | 严重性评分 | 研究数量 | 总计 | 参考文献 |'
- en: '| CWE-664 | CWE-119 | 5.84 | 14 | 42(18) | (Russell et al., [2018](#bib.bib123);
    Liu et al., [2020](#bib.bib96); Nguyen et al., [2020](#bib.bib110); Cheng et al.,
    [2021](#bib.bib29); Yan et al., [2021](#bib.bib146); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Le et al., [2018](#bib.bib77); Cao et al., [2022](#bib.bib18);
    Chen et al., [2021](#bib.bib26); Lin et al., [2019](#bib.bib91); Filus et al.,
    [2020](#bib.bib43); Li et al., [2018](#bib.bib89); Duan et al., [2019](#bib.bib39);
    Wang et al., [2020](#bib.bib137)) |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| CWE-664 | CWE-119 | 5.84 | 14 | 42(18) | (Russell et al., [2018](#bib.bib123);
    Liu et al., [2020](#bib.bib96); Nguyen et al., [2020](#bib.bib110); Cheng et al.,
    [2021](#bib.bib29); Yan et al., [2021](#bib.bib146); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Le et al., [2018](#bib.bib77); Cao et al., [2022](#bib.bib18);
    Chen et al., [2021](#bib.bib26); Lin et al., [2019](#bib.bib91); Filus et al.,
    [2020](#bib.bib43); Li et al., [2018](#bib.bib89); Duan et al., [2019](#bib.bib39);
    Wang et al., [2020](#bib.bib137)) |'
- en: '|  | CWE-787 | 65.93 | 5 |  | (Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Fu and Tantithamthavorn, [2022](#bib.bib46); Cao et al., [2022](#bib.bib18);
    Yang et al., [2022](#bib.bib147)) |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-787 | 65.93 | 5 |  | (Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Fu and Tantithamthavorn, [2022](#bib.bib46); Cao et al., [2022](#bib.bib18);
    Yang et al., [2022](#bib.bib147)) |'
- en: '|  | CWE-22 | 14.69 | 4 |  | (Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Fu and Tantithamthavorn, [2022](#bib.bib46); Ghaffarian and
    Shahriari, [2021](#bib.bib50)) |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-22 | 14.69 | 4 |  | (Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Fu and Tantithamthavorn, [2022](#bib.bib46); Ghaffarian and
    Shahriari, [2021](#bib.bib50)) |'
- en: '|  | CWE-125 | 24.9 | 4 |  | (Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Cao et al., [2022](#bib.bib18); Chen et al., [2021](#bib.bib26))
    |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-125 | 24.9 | 4 |  | (Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Cao et al., [2022](#bib.bib18); Chen et al., [2021](#bib.bib26))
    |'
- en: '|  | CWE-400 | - | 4 |  | (Wang et al., [2020](#bib.bib137); Zou et al., [2019](#bib.bib161);
    Cheng et al., [2021](#bib.bib29); Yang et al., [2022](#bib.bib147)) |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-400 | - | 4 |  | (Wang et al., [2020](#bib.bib137); Zou et al., [2019](#bib.bib161);
    Cheng et al., [2021](#bib.bib29); Yang et al., [2022](#bib.bib147)) |'
- en: '|  | CWE-200 | 4.74 | 3 |  | (Wang et al., [2020](#bib.bib137); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Chen et al., [2021](#bib.bib26)) |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-200 | 4.74 | 3 |  | (Wang et al., [2020](#bib.bib137); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Chen et al., [2021](#bib.bib26)) |'
- en: '|  | CWE-121 | - | 3 |  | (Russell et al., [2018](#bib.bib123); Yan et al.,
    [2021](#bib.bib146); Cao et al., [2022](#bib.bib18)) |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-121 | - | 3 |  | (Russell et al., [2018](#bib.bib123); Yan et al.,
    [2021](#bib.bib146); Cao et al., [2022](#bib.bib18)) |'
- en: '|  | CWE-122 | - | 3 |  | (Choi et al., [2017](#bib.bib32); Cao et al., [2022](#bib.bib18);
    Russell et al., [2018](#bib.bib123)) |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-122 | - | 3 |  | (Choi et al., [2017](#bib.bib32); Cao et al., [2022](#bib.bib18);
    Russell et al., [2018](#bib.bib123)) |'
- en: '|  | CWE-120 | - | 2 |  | (Russell et al., [2018](#bib.bib123); Cao et al.,
    [2022](#bib.bib18)) |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-120 | - | 2 |  | (Russell et al., [2018](#bib.bib123); Cao et al.,
    [2022](#bib.bib18)) |'
- en: '| CWE-707 | CWE-20 | 20.47 | 6 | 16(9) | (Russell et al., [2018](#bib.bib123);
    Wang et al., [2020](#bib.bib137); Cheng et al., [2021](#bib.bib29); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Chen et al., [2021](#bib.bib26); Yang et al., [2022](#bib.bib147))
    |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| CWE-707 | CWE-20 | 20.47 | 6 | 16(9) | (Russell et al., [2018](#bib.bib123);
    Wang et al., [2020](#bib.bib137); Cheng et al., [2021](#bib.bib29); Fu and Tantithamthavorn,
    [2022](#bib.bib46); Chen et al., [2021](#bib.bib26); Yang et al., [2022](#bib.bib147))
    |'
- en: '|  | CWE-78 | 19.55 | 5 |  | (Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Ghaffarian and Shahriari, [2021](#bib.bib50); Li et al., [2021b](#bib.bib87);
    Yang et al., [2022](#bib.bib147)) |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-78 | 19.55 | 5 |  | (Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Ghaffarian and Shahriari, [2021](#bib.bib50); Li et al., [2021b](#bib.bib87);
    Yang et al., [2022](#bib.bib147)) |'
- en: '|  | CWE-89 | 19.54 | 3 |  | (Ghaffarian and Shahriari, [2021](#bib.bib50);
    Kronjee et al., [2018](#bib.bib73); Wang et al., [2020](#bib.bib137)) |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-89 | 19.54 | 3 |  | (Ghaffarian and Shahriari, [2021](#bib.bib50);
    Kronjee et al., [2018](#bib.bib73); Wang et al., [2020](#bib.bib137)) |'
- en: '|  | CWE-79 | 46.84 | 2 |  | (Kronjee et al., [2018](#bib.bib73); Wang et al.,
    [2020](#bib.bib137)) |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '|  | CWE-79 | 46.84 | 2 |  | (Kronjee et al., [2018](#bib.bib73); Wang et al.,
    [2020](#bib.bib137)) |'
- en: '| CWE-682 | CWE-190 | 7.12 | 5 | 5 | (Wang et al., [2020](#bib.bib137); Cheng
    et al., [2021](#bib.bib29); Fu and Tantithamthavorn, [2022](#bib.bib46); Zou et al.,
    [2019](#bib.bib161); Yang et al., [2022](#bib.bib147)) |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| CWE-682 | CWE-190 | 7.12 | 5 | 5 | (Wang et al., [2020](#bib.bib137); Cheng
    et al., [2021](#bib.bib29); Fu and Tantithamthavorn, [2022](#bib.bib46); Zou et
    al., [2019](#bib.bib161); Yang et al., [2022](#bib.bib147)) |'
- en: '| CWE-703 | CWE-476 | 6.54 | 4 | 4 | (Russell et al., [2018](#bib.bib123);
    Wang et al., [2020](#bib.bib137); Cao et al., [2022](#bib.bib18); Chen et al.,
    [2021](#bib.bib26)) |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| CWE-703 | CWE-476 | 6.54 | 4 | 4 | (拉塞尔等， [2018](#bib.bib123); 王等， [2020](#bib.bib137);
    曹等， [2022](#bib.bib18); 陈等， [2021](#bib.bib26)) |'
- en: '| CWE-284 | CWE-284 | - | 2 | 2 | (Aivatoglou et al., [2021](#bib.bib4); Chen
    et al., [2021](#bib.bib26)) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| CWE-284 | CWE-284 | - | 2 | 2 | (Aivatoglou等， [2021](#bib.bib4); 陈等， [2021](#bib.bib26))
    |'
- en: '| CWE-691 | CWE-362 | - | 2 | 2 | (Chen et al., [2021](#bib.bib26); Zou et al.,
    [2019](#bib.bib161)) |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| CWE-691 | CWE-362 | - | 2 | 2 | (陈等， [2021](#bib.bib26); 邹等， [2019](#bib.bib161))
    |'
- en: '| CWE-1215 | CWE-129 | - | 1 | 1 | (Yang et al., [2022](#bib.bib147)) |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| CWE-1215 | CWE-129 | - | 1 | 1 | (杨等， [2022](#bib.bib147)) |'
- en: '| - | CWE-789 | - | 1 | 1 | (Yang et al., [2022](#bib.bib147)) |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| - | CWE-789 | - | 1 | 1 | (杨等， [2022](#bib.bib147)) |'
- en: '| SUM | - | - | - | 73(21) | - |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 总计 | - | - | - | 73(21) | - |'
- en: Improper Neutralization - (CWE-707) Is the second major family of vulnerability
    types covered by 16 primary studies, including 9 unique primary studies. In this
    type, the attackers exploit input and output data when they are malformed or not
    validated properly. There are several scenarios that can lead to data neutralization
    weaknesses. The first scenario involves checking whether input and output data
    are safe, while the second scenario involves filtering the input and output data
    to ensure that any data transformation is done safely. The third scenario involves
    preventing external attackers from directly manipulating the input and output
    data, while the fourth scenario relates to the lack of processing input and output
    data in any circumstances. All of these scenarios can be the root causes of data
    neutralization weaknesses. As can be seen, CWE-20 is the most frequent type of
    vulnerability accounting for 6 primary studies. CWE-20 refers to a situation where
    input validation is not done properly in software systems, making them vulnerable
    to attacks by malicious individuals who can exploit input data. This occurs when
    the input data is not verified to be safe or in line with the predefined specifications.
    The severity and occurrence of this issue are significant, highlighting the need
    for its detection as it can pose critical risks. CWE-78 is the second major vulnerability
    type covered by 5 primary studies (Wang et al., [2020](#bib.bib137); Cheng et al.,
    [2021](#bib.bib29); Ghaffarian and Shahriari, [2021](#bib.bib50); Li et al., [2021b](#bib.bib87);
    Yang et al., [2022](#bib.bib147)). This category of security vulnerability pertains
    to OS command injection, in which an external attacker can construct an OS command
    by using input data from components that have not been adequately verified. The
    attacker can then execute harmful commands, potentially causing the system to
    behave unexpectedly or crash, and putting it in a hazardous state.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 不当中和 - (CWE-707) 是由16项主要研究涵盖的第二大漏洞类型，包括9项独特的主要研究。在这种类型中，攻击者利用输入和输出数据，当这些数据格式错误或未经适当验证时。可能导致数据中和漏洞的场景有几个。第一个场景涉及检查输入和输出数据是否安全，而第二个场景涉及过滤输入和输出数据，以确保任何数据转换都安全进行。第三个场景涉及防止外部攻击者直接操纵输入和输出数据，而第四个场景与在任何情况下都不处理输入和输出数据相关。这些场景都可能是数据中和漏洞的根本原因。如图所示，CWE-20
    是最常见的漏洞类型，占据了6项主要研究。CWE-20 指的是软件系统中输入验证不充分的情况，使其易受到恶意个体的攻击，这些攻击者可以利用输入数据。这种情况发生在输入数据未经过验证是否安全或与预定义规范一致时。此问题的严重性和发生频率都很高，强调了其检测的必要性，因为它可能带来关键风险。CWE-78
    是第二大漏洞类型，由5项主要研究涵盖（王等， [2020](#bib.bib137); 程等， [2021](#bib.bib29); Ghaffarian
    和 Shahriari，[2021](#bib.bib50); 李等，[2021b](#bib.bib87); 杨等， [2022](#bib.bib147)）。此类别的安全漏洞涉及操作系统命令注入，其中外部攻击者可以利用未经充分验证的组件的输入数据构造操作系统命令。攻击者可以执行有害命令，可能导致系统行为异常或崩溃，使其处于危险状态。
- en: '<svg   height="261.95" overflow="visible" version="1.1" width="593.51"><g transform="translate(0,261.95)
    matrix(1 0 0 -1 0 0) translate(20.38,0) translate(0,220.86)"><g stroke="#000000"><g
    stroke-width="1.0pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 0 0)"><foreignobject width="552.76" height="210.17" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">(1) The most frequent type of vulnerabilities
    covered in primary studies is Improper Control of a Resource Through its Lifetime-(CWE-664)
    accounting for 18 unique primary studies. CWE-119: Improper Restriction of Operations
    within the Bounds of a Memory Buffer is the most frequent type of vulnerability
    in this category accounting for 14 primary studies, and CWE-787: Out-of-bounds
    Write comes subsequently covered by 5 primary studies. The least frequent type
    of vulnerability is CWE-120 covered by 2 studies. (2) Improper Neutralization(CWE-707)
    is the second major family of vulnerability types covered by 9 unique primary
    studies in total. In this family, CWE-20: Improper Input Validation is the most
    frequent type covered by 6 primary studies, and CWE-78: Improper Neutralization
    of Special Elements used in an OS Command (‘OS Command Injection’) comes next
    with 5 primary studies. (3) Some vulnerability types have a high CVSS score while
    not sufficiently addressed by existing vulnerability detection studies including
    but not limited to CWE-79 and CWE-89. <g stroke-width="0.5pt" fill="#FF9999"><path
    d="M 97.05 40.75 L 5.19 40.75 C 2.13 40.75 -0.35 38.27 -0.35 35.21 L -0.35 24.91
    C -0.35 21.86 2.13 19.38 5.19 19.38 L 97.05 19.38 C 100.11 19.38 102.59 21.86
    102.59 24.91 L 102.59 35.21 C 102.59 38.27 100.11 40.75 97.05 40.75 Z M -0.35
    19.38"></path></g><g stroke-width="0.5pt" fill="#000000" stroke="#000000" transform="matrix(1.0
    0.0 0.0 1.0 4.27 26.68)"><foreignobject width="94.09" height="12.15" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">Answer to RQ4</foreignobject></g>'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '(1) 在主要研究中，最常见的漏洞类型是资源生命周期不当控制（CWE-664），占据了18项独特的主要研究。CWE-119: 内存缓冲区边界内操作的不当限制是该类别中最常见的漏洞类型，占据了14项主要研究，其次是CWE-787:
    越界写入，由5项主要研究涵盖。最少见的漏洞类型是CWE-120，仅被2项研究涉及。(2) 不当中和（CWE-707）是第二大漏洞类型类别，总共涵盖了9项独特的主要研究。在这个类别中，CWE-20:
    不当输入验证是最常见的类型，由6项主要研究覆盖，其次是CWE-78: 不当中和操作系统命令中使用的特殊元素（‘OS命令注入’），由5项主要研究涉及。(3)
    一些漏洞类型具有较高的CVSS评分，但现有的漏洞检测研究未能充分解决，包括但不限于CWE-79和CWE-89。'
- en: 4.5\. RQ5\. What are possible challenges and open directions in software vulnerability
    detection?
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. RQ5\. 软件漏洞检测中可能面临的挑战和开放方向是什么？
- en: We have summarized the challenges from previous studies into five different
    categories, which are discussed as follows.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前研究中的挑战总结为五个不同的类别，具体讨论如下。
- en: 'Challenge 1: Semantic Representation. The biggest challenge in vulnerability
    detection through learning is the inadequate modeling of the comprehensive semantics
    of complex vulnerabilities by current models (Dam et al., [2018](#bib.bib34),
    [2017](#bib.bib33); Shippey et al., [2019](#bib.bib129); Wang et al., [2016](#bib.bib139);
    Jeon and Kim, [2021](#bib.bib65); Phan et al., [2017](#bib.bib117); Hoang et al.,
    [2019](#bib.bib61); Cheng et al., [2021](#bib.bib29); Zhou et al., [2019](#bib.bib155);
    Wu et al., [2021](#bib.bib141); Li et al., [2017](#bib.bib83), [2021c](#bib.bib88),
    [2021b](#bib.bib87); Duan et al., [2019](#bib.bib39); Zheng et al., [2021](#bib.bib154);
    Zhuang et al., [2022](#bib.bib157); Cheng et al., [2022](#bib.bib31); Liu et al.,
    [2021b](#bib.bib98); Yang et al., [2022](#bib.bib147); Nguyen et al., [2022b](#bib.bib109),
    [a](#bib.bib108)). These vulnerabilities often exhibit intricate characteristics
    and patterns that are not fully captured by existing ML/DL models that treat source
    code snippets as a linear sequence like natural language, or only partially represent
    source code snippets. Unlike natural language, the source code of real-world projects
    contains structural and logical information that must be considered by ML/DL models
    using AST, data flow, and control flow. Therefore, current ML/DL approaches fall
    short of identifying complex vulnerability patterns.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战1：语义表示。通过学习进行漏洞检测的最大挑战是当前模型对复杂漏洞的全面语义建模不足（Dam 等，[2018](#bib.bib34)，[2017](#bib.bib33)；Shippey
    等，[2019](#bib.bib129)；Wang 等，[2016](#bib.bib139)；Jeon 和 Kim，[2021](#bib.bib65)；Phan
    等，[2017](#bib.bib117)；Hoang 等，[2019](#bib.bib61)；Cheng 等，[2021](#bib.bib29)；Zhou
    等，[2019](#bib.bib155)；Wu 等，[2021](#bib.bib141)；Li 等，[2017](#bib.bib83)，[2021c](#bib.bib88)，[2021b](#bib.bib87)；Duan
    等，[2019](#bib.bib39)；Zheng 等，[2021](#bib.bib154)；Zhuang 等，[2022](#bib.bib157)；Cheng
    等，[2022](#bib.bib31)；Liu 等，[2021b](#bib.bib98)；Yang 等，[2022](#bib.bib147)；Nguyen
    等，[2022b](#bib.bib109)，[a](#bib.bib108)）。这些漏洞通常具有复杂的特征和模式，而现有的 ML/DL 模型无法完全捕捉这些特征，因为它们将源代码片段视为类似自然语言的线性序列，或仅部分表示源代码片段。与自然语言不同，现实世界项目的源代码包含结构性和逻辑性信息，ML/DL
    模型必须使用 AST、数据流和控制流来考虑这些信息。因此，当前的 ML/DL 方法在识别复杂漏洞模式方面存在不足。
- en: 'Challenge 2: Prediction Granularity. The ability of DL models to identify the
    location of vulnerabilities is influenced by the level of granularity in their
    inputs. Current DL models use a coarser level of granularity, such as method and
    file, for vulnerability detection. To achieve finer-grained inputs, program slicing
    is necessary, but it poses a challenge. The crucial question is how to perform
    program slicing effectively to eliminate unwanted noise in input data and provide
    more specific inputs. Current tools (Pascarella et al., [2019](#bib.bib114); Dinella
    et al., [2020](#bib.bib36); Fu and Tantithamthavorn, [2022](#bib.bib46); Zou et al.,
    [2019](#bib.bib161); Cao et al., [2022](#bib.bib18); Lin et al., [2017](#bib.bib92);
    Li et al., [2021a](#bib.bib85); Ding et al., [2022](#bib.bib37); Zou et al., [2022](#bib.bib160))
    concentrate on library/API function calls, arithmetic operations, and pointer
    usages, but this approach is not sufficient since not all vulnerabilities originate
    from these slicing criteria.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战2：预测粒度。DL 模型识别漏洞位置的能力受到其输入粒度水平的影响。当前 DL 模型使用较粗的粒度级别，如方法和文件来进行漏洞检测。为了实现更精细的输入，需要程序切片，但这也带来了挑战。关键问题是如何有效地进行程序切片，以消除输入数据中的噪声并提供更具体的输入。当前工具（Pascarella
    等，[2019](#bib.bib114)；Dinella 等，[2020](#bib.bib36)；Fu 和 Tantithamthavorn，[2022](#bib.bib46)；Zou
    等，[2019](#bib.bib161)；Cao 等，[2022](#bib.bib18)；Lin 等，[2017](#bib.bib92)；Li 等，[2021a](#bib.bib85)；Ding
    等，[2022](#bib.bib37)；Zou 等，[2022](#bib.bib160)）集中于库/API 函数调用、算术操作和指针使用，但这种方法并不充分，因为并非所有漏洞都源自这些切片标准。
- en: 'Challenge 3: False Positive Removal. The most commonly used tools for detecting
    software vulnerabilities and bugs are static analyzers (Zhou and Sharma, [2017](#bib.bib156);
    Kronjee et al., [2018](#bib.bib73); Zeng et al., [2021](#bib.bib151); Li et al.,
    [2019](#bib.bib86); Harer et al., [2018](#bib.bib56); Ziems and Wu, [2021](#bib.bib159);
    Zou et al., [2019](#bib.bib161)). These tools utilize hard-coded rules that are
    defined by experts to model the runtime behavior of a program without the need
    for compilation. This approach has several benefits, such as effectively identifying
    the location of vulnerabilities in source codes, which is challenging in large-scale
    projects with thousands of files and artifacts. Additionally, static analyzers
    are used at the early stage of the software development process, which helps reduce
    software maintenance costs. However, relying on expert-defined rules comes with
    a high false-positive rate, as these rules may not be generalizable to new vulnerabilities
    that have intricate and sophisticated program semantics. Another significant issue
    is that defining and updating rules is a labor-intensive and time-consuming process
    that requires experts to have in-depth knowledge of emerging vulnerabilities.
    That is why data-driven vulnerability detection has emerged to overcome the aforementioned
    challenges (Zhou and Sharma, [2017](#bib.bib156); Kronjee et al., [2018](#bib.bib73);
    Zeng et al., [2021](#bib.bib151); Li et al., [2019](#bib.bib86); Harer et al.,
    [2018](#bib.bib56); Ziems and Wu, [2021](#bib.bib159); Zou et al., [2019](#bib.bib161)).'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 3：假阳性移除。用于检测软件漏洞和错误的最常用工具是静态分析器（Zhou and Sharma, [2017](#bib.bib156); Kronjee
    et al., [2018](#bib.bib73); Zeng et al., [2021](#bib.bib151); Li et al., [2019](#bib.bib86);
    Harer et al., [2018](#bib.bib56); Ziems and Wu, [2021](#bib.bib159); Zou et al.,
    [2019](#bib.bib161)）。这些工具利用专家定义的硬编码规则来模拟程序的运行时行为，而无需编译。这种方法有几个优点，比如能够有效地识别源代码中的漏洞位置，这在具有数千个文件和工件的大型项目中具有挑战性。此外，静态分析器在软件开发过程的早期阶段使用，这有助于减少软件维护成本。然而，依赖于专家定义的规则会带来较高的假阳性率，因为这些规则可能无法推广到具有复杂和精细程序语义的新漏洞。另一个显著问题是定义和更新规则是一个劳动密集且耗时的过程，需要专家对新兴漏洞有深入的了解。这就是为什么数据驱动的漏洞检测应运而生，以克服上述挑战（Zhou
    and Sharma, [2017](#bib.bib156); Kronjee et al., [2018](#bib.bib73); Zeng et al.,
    [2021](#bib.bib151); Li et al., [2019](#bib.bib86); Harer et al., [2018](#bib.bib56);
    Ziems and Wu, [2021](#bib.bib159); Zou et al., [2019](#bib.bib161)）。
- en: 'Challenge 4: Lack of Training Data. A significant weakness of DL models, particularly
    in software vulnerability detection, is their insatiable need for data (Chen et al.,
    [2020b](#bib.bib25); Liu et al., [2020](#bib.bib96); Lin et al., [2019](#bib.bib91);
    Yang et al., [2017](#bib.bib148); Ni et al., [2022](#bib.bib111)). In domains
    such as image classification, there is an ample supply of labeled data, making
    it possible to train DL models effectively. Furthermore, there are many pre-trained
    models available that can be fine-tuned for detection tasks. However, in software
    vulnerability detection, data scarcity is a major problem since labeling ground
    truth information is a challenging task. To obtain training data, multiple online
    platforms such as Stack Overflow, GitHub, and issue tracking or bug tracking systems
    are used. While these platforms contain billions of records, the labeling process
    is difficult and is often done manually. One possible solution is the automatic
    labeling of data, but this approach is challenging as it often generates many
    false positives. Additionally, some researchers use unsupervised classification
    for vulnerability detection, but this method also suffers from limited precision.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 4：缺乏训练数据。深度学习模型，特别是在软件漏洞检测中的一个显著弱点是它们对数据的**贪婪需求**（Chen et al., [2020b](#bib.bib25);
    Liu et al., [2020](#bib.bib96); Lin et al., [2019](#bib.bib91); Yang et al., [2017](#bib.bib148);
    Ni et al., [2022](#bib.bib111)）。在如图像分类等领域，标记数据供应充足，使得深度学习模型的有效训练成为可能。此外，许多预训练模型可以为检测任务进行微调。然而，在软件漏洞检测中，由于标记真实信息是一项具有挑战性的任务，数据稀缺是一个主要问题。为了获得训练数据，使用了多个在线平台，如
    Stack Overflow、GitHub 以及问题跟踪或错误跟踪系统。尽管这些平台包含数十亿条记录，但标记过程困难且通常是手动完成的。一个可能的解决方案是自动标记数据，但这种方法面临许多假阳性结果的挑战。此外，一些研究人员使用无监督分类进行漏洞检测，但这种方法也存在精度有限的问题。
- en: 'Challenge 5: Lack of Model Interpretability. Interpretability in DL models
    refers to the ability to understand and explain the decisions made by the model (Dwivedi
    et al., [2023](#bib.bib41); Minh et al., [2022](#bib.bib106)). In the context
    of software vulnerability detection (Zou et al., [2021](#bib.bib162); Li et al.,
    [2021a](#bib.bib85); Liu et al., [2021b](#bib.bib98)), there are several challenges
    that make interpretability challenging for DL models. First, source code can be
    highly complex, especially in large software projects. It often consists of multiple
    files, functions, and dependencies, making it difficult to extract meaningful
    and concise explanations from the code (Jiang et al., [2022](#bib.bib67)). Software
    systems are dynamic and undergo changes over time. Code is often maintained, updated,
    and refactored, which can introduce complexities in interpreting the decisions
    made by AI models. The model’s explanations may not be applicable to the current
    version of the code if it has evolved since the model’s training.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 5：模型可解释性不足。在深度学习模型中，可解释性指的是理解和解释模型做出决策的能力（Dwivedi 等，[2023](#bib.bib41)；Minh
    等，[2022](#bib.bib106)）。在软件漏洞检测的背景下（Zou 等，[2021](#bib.bib162)；Li 等，[2021a](#bib.bib85)；Liu
    等，[2021b](#bib.bib98)），存在多个挑战使得深度学习模型的可解释性变得困难。首先，源代码可能非常复杂，特别是在大型软件项目中。它通常包含多个文件、函数和依赖关系，使得从代码中提取有意义和简洁的解释变得困难（Jiang
    等，[2022](#bib.bib67)）。软件系统是动态的，会随着时间发生变化。代码通常会被维护、更新和重构，这可能会增加解释 AI 模型做出决策的复杂性。如果模型的训练数据发生变化，模型的解释可能不适用于当前版本的代码。
- en: <svg   height="252.5" overflow="visible" version="1.1" width="593.51"><g transform="translate(0,252.5)
    matrix(1 0 0 -1 0 0) translate(20.38,0) translate(0,211.4)"><g stroke="#000000"><g
    stroke-width="1.0pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 0 0)"><foreignobject width="552.76" height="200.71" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">(1) Current models inadequately capture the
    comprehensive semantics of complex vulnerabilities, as they fail to consider the
    structural and logical information present in source code snippets. Existing ML/DL
    models treat source code as a linear sequence, which limits their ability to identify
    intricate vulnerability patterns. (2) DL models often use a coarse level of granularity
    for vulnerability detection, such as method and file level. Achieving finer-grained
    inputs requires effective program-slicing techniques to eliminate noise and provide
    more specific inputs. Current approaches focus on certain slicing criteria, but
    vulnerabilities can originate from other sources as well. (3) DL models require
    a significant amount of labeled data for effective training. However, in software
    vulnerability detection, there is a scarcity of labeled data due to the challenging
    task of manual labeling. Automatic labeling approaches often generate false positives,
    and unsupervised classification suffers from limited precision. <g stroke-width="0.5pt"
    fill="#FF9999"><path d="M 97.05 40.75 L 5.19 40.75 C 2.13 40.75 -0.35 38.27 -0.35
    35.21 L -0.35 24.91 C -0.35 21.86 2.13 19.38 5.19 19.38 L 97.05 19.38 C 100.11
    19.38 102.59 21.86 102.59 24.91 L 102.59 35.21 C 102.59 38.27 100.11 40.75 97.05
    40.75 Z M -0.35 19.38"></path></g><g stroke-width="0.5pt" fill="#000000" stroke="#000000"
    transform="matrix(1.0 0.0 0.0 1.0 4.27 26.68)"><foreignobject width="94.09" height="12.15"
    transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">Answer to RQ5</foreignobject></g>
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: <svg   height="252.5" overflow="visible" version="1.1" width="593.51"><g transform="translate(0,252.5)
    matrix(1 0 0 -1 0 0) translate(20.38,0) translate(0,211.4)"><g stroke="#000000"><g
    stroke-width="1.0pt" fill="#000000" stroke="#000000" transform="matrix(1.0 0.0
    0.0 1.0 0 0)"><foreignobject width="552.76" height="200.71" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">(1) 现有模型无法充分捕捉复杂漏洞的全面语义，因为它们未能考虑源代码片段中的结构和逻辑信息。现有的机器学习/深度学习模型将源代码视为线性序列，这限制了它们识别复杂漏洞模式的能力。(2)
    深度学习模型通常使用较粗的粒度进行漏洞检测，例如方法级别和文件级别。实现更细粒度的输入需要有效的程序切片技术，以消除噪声并提供更具体的输入。目前的方法集中在某些切片标准上，但漏洞也可能来源于其他地方。(3)
    深度学习模型需要大量的标注数据以进行有效训练。然而，在软件漏洞检测中，由于手动标注任务的挑战，标注数据稀缺。自动标注方法通常会产生假阳性，而无监督分类的精度有限。<g
    stroke-width="0.5pt" fill="#FF9999"><path d="M 97.05 40.75 L 5.19 40.75 C 2.13
    40.75 -0.35 38.27 -0.35 35.21 L -0.35 24.91 C -0.35 21.86 2.13 19.38 5.19 19.38
    L 97.05 19.38 C 100.11 19.38 102.59 21.86 102.59 24.91 L 102.59 35.21 C 102.59
    38.27 100.11 40.75 97.05 40.75 Z M -0.35 19.38"></path></g><g stroke-width="0.5pt"
    fill="#000000" stroke="#000000" transform="matrix(1.0 0.0 0.0 1.0 4.27 26.68)"><foreignobject
    width="94.09" height="12.15" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">回答
    RQ5</foreignobject></g>
- en: 5\. Threats to validity
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5\. 有效性的威胁
- en: External Validity. One of the major threats to the external validity of our
    work is the data collection internal. We collect data in an 11 years old period
    from 2011 to 2022 to coverall all possible studies published during this period.
    Another source of threat to external validity is the coverage of the input data
    types in software vulnerability detection. To tackle this threat, we focused on
    source code snippets as well as repository data, i.e., data that can be extracted
    from open source including GitHub and CVE.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 外部有效性。我们工作的外部有效性的主要威胁之一是数据收集内部。我们在2011年至2022年的11年期间收集数据，以涵盖此期间发布的所有可能的研究。另一个对外部有效性的威胁来源是软件漏洞检测中输入数据类型的覆盖范围。为了解决这个威胁，我们集中于源代码片段以及仓库数据，即可以从开源中提取的数据，包括GitHub和CVE。
- en: Internal Validity. One of the major threats to the internal validity of our
    work is the automatic collection of data for analysis. Our technique for data
    collection is automated at its initial steps in which we may miss some important
    vulnerability detection papers. In fact, we developed a set of scripts that allowed
    us to extract papers given an 11-year period. Even though the subsequent steps
    are manually supervised, still the automatic filtering suffers from this issue.
    The second important issue with our data collection is possible bias. The root
    cause of bias is unavoidable disagreements during paper classification as two
    researchers have worked together to categorize papers based on title, abstract,
    and content of papers. In case the researchers could not come up with an agreement,
    the third researcher join to resolve the differences which somehow relaxes the
    issue.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 内部有效性。我们工作的内部有效性的主要威胁之一是自动数据收集分析。我们的数据收集技术在初始步骤是自动化的，这可能导致我们遗漏一些重要的漏洞检测论文。事实上，我们开发了一套脚本，使我们能够提取给定11年期间的论文。即使后续步骤是人工监督的，但自动过滤仍然存在这个问题。数据收集的第二个重要问题是可能的偏见。偏见的根本原因是不可避免的分类分歧，因为两位研究人员一起根据论文的标题、摘要和内容对论文进行分类。如果研究人员无法达成一致，第三位研究人员会加入以解决分歧，从而在一定程度上缓解了这个问题。
- en: Construct Validity. The major threat to the construct validity of our survey
    is the level of granularity of the analysis we conducted for each primary study.
    For each study, we deeply analyzed the artifacts explained in the paper and show
    their distribution as tables and graphs. For example, in terms of sources for
    benchmark data, we deeply analyzed 17 sources accounting for 53 primary studies
    overall. The second threat to the construct validity is the degree of coverage
    for each primary study. We analyzed each primary study from 5 aspects including
    input data, input representation, embedding techniques, models, vulnerability
    types, and whether the study supports the interpretability of vulnerability detection
    models or not.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 构建有效性。我们调查的构建有效性的主要威胁是我们对每个主要研究进行的分析的粒度水平。对于每项研究，我们深入分析了论文中解释的工件，并将其分布展示为表格和图表。例如，就基准数据的来源而言，我们深入分析了17个来源，涵盖了总共53个主要研究。构建有效性的第二个威胁是每个主要研究的覆盖程度。我们从5个方面分析了每个主要研究，包括输入数据、输入表示、嵌入技术、模型、漏洞类型，以及研究是否支持漏洞检测模型的可解释性。
- en: 6\. Conclusion
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6\. 结论
- en: In this study, we conducted a systematic survey on 67 primary studies using
    ML/DL models for software security vulnerability detection. We collected the papers
    from different journals and conference venues including 25 conferences and 12
    journals. Our review is established based on five major research questions and
    a set of sub-research questions. We devised the research questions in a comprehensive
    manner where to cover various dimensions of software vulnerability detection.
    Our analysis of primary studies indicated that there is a booming trend in the
    growth of using ML/DL models for software vulnerability detection. Our deep analysis
    of data sources of primary studies revealed that 65.7% of studies use benchmark
    data for software vulnerability detection. We also find 6 broad categories of
    DL models along with 14 classic ML models used in software vulnerability detection.
    The categories of DL models are classified as recurrent models, graph models,
    attention models, convolutional models, general models, and transformer models.
    RNNs are by far the most popular DNNs in software vulnerability detection. Our
    analysis also finds that RNNs with LSTM cells are the most popular network architectures
    in recurrent models, accounting for 8 primary studies. In the category of graph
    models, GGNN is the most popular DL model used by 4 primary studies. Our results
    on vulnerability types reveal that the most frequent type of vulnerability covered
    in existing studies is Improper Control of a Resource Through its Lifetime - (CWE-664)
    accounting for 18 primary studies. In conclusion, we have identified a collection
    of ongoing challenges that necessitate further exploration in future studies involving
    the utilization of ML/DL models for software vulnerability detection.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项研究中，我们对使用 ML/DL 模型进行软件安全漏洞检测的67项主要研究进行了系统调查。我们从不同的期刊和会议场所收集了论文，包括25个会议和12个期刊。我们的审查基于五个主要研究问题和一组子研究问题建立。我们以全面的方式设计了研究问题，以涵盖软件漏洞检测的各个维度。我们对主要研究的分析表明，使用
    ML/DL 模型进行软件漏洞检测的增长趋势非常显著。我们对主要研究的数据源进行了深入分析，结果显示65.7%的研究使用了基准数据进行软件漏洞检测。我们还发现了6类深度学习（DL）模型以及14种经典机器学习（ML）模型在软件漏洞检测中的应用。DL
    模型的分类包括递归模型、图模型、注意力模型、卷积模型、通用模型和变换器模型。到目前为止，递归神经网络（RNN）是软件漏洞检测中最受欢迎的深度神经网络（DNN）。我们的分析还发现，具有
    LSTM 单元的 RNN 是递归模型中最受欢迎的网络架构，占8项主要研究。在图模型类别中，GGNN 是4项主要研究中使用的最受欢迎的 DL 模型。我们对漏洞类型的结果显示，现有研究中最频繁出现的漏洞类型是资源生命周期控制不当
    - （CWE-664），占18项主要研究。总之，我们识别出了一系列持续存在的挑战，需在未来研究中进一步探索，特别是涉及 ML/DL 模型在软件漏洞检测中的应用。
- en: References
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: (1)
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (1)
- en: Aaltonen and Gao (2021) Aleksi Aaltonen and Yiwen Gao. 2021. Does the Outsider
    Help? The Impact of Bug Bounty Programs on Data Breaches. *The Impact of Bug Bounty
    Programs on Data Breaches (August 20, 2021). Fox School of Business Research Paper*
    (2021).
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aaltonen 和 Gao (2021) Aleksi Aaltonen 和 Yiwen Gao. 2021. 外部者是否有帮助？漏洞悬赏计划对数据泄露的影响。*漏洞悬赏计划对数据泄露的影响（2021年8月20日）。Fox
    商学院研究论文*（2021年）。
- en: Abri et al. (2019) Faranak Abri, Sima Siami-Namini, Mahdi Adl Khanghah, Fahimeh Mirza
    Soltani, and Akbar Siami Namin. 2019. Can machine/deep learning classifiers detect
    zero-day malware with high accuracy?. In *2019 IEEE international conference on
    big data (Big Data)*. IEEE, 3252–3259.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Abri 等 (2019) Faranak Abri, Sima Siami-Namini, Mahdi Adl Khanghah, Fahimeh Mirza
    Soltani, 和 Akbar Siami Namin. 2019. 机器/深度学习分类器能否高精度检测零日恶意软件？发表于*2019 IEEE 大数据国际会议（Big
    Data）*。IEEE，3252–3259。
- en: Aivatoglou et al. (2021) Georgios Aivatoglou, Mike Anastasiadis, Georgios Spanos,
    Antonis Voulgaridis, Konstantinos Votis, and Dimitrios Tzovaras. 2021. A tree-based
    machine learning methodology to automatically classify software vulnerabilities.
    In *2021 IEEE International Conference on Cyber Security and Resilience (CSR)*.
    IEEE, 312–317.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aivatoglou 等 (2021) Georgios Aivatoglou, Mike Anastasiadis, Georgios Spanos,
    Antonis Voulgaridis, Konstantinos Votis, 和 Dimitrios Tzovaras. 2021. 基于树的机器学习方法自动分类软件漏洞。发表于*2021
    IEEE 国际网络安全与韧性会议（CSR）*。IEEE，312–317。
- en: 'An et al. (2020) Wenyan An, Liwei Chen, Jinxin Wang, Gewangzi Du, Gang Shi,
    and Dan Meng. 2020. AVDHRAM: Automated Vulnerability Detection based on Hierarchical
    Representation and Attention Mechanism. In *2020 IEEE Intl Conf on Parallel &
    Distributed Processing with Applications, Big Data & Cloud Computing, Sustainable
    Computing & Communications, Social Computing & Networking (ISPA/BDCloud/SocialCom/SustainCom)*.
    IEEE, 337–344.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'An et al. (2020) Wenyan An, Liwei Chen, Jinxin Wang, Gewangzi Du, Gang Shi,
    and Dan Meng. 2020. AVDHRAM: 基于层次表示和注意力机制的自动化漏洞检测。在 *2020 IEEE国际并行与分布处理应用、大数据与云计算、可持续计算与通信、社会计算与网络（ISPA/BDCloud/SocialCom/SustainCom）会议*。IEEE，337–344。'
- en: 'Anthonysamy et al. (2017) Pauline Anthonysamy, Awais Rashid, and Ruzanna Chitchyan.
    2017. Privacy requirements: present & future. In *2017 IEEE/ACM 39th international
    conference on software engineering: software engineering in society track (ICSE-SEIS)*.
    IEEE, 13–22.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anthonysamy et al. (2017) Pauline Anthonysamy, Awais Rashid, and Ruzanna Chitchyan.
    2017. 隐私需求：现在与未来。在 *2017 IEEE/ACM 第39届国际软件工程会议：软件工程在社会中的轨迹（ICSE-SEIS）*。IEEE，13–22。
- en: Aslan et al. (2023) Ömer Aslan, Semih Serkant Aktuğ, Merve Ozkan-Okay, Abdullah Asim
    Yilmaz, and Erdal Akin. 2023. A comprehensive review of cyber security vulnerabilities,
    threats, attacks, and solutions. *Electronics* 12, 6 (2023), 1333.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aslan et al. (2023) Ömer Aslan, Semih Serkant Aktuğ, Merve Ozkan-Okay, Abdullah
    Asim Yilmaz, and Erdal Akin. 2023. 网络安全漏洞、威胁、攻击与解决方案的全面回顾。*Electronics* 12, 6（2023年），1333。
- en: Bacchelli and Bird (2013) Alberto Bacchelli and Christian Bird. 2013. Expectations,
    outcomes, and challenges of modern code review. In *2013 35th International Conference
    on Software Engineering (ICSE)*. IEEE, 712–721.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bacchelli and Bird (2013) Alberto Bacchelli 和 Christian Bird. 2013. 现代代码审查的期望、结果和挑战。在
    *2013年第35届国际软件工程会议（ICSE）*。IEEE，712–721。
- en: 'Bhandari et al. (2021) Guru Bhandari, Amara Naseer, and Leon Moonen. 2021.
    CVEfixes: automated collection of vulnerabilities and their fixes from open-source
    software. In *Proceedings of the 17th International Conference on Predictive Models
    and Data Analytics in Software Engineering*. 30–39.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bhandari et al. (2021) Guru Bhandari, Amara Naseer, and Leon Moonen. 2021.
    CVEfixes: 从开源软件中自动收集漏洞及其修复。在 *第17届国际软件工程预测模型与数据分析会议论文集*。30–39。'
- en: 'Bi et al. (2023) Yingzhou Bi, Jiangtao Huang, Penghui Liu, and Lianmei Wang.
    2023. Benchmarking Software Vulnerability Detection Techniques: A Survey. *arXiv
    preprint arXiv:2303.16362* (2023).'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bi et al. (2023) Yingzhou Bi, Jiangtao Huang, Penghui Liu, and Lianmei Wang.
    2023. 软件漏洞检测技术基准：一项调查。*arXiv预印本 arXiv:2303.16362*（2023年）。
- en: 'Bilge and Dumitraş (2012) Leyla Bilge and Tudor Dumitraş. 2012. Before we knew
    it: an empirical study of zero-day attacks in the real world. In *Proceedings
    of the 2012 ACM conference on Computer and communications security*. 833–844.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bilge and Dumitraş (2012) Leyla Bilge 和 Tudor Dumitraş. 2012. 我们还未意识到：现实世界中的零日攻击实证研究。在
    *2012 ACM计算机与通信安全会议论文集*。833–844。
- en: 'Black (2017) Paul E Black. 2017. Sard: a software assurance reference dataset.
    (2017).'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Black (2017) Paul E Black. 2017. Sard: 一份软件保障参考数据集。（2017年）。'
- en: 'Booth et al. (2013) Harold Booth, Doug Rike, and Gregory A Witte. 2013. The
    national vulnerability database (nvd): Overview. (2013).'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Booth et al. (2013) Harold Booth, Doug Rike, 和 Gregory A Witte. 2013. 国家漏洞数据库（nvd）：概述。（2013年）。
- en: 'Bozorgi et al. (2010) Mehran Bozorgi, Lawrence K Saul, Stefan Savage, and Geoffrey M
    Voelker. 2010. Beyond heuristics: learning to classify vulnerabilities and predict
    exploits. In *Proceedings of the 16th ACM SIGKDD international conference on Knowledge
    discovery and data mining*. 105–114.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bozorgi et al. (2010) Mehran Bozorgi, Lawrence K Saul, Stefan Savage, 和 Geoffrey
    M Voelker. 2010. 超越启发式：学习分类漏洞和预测利用。在 *第16届ACM SIGKDD国际知识发现与数据挖掘会议论文集*。105–114。
- en: Bugzilla’s (2021) UI Bugzilla’s. 2021. Bugzilla. (2021).
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bugzilla’s (2021) UI Bugzilla’s. 2021. Bugzilla。（2021年）。
- en: 'Cadar et al. (2008) Cristian Cadar, Daniel Dunbar, Dawson R Engler, et al.
    2008. Klee: unassisted and automatic generation of high-coverage tests for complex
    systems programs.. In *OSDI*, Vol. 8. 209–224.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cadar et al. (2008) Cristian Cadar, Daniel Dunbar, Dawson R Engler, 等. 2008.
    Klee: 无辅助和自动生成高覆盖率的复杂系统程序测试。在 *OSDI*，第8卷。209–224。'
- en: 'Canfora et al. (2022) Gerardo Canfora, Andrea Di Sorbo, Sara Forootani, Matias
    Martinez, and Corrado A Visaggio. 2022. Patchworking: Exploring the code changes
    induced by vulnerability fixing activities. *Information and Software Technology*
    142 (2022), 106745.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canfora et al. (2022) Gerardo Canfora, Andrea Di Sorbo, Sara Forootani, Matias
    Martinez, 和 Corrado A Visaggio. 2022. 补丁工作：探索漏洞修复活动引发的代码更改。*信息与软件技术* 142（2022年），106745。
- en: 'Cao et al. (2022) Sicong Cao, Xiaobing Sun, Lili Bo, Rongxin Wu, Bin Li, and
    Chuanqi Tao. 2022. MVD: Memory-Related Vulnerability Detection Based on Flow-Sensitive
    Graph Neural Networks. *arXiv preprint arXiv:2203.02660* (2022).'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曹等人（2022）思聪·曹，晓冰·孙，莉莉·博，荣欣·吴，彬·李，川琪·陶。2022。MVD：基于流敏感图神经网络的内存相关漏洞检测。*arXiv预印本arXiv:2203.02660*（2022）。
- en: Carlsson and Baca (2005) Bengt Carlsson and Dejan Baca. 2005. Software security
    analysis-execution phase audit. In *31st EUROMICRO Conference on Software Engineering
    and Advanced Applications*. IEEE, 240–247.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡尔松和巴卡（2005）本特·卡尔松，德扬·巴卡。2005。软件安全分析-执行阶段审计。发表于*第31届EUROMICRO软件工程与先进应用会议*。IEEE，240–247。
- en: 'Chakraborty et al. (2021) Saikat Chakraborty, Rahul Krishna, Yangruibo Ding,
    and Baishakhi Ray. 2021. Deep learning based vulnerability detection: Are we there
    yet. *IEEE Transactions on Software Engineering* (2021).'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查克拉博提等人（2021）赛卡特·查克拉博提，拉胡尔·克里希纳，杨瑞博·丁，拜莎基·雷。2021。基于深度学习的漏洞检测：我们还没到达吗。*IEEE软件工程学报*（2021）。
- en: Chang et al. (2011) Yung-Yu Chang, Pavol Zavarsky, Ron Ruhl, and Dale Lindskog.
    2011. Trend analysis of the cve for software vulnerability management. In *2011
    IEEE third international conference on privacy, security, risk and trust and 2011
    IEEE third international conference on social computing*. IEEE, 1290–1293.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 张等人（2011）永裕·张，帕沃尔·扎瓦尔斯基，罗恩·鲁尔，戴尔·林斯科格。2011。软件漏洞管理的CVE趋势分析。发表于*2011 IEEE第三届隐私、安全、风险与信任国际会议及2011
    IEEE第三届社会计算国际会议*。IEEE，1290–1293。
- en: 'Chen et al. (2019a) Haipeng Chen, Jing Liu, Rui Liu, Noseong Park, and VS Subrahmanian.
    2019a. VEST: A System for Vulnerability Exploit Scoring & Timing.. In *IJCAI*.
    6503–6505.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈等人（2019a）海鹏·陈，静·刘，锐·刘，诺森·朴，VS·苏布拉赫曼。2019a。VEST：一个用于漏洞利用评分与时机的系统。发表于*IJCAI*。6503–6505。
- en: Chen et al. (2019b) Haipeng Chen, Rui Liu, Noseong Park, and VS Subrahmanian.
    2019b. Using twitter to predict when vulnerabilities will be exploited. In *Proceedings
    of the 25th ACM SIGKDD international conference on knowledge discovery & data
    Mining*. 3143–3152.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈等人（2019b）海鹏·陈，锐·刘，诺森·朴，VS·苏布拉赫曼。2019b。利用Twitter预测漏洞何时被利用。发表于*第25届ACM SIGKDD国际知识发现与数据挖掘大会论文集*。3143–3152。
- en: Chen et al. (2020a) Jinfu Chen, Patrick Kwaku Kudjo, Solomon Mensah, Selasie Aformaley
    Brown, and George Akorfu. 2020a. An automatic software vulnerability classification
    framework using term frequency-inverse gravity moment and feature selection. *Journal
    of Systems and Software* 167 (2020), 110616.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈等人（2020a）金福·陈，帕特里克·夸库·库乔，所罗门·门萨，塞拉西·阿福马雷·布朗，乔治·阿科夫。2020a。基于词频-逆重力矩和特征选择的自动化软件漏洞分类框架。*系统与软件杂志*
    167（2020），110616。
- en: Chen et al. (2020b) Yang Chen, Andrew E Santosa, Ang Ming Yi, Abhishek Sharma,
    Asankhaya Sharma, and David Lo. 2020b. A machine learning approach for vulnerability
    curation. In *Proceedings of the 17th International Conference on Mining Software
    Repositories*. 32–42.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈等人（2020b）杨·陈，安德鲁·E·圣托萨，昂·名义，阿比舍克·香玛，阿桑卡亚·香玛，大卫·罗。2020b。用于漏洞整理的机器学习方法。发表于*第17届国际软件仓库挖掘会议论文集*。32–42。
- en: Chen et al. (2021) Zimin Chen, Steve Kommrusch, and Martin Monperrus. 2021.
    Neural Transfer Learning for Repairing Security Vulnerabilities in C Code. *arXiv
    preprint arXiv:2104.08308* (2021).
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈等人（2021）子敏·陈，史蒂夫·科姆鲁斯，马丁·蒙佩鲁斯。2021。用于修复C代码中安全漏洞的神经迁移学习。*arXiv预印本arXiv:2104.08308*（2021）。
- en: Chen et al. (2022) Zimin Chen, Steve Kommrusch, and Martin Monperrus. 2022.
    Neural transfer learning for repairing security vulnerabilities in c code. *IEEE
    Transactions on Software Engineering* 49, 1 (2022), 147–165.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈等人（2022）子敏·陈，史蒂夫·科姆鲁斯，马丁·蒙佩鲁斯。2022。用于修复C代码中安全漏洞的神经迁移学习。*IEEE软件工程学报* 49, 1（2022），147–165。
- en: Chen et al. (2010) Zhongqiang Chen, Yuan Zhang, and Zhongrong Chen. 2010. A
    categorization framework for common computer vulnerabilities and exposures. *Comput.
    J.* 53, 5 (2010), 551–580.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈等人（2010）钟强·陈，袁·张，钟荣·陈。2010。常见计算机漏洞和暴露的分类框架。*计算机学报* 53, 5（2010），551–580。
- en: 'Cheng et al. (2021) Xiao Cheng, Haoyu Wang, Jiayi Hua, Guoai Xu, and Yulei
    Sui. 2021. DeepWukong: Statically detecting software vulnerabilities using deep
    graph neural network. *ACM Transactions on Software Engineering and Methodology
    (TOSEM)* 30, 3 (2021), 1–33.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程等人（2021）肖·程，浩宇·王，佳怡·华，国爱·徐，余磊·隋。2021。DeepWukong：使用深度图神经网络静态检测软件漏洞。*ACM软件工程与方法学交易（TOSEM）*
    30, 3（2021），1–33。
- en: Cheng et al. (2019) Xiao Cheng, Haoyu Wang, Jiayi Hua, Miao Zhang, Guoai Xu,
    Li Yi, and Yulei Sui. 2019. Static detection of control-flow-related vulnerabilities
    using graph embedding. In *2019 24th International Conference on Engineering of
    Complex Computer Systems (ICECCS)*. IEEE, 41–50.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cheng 等人（2019）Xiao Cheng、Haoyu Wang、Jiayi Hua、Miao Zhang、Guoai Xu、Li Yi 和 Yulei
    Sui。2019年。基于图嵌入的控制流相关漏洞静态检测。在 *2019年第24届复杂计算机系统工程国际会议（ICECCS）* 上发表。IEEE，41–50。
- en: Cheng et al. (2022) Xiao Cheng, Guanqin Zhang, Haoyu Wang, and Yulei Sui. 2022.
    Path-sensitive code embedding via contrastive learning for software vulnerability
    detection. In *Proceedings of the 31st ACM SIGSOFT International Symposium on
    Software Testing and Analysis*. 519–531.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cheng 等人（2022）Xiao Cheng、Guanqin Zhang、Haoyu Wang 和 Yulei Sui。2022年。通过对比学习的路径敏感代码嵌入用于软件漏洞检测。在
    *第31届ACM SIGSOFT国际软件测试与分析研讨会* 上发表。519–531。
- en: Choi et al. (2017) Min-Je Choi, Sehun Jeong, Hakjoo Oh, and Jaegul Choo. 2017.
    End-to-End Prediction of Buffer Overruns from Raw Source Code via Neural Memory
    Networks. In *Proceedings of the 26th International Joint Conference on Artificial
    Intelligence* (Melbourne, Australia) *(IJCAI’17)*. AAAI Press, 1546–1553.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Choi 等人（2017）Min-Je Choi、Sehun Jeong、Hakjoo Oh 和 Jaegul Choo。2017年。从原始源代码通过神经记忆网络进行端到端的缓冲区溢出预测。在
    *第26届国际人工智能联合会议*（澳大利亚墨尔本）*(IJCAI’17)* 上发表。AAAI出版社，1546–1553。
- en: Dam et al. (2017) Hoa Khanh Dam, Truyen Tran, Trang Pham, Shien Wee Ng, John
    Grundy, and Aditya Ghose. 2017. Automatic feature learning for vulnerability prediction.
    *arXiv preprint arXiv:1708.02368* (2017).
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dam 等人（2017）Hoa Khanh Dam、Truyen Tran、Trang Pham、Shien Wee Ng、John Grundy 和
    Aditya Ghose。2017年。自动特征学习用于漏洞预测。*arXiv 预印本 arXiv:1708.02368*（2017年）。
- en: Dam et al. (2018) Hoa Khanh Dam, Truyen Tran, Trang Pham, Shien Wee Ng, John
    Grundy, and Aditya Ghose. 2018. Automatic feature learning for predicting vulnerable
    software components. *IEEE Transactions on Software Engineering* 47, 1 (2018),
    67–85.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dam 等人（2018）Hoa Khanh Dam、Truyen Tran、Trang Pham、Shien Wee Ng、John Grundy 和
    Aditya Ghose。2018年。自动特征学习用于预测易受攻击的软件组件。*IEEE 软件工程汇刊* 47, 1（2018年），67–85。
- en: 'Devlin et al. (2018) Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina
    Toutanova. 2018. Bert: Pre-training of deep bidirectional transformers for language
    understanding. *arXiv preprint arXiv:1810.04805* (2018).'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Devlin 等人（2018）Jacob Devlin、Ming-Wei Chang、Kenton Lee 和 Kristina Toutanova。2018年。Bert:
    深度双向变换器的预训练用于语言理解。*arXiv 预印本 arXiv:1810.04805*（2018年）。'
- en: 'Dinella et al. (2020) Elizabeth Dinella, Hanjun Dai, Ziyang Li, Mayur Naik,
    Le Song, and Ke Wang. 2020. Hoppity: Learning graph transformations to detect
    and fix bugs in programs. In *International Conference on Learning Representations
    (ICLR)*.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dinella 等人（2020）Elizabeth Dinella、Hanjun Dai、Ziyang Li、Mayur Naik、Le Song 和
    Ke Wang。2020年。Hoppity: 学习图形变换以检测和修复程序中的错误。在 *国际学习表征会议（ICLR）* 上发表。'
- en: 'Ding et al. (2022) Yangruibo Ding, Sahil Suneja, Yunhui Zheng, Jim Laredo,
    Alessandro Morari, Gail Kaiser, and Baishakhi Ray. 2022. VELVET: a noVel Ensemble
    Learning approach to automatically locate VulnErable sTatements. In *2022 IEEE
    International Conference on Software Analysis, Evolution and Reengineering (SANER)*.
    IEEE, 959–970.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ding 等人（2022）Yangruibo Ding、Sahil Suneja、Yunhui Zheng、Jim Laredo、Alessandro
    Morari、Gail Kaiser 和 Baishakhi Ray。2022年。VELVET: 一种新颖的集成学习方法自动定位易受攻击的语句。在 *2022年IEEE国际软件分析、演化与重构会议（SANER）*
    上发表。IEEE，959–970。'
- en: Du et al. (2020) Xiaoting Du, Zenghui Zhou, Beibei Yin, and Guanping Xiao. 2020.
    Cross-project bug type prediction based on transfer learning. *Software Quality
    Journal* 28, 1 (2020), 39–57.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Du 等人（2020）Xiaoting Du、Zenghui Zhou、Beibei Yin 和 Guanping Xiao。2020年。基于迁移学习的跨项目错误类型预测。*软件质量期刊*
    28, 1（2020年），39–57。
- en: 'Duan et al. (2019) Xu Duan, Jingzheng Wu, Shouling Ji, Zhiqing Rui, Tianyue
    Luo, Mutian Yang, and Yanjun Wu. 2019. VulSniper: Focus Your Attention to Shoot
    Fine-Grained Vulnerabilities.. In *IJCAI*. 4665–4671.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Duan 等人（2019）Xu Duan、Jingzheng Wu、Shouling Ji、Zhiqing Rui、Tianyue Luo、Mutian
    Yang 和 Yanjun Wu。2019年。VulSniper: 聚焦你的注意力以发现细粒度漏洞。在 *IJCAI* 上发表。4665–4671。'
- en: Dunham (2009) Andrew Dunham. 2009. *rough-auditing-tool-for-security*. [https://github.com/andrew-d/rough-auditing-tool-for-security](https://github.com/andrew-d/rough-auditing-tool-for-security)
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dunham（2009）Andrew Dunham。2009年。*粗略审计工具用于安全性*。 [https://github.com/andrew-d/rough-auditing-tool-for-security](https://github.com/andrew-d/rough-auditing-tool-for-security)
- en: 'Dwivedi et al. (2023) Rudresh Dwivedi, Devam Dave, Het Naik, Smiti Singhal,
    Rana Omer, Pankesh Patel, Bin Qian, Zhenyu Wen, Tejal Shah, Graham Morgan, et al.
    2023. Explainable AI (XAI): Core ideas, techniques, and solutions. *Comput. Surveys*
    55, 9 (2023), 1–33.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dwivedi等（2023）Rudresh Dwivedi, Devam Dave, Het Naik, Smiti Singhal, Rana Omer,
    Pankesh Patel, Bin Qian, Zhenyu Wen, Tejal Shah, Graham Morgan, 等. 2023. 可解释人工智能（XAI）：核心思想、技术和解决方案。*Comput.
    Surveys* 55, 9 (2023), 1–33。
- en: Facebook (2013) Facebook. 2013. *Infer*. [https://fbinfer.com/](https://fbinfer.com/)
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook（2013）Facebook. 2013. *Infer*。 [https://fbinfer.com/](https://fbinfer.com/)
- en: Filus et al. (2020) Katarzyna Filus, Miltiadis Siavvas, Joanna Domańska, and
    Erol Gelenbe. 2020. The random neural network as a bonding model for software
    vulnerability prediction. In *Symposium on Modelling, Analysis, and Simulation
    of Computer and Telecommunication Systems*. Springer, 102–116.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Filus等（2020）Katarzyna Filus, Miltiadis Siavvas, Joanna Domańska, 和 Erol Gelenbe.
    2020. 随机神经网络作为软件漏洞预测的结合模型。 在 *Symposium on Modelling, Analysis, and Simulation
    of Computer and Telecommunication Systems*。 Springer, 102–116。
- en: Foreman (2019) Park Foreman. 2019. *Vulnerability management*. CRC Press.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Foreman（2019）Park Foreman. 2019. *Vulnerability management*。 CRC Press。
- en: Frei et al. (2006) Stefan Frei, Martin May, Ulrich Fiedler, and Bernhard Plattner.
    2006. Large-scale vulnerability analysis. In *Proceedings of the 2006 SIGCOMM
    workshop on Large-scale attack defense*. 131–138.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Frei等（2006）Stefan Frei, Martin May, Ulrich Fiedler, 和 Bernhard Plattner. 2006.
    大规模漏洞分析。 在 *Proceedings of the 2006 SIGCOMM workshop on Large-scale attack defense*。
    131–138。
- en: 'Fu and Tantithamthavorn (2022) Michael Fu and Chakkrit Tantithamthavorn. 2022.
    LineVul: A Transformer-based Line-Level Vulnerability Prediction. (2022).'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Fu和Tantithamthavorn（2022）Michael Fu 和 Chakkrit Tantithamthavorn. 2022. LineVul:
    基于Transformer的行级漏洞预测。 (2022)。'
- en: 'Gao et al. (2021) Cong Gao, Geng Wang, Weisong Shi, Zhongmin Wang, and Yanping
    Chen. 2021. Autonomous driving security: State of the art and challenges. *IEEE
    Internet of Things Journal* 9, 10 (2021), 7572–7595.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gao等（2021）Cong Gao, Geng Wang, Weisong Shi, Zhongmin Wang, 和 Yanping Chen. 2021.
    自主驾驶安全：现状与挑战。*IEEE Internet of Things Journal* 9, 10 (2021), 7572–7595。
- en: 'Gawron et al. (2018) Marian Gawron, Feng Cheng, and Christoph Meinel. 2018.
    Automatic vulnerability classification using machine learning. In *Risks and Security
    of Internet and Systems: 12th International Conference, CRiSIS 2017, Dinard, France,
    September 19-21, 2017, Revised Selected Papers 12*. Springer, 3–17.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Gawron等（2018）Marian Gawron, Feng Cheng, 和 Christoph Meinel. 2018. 使用机器学习的自动漏洞分类。
    在 *Risks and Security of Internet and Systems: 12th International Conference,
    CRiSIS 2017, Dinard, France, September 19-21, 2017, Revised Selected Papers 12*。
    Springer, 3–17。'
- en: 'Ghaffarian and Shahriari (2017) Seyed Mohammad Ghaffarian and Hamid Reza Shahriari.
    2017. Software vulnerability analysis and discovery using machine-learning and
    data-mining techniques: A survey. *ACM Computing Surveys (CSUR)* 50, 4 (2017),
    1–36.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ghaffarian和Shahriari（2017）Seyed Mohammad Ghaffarian 和 Hamid Reza Shahriari.
    2017. 使用机器学习和数据挖掘技术进行软件漏洞分析和发现：综述。*ACM Computing Surveys (CSUR)* 50, 4 (2017),
    1–36。
- en: Ghaffarian and Shahriari (2021) Seyed Mohammad Ghaffarian and Hamid Reza Shahriari.
    2021. Neural software vulnerability analysis using rich intermediate graph representations
    of programs. *Information Sciences* 553 (2021), 189–207.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ghaffarian和Shahriari（2021）Seyed Mohammad Ghaffarian 和 Hamid Reza Shahriari.
    2021. 使用丰富的中间图表示程序的神经软件漏洞分析。*Information Sciences* 553 (2021), 189–207。
- en: 'Gissurarson et al. (2022) Matthías Páll Gissurarson, Leonhard Applis, Annibale
    Panichella, Arie van Deursen, and David Sands. 2022. PropR: property-based automatic
    program repair. In *Proceedings of the 44th International Conference on Software
    Engineering*. 1768–1780.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Gissurarson等（2022）Matthías Páll Gissurarson, Leonhard Applis, Annibale Panichella,
    Arie van Deursen, 和 David Sands. 2022. PropR: 基于属性的自动程序修复。 在 *Proceedings of the
    44th International Conference on Software Engineering*。 1768–1780。'
- en: Gong et al. (2019) Xi Gong, Zhenchang Xing, Xiaohong Li, Zhiyong Feng, and Zhuobing
    Han. 2019. Joint prediction of multiple vulnerability characteristics through
    multi-task learning. In *2019 24th International Conference on Engineering of
    Complex Computer Systems (ICECCS)*. IEEE, 31–40.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gong等（2019）Xi Gong, Zhenchang Xing, Xiaohong Li, Zhiyong Feng, 和 Zhuobing Han.
    2019. 通过多任务学习联合预测多个漏洞特征。 在 *2019 24th International Conference on Engineering
    of Complex Computer Systems (ICECCS)*。 IEEE, 31–40。
- en: Goodfellow et al. (2020) Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing
    Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio. 2020.
    Generative adversarial networks. *Commun. ACM* 63, 11 (2020), 139–144.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goodfellow等（2020）Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David
    Warde-Farley, Sherjil Ozair, Aaron Courville, 和 Yoshua Bengio. 2020. 生成对抗网络。*Commun.
    ACM* 63, 11 (2020), 139–144。
- en: 'Goseva-Popstojanova and Tyo (2017) Katerina Goseva-Popstojanova and Jacob Tyo.
    2017. Experience report: Security vulnerability profiles of mission critical software:
    Empirical analysis of security related bug reports. In *2017 IEEE 28th International
    Symposium on Software Reliability Engineering (ISSRE)*. IEEE, 152–163.'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Goseva-Popstojanova 和 Tyo (2017) Katerina Goseva-Popstojanova 和 Jacob Tyo.
    2017. 经验报告: 任务关键软件的安全漏洞档案: 安全相关缺陷报告的实证分析。在 *2017 IEEE 第28届软件可靠性工程国际研讨会 (ISSRE)*。IEEE,
    152–163。'
- en: 'Guo et al. (2020) Daya Guo, Shuo Ren, Shuai Lu, Zhangyin Feng, Duyu Tang, Shujie
    Liu, Long Zhou, Nan Duan, Alexey Svyatkovskiy, Shengyu Fu, et al. 2020. Graphcodebert:
    Pre-training code representations with data flow. *arXiv preprint arXiv:2009.08366*
    (2020).'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Guo 等 (2020) Daya Guo, Shuo Ren, Shuai Lu, Zhangyin Feng, Duyu Tang, Shujie
    Liu, Long Zhou, Nan Duan, Alexey Svyatkovskiy, Shengyu Fu, 等. 2020. Graphcodebert:
    通过数据流进行代码表示的预训练。*arXiv 预印本 arXiv:2009.08366* (2020)。'
- en: Harer et al. (2018) Jacob A. Harer, Onur Ozdemir, Tomo Lazovich, Christopher P.
    Reale, Rebecca L. Russell, Louis Y. Kim, and Peter Chin. 2018. Learning to Repair
    Software Vulnerabilities with Generative Adversarial Networks. In *Proceedings
    of the 32nd International Conference on Neural Information Processing Systems*
    (Montréal, Canada) *(NIPS’18)*. Curran Associates Inc., Red Hook, NY, USA, 7944–7954.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Harer 等 (2018) Jacob A. Harer, Onur Ozdemir, Tomo Lazovich, Christopher P. Reale,
    Rebecca L. Russell, Louis Y. Kim, 和 Peter Chin. 2018. 利用生成对抗网络学习修复软件漏洞。在 *第32届神经信息处理系统国际会议*
    (蒙特利尔，加拿大) *(NIPS’18)*。Curran Associates Inc., Red Hook, NY, USA, 7944–7954。
- en: Harzevili et al. (2022) Nima Shiri Harzevili, Jiho Shin, Junjie Wang, and Song
    Wang. 2022. Characterizing and Understanding Software Security Vulnerabilities
    in Machine Learning Libraries. *arXiv preprint arXiv:2203.06502* (2022).
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Harzevili 等 (2022) Nima Shiri Harzevili, Jiho Shin, Junjie Wang, 和 Song Wang.
    2022. 机器学习库中的软件安全漏洞的特征化与理解。*arXiv 预印本 arXiv:2203.06502* (2022)。
- en: He et al. (2020) Daojing He, Zhi Deng, Yuxing Zhang, Sammy Chan, Yao Cheng,
    and Nadra Guizani. 2020. Smart contract vulnerability analysis and security audit.
    *IEEE Network* 34, 5 (2020), 276–282.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: He 等 (2020) Daojing He, Zhi Deng, Yuxing Zhang, Sammy Chan, Yao Cheng, 和 Nadra
    Guizani. 2020. 智能合约漏洞分析与安全审计。*IEEE 网络* 34, 5 (2020), 276–282。
- en: 'Hin et al. (2022) David Hin, Andrey Kan, Huaming Chen, and M Ali Babar. 2022.
    LineVD: Statement-level Vulnerability Detection using Graph Neural Networks. *arXiv
    preprint arXiv:2203.05181* (2022).'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Hin 等 (2022) David Hin, Andrey Kan, Huaming Chen, 和 M Ali Babar. 2022. LineVD:
    使用图神经网络进行语句级漏洞检测。*arXiv 预印本 arXiv:2203.05181* (2022)。'
- en: Hinton et al. (2006) Geoffrey E Hinton, Simon Osindero, and Yee-Whye Teh. 2006.
    A fast learning algorithm for deep belief nets. *Neural computation* 18, 7 (2006),
    1527–1554.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hinton 等 (2006) Geoffrey E Hinton, Simon Osindero, 和 Yee-Whye Teh. 2006. 一种快速学习算法用于深度信念网络。*神经计算*
    18, 7 (2006), 1527–1554。
- en: 'Hoang et al. (2019) Thong Hoang, Hoa Khanh Dam, Yasutaka Kamei, David Lo, and
    Naoyasu Ubayashi. 2019. DeepJIT: an end-to-end deep learning framework for just-in-time
    defect prediction. In *2019 IEEE/ACM 16th International Conference on Mining Software
    Repositories (MSR)*. IEEE, 34–45.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Hoang 等 (2019) Thong Hoang, Hoa Khanh Dam, Yasutaka Kamei, David Lo, 和 Naoyasu
    Ubayashi. 2019. DeepJIT: 一种端到端的深度学习框架用于及时缺陷预测。在 *2019 IEEE/ACM 第16届国际软件仓库挖掘会议
    (MSR)*。IEEE, 34–45。'
- en: Huang et al. (2021) Jianjun Huang, Songming Han, Wei You, Wenchang Shi, Bin
    Liang, Jingzheng Wu, and Yanjun Wu. 2021. Hunting vulnerable smart contracts via
    graph embedding based bytecode matching. *IEEE Transactions on Information Forensics
    and Security* 16 (2021), 2144–2156.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Huang 等 (2021) Jianjun Huang, Songming Han, Wei You, Wenchang Shi, Bin Liang,
    Jingzheng Wu, 和 Yanjun Wu. 2021. 通过图嵌入的字节码匹配寻找易受攻击的智能合约。*IEEE 信息取证与安全学报* 16 (2021),
    2144–2156。
- en: Huo et al. (2018) Xuan Huo, Yang Yang, Ming Li, and De-Chuan Zhan. 2018. Learning
    Semantic Features for Software Defect Prediction by Code Comments Embedding. In
    *2018 IEEE International Conference on Data Mining (ICDM)*. 1049–1054. [https://doi.org/10.1109/ICDM.2018.00133](https://doi.org/10.1109/ICDM.2018.00133)
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Huo 等 (2018) Xuan Huo, Yang Yang, Ming Li, 和 De-Chuan Zhan. 2018. 通过代码注释嵌入学习语义特征用于软件缺陷预测。在
    *2018 IEEE 国际数据挖掘会议 (ICDM)*。1049–1054. [https://doi.org/10.1109/ICDM.2018.00133](https://doi.org/10.1109/ICDM.2018.00133)
- en: 'Jacobs et al. (2023) Jay Jacobs, Sasha Romanosky, Octavian Suciuo, Benjamin
    Edwards, and Armin Sarabi. 2023. Enhancing Vulnerability Prioritization: Data-Driven
    Exploit Predictions with Community-Driven Insights. *arXiv preprint arXiv:2302.14172*
    (2023).'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jacobs 等 (2023) Jay Jacobs, Sasha Romanosky, Octavian Suciuo, Benjamin Edwards,
    和 Armin Sarabi. 2023. 增强漏洞优先级排序：结合社区驱动见解的数据驱动漏洞预测。*arXiv 预印本 arXiv:2302.14172*
    (2023)。
- en: 'Jeon and Kim (2021) Sanghoon Jeon and Huy Kang Kim. 2021. AutoVAS: An automated
    vulnerability analysis system with a deep learning approach. *Computers & Security*
    106 (2021), 102308.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jeon and Kim (2021) Sanghoon Jeon 和 Huy Kang Kim. 2021. AutoVAS：一种基于深度学习的自动化漏洞分析系统。*Computers
    & Security* 106 (2021)，102308。
- en: Jiang and Atif (2020) Yuning Jiang and Yacine Atif. 2020. An approach to discover
    and assess vulnerability severity automatically in cyber-physical systems. In
    *13th international conference on security of information and networks*. 1–8.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jiang and Atif (2020) Yuning Jiang 和 Yacine Atif. 2020. 在网络物理系统中自动发现和评估漏洞严重性的方法。发表于
    *第13届信息与网络安全国际会议*。1–8。
- en: Jiang et al. (2022) Yanjie Jiang, Hui Liu, Yuxia Zhang, Weixing Ji, Hao Zhong,
    and Lu Zhang. 2022. Do bugs lead to unnaturalness of source code?. In *Proceedings
    of the 30th ACM Joint European Software Engineering Conference and Symposium on
    the Foundations of Software Engineering*. 1085–1096.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jiang et al. (2022) Yanjie Jiang, Hui Liu, Yuxia Zhang, Weixing Ji, Hao Zhong
    和 Lu Zhang. 2022. 错误是否导致源代码的不自然？发表于 *第30届ACM欧洲联合软件工程会议及软件工程基础研讨会*。1085–1096。
- en: Jimenez et al. (2016) Matthieu Jimenez, Mike Papadakis, and Yves Le Traon. 2016.
    An empirical analysis of vulnerabilities in openssl and the linux kernel. In *2016
    23rd Asia-Pacific Software Engineering Conference (APSEC)*. IEEE, 105–112.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jimenez et al. (2016) Matthieu Jimenez, Mike Papadakis 和 Yves Le Traon. 2016.
    对 openssl 和 Linux 内核漏洞的实证分析。发表于 *2016年第23届亚太软件工程会议（APSEC）*。IEEE，105–112。
- en: Keele et al. (2007) Staffs Keele et al. 2007. *Guidelines for performing systematic
    literature reviews in software engineering*. Technical Report. Technical report,
    Ver. 2.3 EBSE Technical Report. EBSE.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keele et al. (2007) Keele 等人。2007. *软件工程中的系统文献综述指南*。技术报告。技术报告，版本 2.3 EBSE 技术报告。EBSE。
- en: Khan and Parkinson (2018) Saad Khan and Simon Parkinson. 2018. Review into state
    of the art of vulnerability assessment using artificial intelligence. In *Guide
    to Vulnerability Analysis for Computer Networks and Systems*. Springer, 3–32.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Khan and Parkinson (2018) Saad Khan 和 Simon Parkinson. 2018. 使用人工智能进行漏洞评估的前沿回顾。发表于
    *计算机网络和系统漏洞分析指南*。Springer，3–32。
- en: 'Kim et al. (2019) Taegyu Kim, Chung Hwan Kim, Junghwan Rhee, Fan Fei, Zhan
    Tu, Gregory Walkup, Xiangyu Zhang, Xinyan Deng, and Dongyan Xu. 2019. RVFuzzer:
    Finding Input Validation Bugs in Robotic Vehicles through Control-Guided Testing..
    In *USENIX Security Symposium*. 425–442.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kim et al. (2019) Taegyu Kim, Chung Hwan Kim, Junghwan Rhee, Fan Fei, Zhan Tu,
    Gregory Walkup, Xiangyu Zhang, Xinyan Deng 和 Dongyan Xu. 2019. RVFuzzer：通过控制引导测试在机器人车辆中发现输入验证错误。发表于
    *USENIX安全研讨会*。425–442。
- en: Kritikos et al. (2019) Kyriakos Kritikos, Kostas Magoutis, Manos Papoutsakis,
    and Sotiris Ioannidis. 2019. A survey on vulnerability assessment tools and databases
    for cloud-based web applications. *Array* 3 (2019), 100011.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kritikos et al. (2019) Kyriakos Kritikos, Kostas Magoutis, Manos Papoutsakis
    和 Sotiris Ioannidis. 2019. 针对基于云的Web应用程序的漏洞评估工具和数据库调查。*Array* 3 (2019)，100011。
- en: Kronjee et al. (2018) Jorrit Kronjee, Arjen Hommersom, and Harald Vranken. 2018.
    Discovering software vulnerabilities using data-flow analysis and machine learning.
    In *Proceedings of the 13th international conference on availability, reliability
    and security*. 1–10.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kronjee et al. (2018) Jorrit Kronjee, Arjen Hommersom 和 Harald Vranken. 2018.
    使用数据流分析和机器学习发现软件漏洞。发表于 *第13届国际可用性、可靠性和安全性会议论文集*。1–10。
- en: Kudjo et al. (2020) Patrick Kwaku Kudjo, Jinfu Chen, Solomon Mensah, Richard
    Amankwah, and Christopher Kudjo. 2020. The effect of Bellwether analysis on software
    vulnerability severity prediction models. *Software Quality Journal* 28 (2020),
    1413–1446.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kudjo et al. (2020) Patrick Kwaku Kudjo, Jinfu Chen, Solomon Mensah, Richard
    Amankwah 和 Christopher Kudjo. 2020. Bellwether 分析对软件漏洞严重性预测模型的影响。*软件质量杂志* 28 (2020)，1413–1446。
- en: Kudjo et al. (2019) Patrick Kwaku Kudjo, Jinfu Chen, Minmin Zhou, Solomon Mensah,
    and Rubing Huang. 2019. Improving the accuracy of vulnerability report classification
    using term frequency-inverse gravity moment. In *2019 IEEE 19th International
    Conference on Software Quality, Reliability and Security (QRS)*. IEEE, 248–259.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kudjo et al. (2019) Patrick Kwaku Kudjo, Jinfu Chen, Minmin Zhou, Solomon Mensah
    和 Rubing Huang. 2019. 使用术语频率-逆向引力矩提高漏洞报告分类的准确性。发表于 *2019 IEEE第19届软件质量、可靠性和安全性国际会议（QRS）*。IEEE，248–259。
- en: 'Lattner (2008) Chris Lattner. 2008. *LLVM and Clang: Next generation compiler
    technology*.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lattner (2008) Chris Lattner. 2008. *LLVM 和 Clang：下一代编译器技术*。
- en: Le et al. (2018) Tue Le, Tuan Nguyen, Trung Le, Dinh Phung, Paul Montague, Olivier
    De Vel, and Lizhen Qu. 2018. Maximal divergence sequential autoencoder for binary
    software vulnerability detection. In *International Conference on Learning Representations*.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Le et al. (2018) Tue Le, Tuan Nguyen, Trung Le, Dinh Phung, Paul Montague, Olivier
    De Vel, and Lizhen Qu. 2018. **最大散度序列自编码器用于二元软件脆弱性检测**。见于 *国际学习表征会议*。
- en: Le et al. (2021a) Triet HM Le, Huaming Chen, and M Ali Babar. 2021a. A survey
    on data-driven software vulnerability assessment and prioritization. *arXiv preprint
    arXiv:2107.08364* (2021).
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Le et al. (2021a) Triet HM Le, Huaming Chen, and M Ali Babar. 2021a. **基于数据的软件脆弱性评估与优先排序调查**。*arXiv预印本arXiv:2107.08364*（2021）。
- en: Le et al. (2022) Triet HM Le, Huaming Chen, and M Ali Babar. 2022. A survey
    on data-driven software vulnerability assessment and prioritization. *Comput.
    Surveys* 55, 5 (2022), 1–39.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Le et al. (2022) Triet HM Le, Huaming Chen, and M Ali Babar. 2022. **基于数据的软件脆弱性评估与优先排序调查**。*计算机调查*
    55, 5（2022），1–39。
- en: 'Le et al. (2021b) Triet Huynh Minh Le, David Hin, Roland Croft, and M Ali Babar.
    2021b. Deepcva: Automated commit-level vulnerability assessment with deep multi-task
    learning. In *2021 36th IEEE/ACM International Conference on Automated Software
    Engineering (ASE)*. IEEE, 717–729.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Le et al. (2021b) Triet Huynh Minh Le, David Hin, Roland Croft, and M Ali Babar.
    2021b. **Deepcva**：基于深度多任务学习的自动提交级脆弱性评估。见于 *2021年第36届IEEE/ACM自动化软件工程国际会议（ASE）*。IEEE，717–729。
- en: Le et al. (2019) Triet Huynh Minh Le, Bushra Sabir, and Muhammad Ali Babar.
    2019. Automated software vulnerability assessment with concept drift. In *2019
    IEEE/ACM 16th International Conference on Mining Software Repositories (MSR)*.
    IEEE, 371–382.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Le et al. (2019) Triet Huynh Minh Le, Bushra Sabir, and Muhammad Ali Babar.
    2019. **基于概念漂移的自动化软件脆弱性评估**。见于 *2019 IEEE/ACM第16届国际软件仓库挖掘会议（MSR）*。IEEE，371–382。
- en: 'Lehmann and Pradel (2019) Daniel Lehmann and Michael Pradel. 2019. Wasabi:
    A framework for dynamically analyzing webassembly. In *Proceedings of the Twenty-Fourth
    International Conference on Architectural Support for Programming Languages and
    Operating Systems*. 1045–1058.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lehmann and Pradel (2019) Daniel Lehmann and Michael Pradel. 2019. **Wasabi**：一种动态分析WebAssembly的框架。见于
    *第24届国际编程语言和操作系统架构支持会议会议录*。1045–1058。
- en: Li et al. (2017) Jian Li, Pinjia He, Jieming Zhu, and Michael R Lyu. 2017. Software
    defect prediction via convolutional neural network. In *2017 IEEE International
    Conference on Software Quality, Reliability and Security (QRS)*. IEEE, 318–328.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li et al. (2017) Jian Li, Pinjia He, Jieming Zhu, and Michael R Lyu. 2017. **通过卷积神经网络的软件缺陷预测**。见于
    *2017 IEEE国际软件质量、可靠性和安全会议（QRS）*。IEEE，318–328。
- en: Li et al. (2022) Leping Li, Hui Liu, Kejun Li, Yanjie Jiang, and Rui Sun. 2022.
    Generating Concise Patches for Newly Released Programming Assignments. *IEEE Transactions
    on Software Engineering* (2022).
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li et al. (2022) Leping Li, Hui Liu, Kejun Li, Yanjie Jiang, and Rui Sun. 2022.
    **为新发布的编程作业生成简洁补丁**。*IEEE软件工程汇刊*（2022）。
- en: Li et al. (2021a) Yi Li, Shaohua Wang, and Tien N Nguyen. 2021a. Vulnerability
    detection with fine-grained interpretations. In *Proceedings of the 29th ACM Joint
    Meeting on European Software Engineering Conference and Symposium on the Foundations
    of Software Engineering*. 292–303.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li et al. (2021a) Yi Li, Shaohua Wang, and Tien N Nguyen. 2021a. **脆弱性检测与细粒度解释**。见于
    *第29届ACM欧洲软件工程会议联合会议和软件工程基础研讨会会议录*。292–303。
- en: Li et al. (2019) Yi Li, Shaohua Wang, Tien N. Nguyen, and Son Van Nguyen. 2019.
    Improving Bug Detection via Context-Based Code Representation Learning and Attention-Based
    Neural Networks. *Proc. ACM Program. Lang.* 3, OOPSLA, Article 162 (oct 2019),
    30 pages. [https://doi.org/10.1145/3360588](https://doi.org/10.1145/3360588)
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li et al. (2019) Yi Li, Shaohua Wang, Tien N. Nguyen, and Son Van Nguyen. 2019.
    **通过基于上下文的代码表示学习和基于注意力的神经网络改进缺陷检测**。*ACM程序语言汇刊* 3，OOPSLA，文章162（2019年10月），30页。
    [https://doi.org/10.1145/3360588](https://doi.org/10.1145/3360588)
- en: 'Li et al. (2021b) Zhen Li, Deqing Zou, Shouhuai Xu, Zhaoxuan Chen, Yawei Zhu,
    and Hai Jin. 2021b. Vuldeelocator: a deep learning-based fine-grained vulnerability
    detector. *IEEE Transactions on Dependable and Secure Computing* (2021).'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li et al. (2021b) Zhen Li, Deqing Zou, Shouhuai Xu, Zhaoxuan Chen, Yawei Zhu,
    and Hai Jin. 2021b. **Vuldeelocator**：一种基于深度学习的细粒度脆弱性检测器。*IEEE可靠和安全计算汇刊*（2021）。
- en: 'Li et al. (2021c) Zhen Li, Deqing Zou, Shouhuai Xu, Hai Jin, Yawei Zhu, and
    Zhaoxuan Chen. 2021c. Sysevr: A framework for using deep learning to detect software
    vulnerabilities. *IEEE Transactions on Dependable and Secure Computing* (2021).'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li et al. (2021c) Zhen Li, Deqing Zou, Shouhuai Xu, Hai Jin, Yawei Zhu, and
    Zhaoxuan Chen. 2021c. **Sysevr**：一种利用深度学习检测软件脆弱性的框架。*IEEE可靠和安全计算汇刊*（2021）。
- en: 'Li et al. (2018) Zhen Li, Deqing Zou, Shouhuai Xu, Xinyu Ou, Hai Jin, Sujuan
    Wang, Zhijun Deng, and Yuyi Zhong. 2018. Vuldeepecker: A deep learning-based system
    for vulnerability detection. *arXiv preprint arXiv:1801.01681* (2018).'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Li et al. (2018) Zhen Li, Deqing Zou, Shouhuai Xu, Xinyu Ou, Hai Jin, Sujuan
    Wang, Zhijun Deng, and Yuyi Zhong. 2018. Vuldeepecker：基于深度学习的漏洞检测系统。*arXiv 预印本
    arXiv:1801.01681* (2018)。
- en: 'Lin et al. (2020) Guanjun Lin, Sheng Wen, Qing-Long Han, Jun Zhang, and Yang
    Xiang. 2020. Software vulnerability detection using deep neural networks: a survey.
    *Proc. IEEE* 108, 10 (2020), 1825–1848.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lin et al. (2020) Guanjun Lin, Sheng Wen, Qing-Long Han, Jun Zhang, and Yang
    Xiang. 2020. 使用深度神经网络进行软件漏洞检测：综述。*IEEE 会议论文集* 108, 10 (2020), 1825–1848。
- en: Lin et al. (2019) Guanjun Lin, Jun Zhang, Wei Luo, Lei Pan, Olivier De Vel,
    Paul Montague, and Yang Xiang. 2019. Software vulnerability discovery via learning
    multi-domain knowledge bases. *IEEE Transactions on Dependable and Secure Computing*
    18, 5 (2019), 2469–2485.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lin et al. (2019) Guanjun Lin, Jun Zhang, Wei Luo, Lei Pan, Olivier De Vel,
    Paul Montague, and Yang Xiang. 2019. 通过学习多领域知识库进行软件漏洞发现。*IEEE 可靠与安全计算汇刊* 18, 5
    (2019), 2469–2485。
- en: 'Lin et al. (2017) Guanjun Lin, Jun Zhang, Wei Luo, Lei Pan, and Yang Xiang.
    2017. POSTER: Vulnerability discovery with function representation learning from
    unlabeled projects. In *Proceedings of the 2017 ACM SIGSAC Conference on Computer
    and Communications Security*. 2539–2541.'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lin et al. (2017) Guanjun Lin, Jun Zhang, Wei Luo, Lei Pan, and Yang Xiang.
    2017. POSTER：基于函数表示学习的无标签项目漏洞发现。在 *2017 ACM SIGSAC 计算机与通信安全会议论文集* 中，2539–2541。
- en: Lin et al. (2018) Guanjun Lin, Jun Zhang, Wei Luo, Lei Pan, Yang Xiang, Olivier
    De Vel, and Paul Montague. 2018. Cross-project transfer representation learning
    for vulnerable function discovery. *IEEE Transactions on Industrial Informatics*
    14, 7 (2018), 3289–3297.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lin et al. (2018) Guanjun Lin, Jun Zhang, Wei Luo, Lei Pan, Yang Xiang, Olivier
    De Vel, and Paul Montague. 2018. 跨项目迁移表示学习用于易受攻击函数发现。*IEEE 工业信息学汇刊* 14, 7 (2018),
    3289–3297。
- en: Liu et al. (2021a) Chao Liu, Cuiyun Gao, Xin Xia, David Lo, John Grundy, and
    Xiaohu Yang. 2021a. On the reproducibility and replicability of deep learning
    in software engineering. *ACM Transactions on Software Engineering and Methodology
    (TOSEM)* 31, 1 (2021), 1–46.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liu et al. (2021a) Chao Liu, Cuiyun Gao, Xin Xia, David Lo, John Grundy, and
    Xiaohu Yang. 2021a. 关于深度学习在软件工程中的可复现性和可复制性。*ACM 软件工程与方法学汇刊（TOSEM）* 31, 1 (2021),
    1–46。
- en: 'Liu et al. (2019a) Shigang Liu, Guanjun Lin, Qing-Long Han, Sheng Wen, Jun
    Zhang, and Yang Xiang. 2019a. DeepBalance: Deep-learning and fuzzy oversampling
    for vulnerability detection. *IEEE Transactions on Fuzzy Systems* 28, 7 (2019),
    1329–1343.'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liu et al. (2019a) Shigang Liu, Guanjun Lin, Qing-Long Han, Sheng Wen, Jun Zhang,
    and Yang Xiang. 2019a. DeepBalance：用于漏洞检测的深度学习和模糊过采样。*IEEE 模糊系统汇刊* 28, 7 (2019),
    1329–1343。
- en: 'Liu et al. (2020) Shigang Liu, Guanjun Lin, Lizhen Qu, Jun Zhang, Olivier De Vel,
    Paul Montague, and Yang Xiang. 2020. CD-VulD: Cross-domain vulnerability discovery
    based on deep domain adaptation. *IEEE Transactions on Dependable and Secure Computing*
    (2020).'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liu et al. (2020) Shigang Liu, Guanjun Lin, Lizhen Qu, Jun Zhang, Olivier De
    Vel, Paul Montague, and Yang Xiang. 2020. CD-VulD：基于深度领域适配的跨领域漏洞发现。*IEEE 可靠与安全计算汇刊*
    (2020)。
- en: 'Liu et al. (2019b) Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi,
    Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019b.
    Roberta: A robustly optimized bert pretraining approach. *arXiv preprint arXiv:1907.11692*
    (2019).'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liu et al. (2019b) Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi,
    Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019b.
    Roberta：一种鲁棒优化的 BERT 预训练方法。*arXiv 预印本 arXiv:1907.11692* (2019)。
- en: 'Liu et al. (2021b) Zhenguang Liu, Peng Qian, Xiang Wang, Lei Zhu, Qinming He,
    and Shouling Ji. 2021b. Smart contract vulnerability detection: from pure neural
    network to interpretable graph feature and expert pattern fusion. *arXiv preprint
    arXiv:2106.09282* (2021).'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liu et al. (2021b) Zhenguang Liu, Peng Qian, Xiang Wang, Lei Zhu, Qinming He,
    and Shouling Ji. 2021b. 智能合约漏洞检测：从纯神经网络到可解释图特征与专家模式融合。*arXiv 预印本 arXiv:2106.09282*
    (2021)。
- en: Liu et al. (2021c) Zhenguang Liu, Peng Qian, Xiaoyang Wang, Yuan Zhuang, Lin
    Qiu, and Xun Wang. 2021c. Combining graph neural networks with expert knowledge
    for smart contract vulnerability detection. *IEEE Transactions on Knowledge and
    Data Engineering* (2021).
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liu et al. (2021c) Zhenguang Liu, Peng Qian, Xiaoyang Wang, Yuan Zhuang, Lin
    Qiu, and Xun Wang. 2021c. 将图神经网络与专家知识结合用于智能合约漏洞检测。*IEEE 知识与数据工程汇刊* (2021)。
- en: 'Lu et al. (2021) Ning Lu, Bin Wang, Yongxin Zhang, Wenbo Shi, and Christian
    Esposito. 2021. NeuCheck: A more practical Ethereum smart contract security analysis
    tool. *Software: Practice and Experience* 51, 10 (2021), 2065–2084.'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Lu et al. (2021) 宁璐, 王斌, 张永鑫, 石文博, 和 克里斯蒂安·埃斯波西托. 2021. NeuCheck: 一个更实用的以太坊智能合约安全分析工具.
    *软件：实践与经验* 51, 10 (2021), 2065–2084.'
- en: 'Luo et al. (2019) Qian Luo, Yurui Cao, Jiajia Liu, and Abderrahim Benslimane.
    2019. Localization and navigation in autonomous driving: Threats and countermeasures.
    *IEEE Wireless Communications* 26, 4 (2019), 38–45.'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Luo et al. (2019) 罗倩, 曹宇瑞, 刘佳佳, 和 阿卜杜勒拉希姆·本斯利曼. 2019. 自动驾驶中的定位与导航：威胁与对策. *IEEE无线通信*
    26, 4 (2019), 38–45.
- en: 'Mahor et al. (2022) Vinod Mahor, Kiran Pachlasiya, Bhagwati Garg, Mukesh Chouhan,
    Shrikant Telang, and Romil Rawat. 2022. Mobile Operating System (Android) Vulnerability
    Analysis Using Machine Learning. In *Proceedings of International Conference on
    Network Security and Blockchain Technology: ICNSBT 2021*. Springer, 159–169.'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mahor et al. (2022) 维诺德·马霍尔, 基兰·帕赫拉西亚, 巴赫瓦蒂·戈格, 穆克什·乔汉, 什里坎特·特朗, 和 罗密尔·拉瓦特.
    2022. 使用机器学习的移动操作系统（Android）漏洞分析. 见 *国际网络安全与区块链技术会议论文集：ICNSBT 2021*. 斯普林格, 159–169.
- en: Mao et al. (2020) Yi Mao, Yun Li, Jiatai Sun, and Yixin Chen. 2020. Explainable
    Software vulnerability detection based on Attention-based Bidirectional Recurrent
    Neural Networks. In *2020 IEEE International Conference on Big Data (Big Data)*.
    IEEE, 4651–4656.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mao et al. (2020) 毛艺, 李云, 孙家泰, 和 陈艺鑫. 2020. 基于注意力的双向递归神经网络的可解释软件漏洞检测. 见 *2020年IEEE国际大数据会议
    (Big Data)*. IEEE, 4651–4656.
- en: Marjamäki (2016) Daniel Marjamäki. 2016. *Cppcheck*. [https://cppcheck.sourceforge.io/](https://cppcheck.sourceforge.io/)
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Marjamäki (2016) 丹尼尔·马尔贾梅基. 2016. *Cppcheck*. [https://cppcheck.sourceforge.io/](https://cppcheck.sourceforge.io/)
- en: Medeiros et al. (2023) Nadia Medeiros, Naghmeh Ivaki, Pedro Costa, and Marco
    Vieira. 2023. Trustworthiness models to categorize and prioritize code for security
    improvement. *Journal of Systems and Software* (2023), 111621.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Medeiros et al. (2023) 纳迪亚·梅德罗斯, 纳赫梅赫·伊瓦基, 佩德罗·科斯塔, 和 马尔科·维埃拉. 2023. 用于安全改进的代码分类与优先级模型.
    *系统与软件期刊* (2023), 111621.
- en: 'Minh et al. (2022) Dang Minh, H Xiang Wang, Y Fen Li, and Tan N Nguyen. 2022.
    Explainable artificial intelligence: a comprehensive review. *Artificial Intelligence
    Review* (2022), 1–66.'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minh et al. (2022) 邓敏, 王欢, 李妍芬, 和 阮丹. 2022. 可解释的人工智能：全面综述. *人工智能综述* (2022),
    1–66.
- en: 'Nethercote and Seward (2007) Nicholas Nethercote and Julian Seward. 2007. Valgrind:
    a framework for heavyweight dynamic binary instrumentation. *ACM Sigplan notices*
    42, 6 (2007), 89–100.'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Nethercote and Seward (2007) 尼古拉斯·内瑟科特 和 朱利安·修厄德. 2007. Valgrind: 一个重量级动态二进制插装框架.
    *ACM Sigplan 通告* 42, 6 (2007), 89–100.'
- en: 'Nguyen et al. (2022a) Hoang H Nguyen, Nhat-Minh Nguyen, Hong-Phuc Doan, Zahra
    Ahmadi, Thanh-Nam Doan, and Lingxiao Jiang. 2022a. MANDO-GURU: vulnerability detection
    for smart contract source code by heterogeneous graph embeddings. In *Proceedings
    of the 30th ACM Joint European Software Engineering Conference and Symposium on
    the Foundations of Software Engineering*. 1736–1740.'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Nguyen et al. (2022a) 黄赫, 阮日明, 杜洪福, 扎赫拉·阿赫马迪, 阮清南, 和 蒋灵晓. 2022a. MANDO-GURU:
    通过异质图嵌入检测智能合约源代码中的漏洞. 见 *第30届ACM联合欧洲软件工程会议暨软件工程基础研讨会论文集*. 1736–1740.'
- en: 'Nguyen et al. (2022b) Hoang H Nguyen, Nhat-Minh Nguyen, Chunyao Xie, Zahra
    Ahmadi, Daniel Kudendo, Thanh-Nam Doan, and Lingxiao Jiang. 2022b. MANDO: Multi-Level
    Heterogeneous Graph Embeddings for Fine-Grained Detection of Smart Contract Vulnerabilities.
    *arXiv preprint arXiv:2208.13252* (2022).'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Nguyen et al. (2022b) 黄赫, 阮日明, 谢春耀, 扎赫拉·阿赫马迪, 丹尼尔·库登多, 阮清南, 和 蒋灵晓. 2022b. MANDO:
    多层次异质图嵌入用于细粒度智能合约漏洞检测. *arXiv预印本 arXiv:2208.13252* (2022).'
- en: Nguyen et al. (2020) Tuan Nguyen, Trung Le, Khanh Nguyen, Olivier de Vel, Paul
    Montague, John Grundy, and Dinh Phung. 2020. Deep cost-sensitive kernel machine
    for binary software vulnerability detection. In *Pacific-Asia Conference on Knowledge
    Discovery and Data Mining*. Springer, 164–177.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nguyen et al. (2020) 阮川, 黎忠, 阮汉, 奥利维耶·德·维尔, 保罗·蒙塔古, 约翰·格伦迪, 和 丁丰. 2020. 用于二进制软件漏洞检测的深度成本敏感核机器.
    见 *亚太知识发现与数据挖掘会议*. 斯普林格, 164–177.
- en: 'Ni et al. (2022) Chao Ni, Wei Wang, Kaiwen Yang, Xin Xia, Kui Liu, and David
    Lo. 2022. The best of both worlds: integrating semantic features with expert features
    for defect prediction and localization. In *Proceedings of the 30th ACM Joint
    European Software Engineering Conference and Symposium on the Foundations of Software
    Engineering*. 672–683.'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ni 等（2022）Chao Ni、Wei Wang、Kaiwen Yang、Xin Xia、Kui Liu 和 David Lo。2022。《两全其美：将语义特征与专家特征相结合用于缺陷预测和定位》。在
    *第30届 ACM 欧洲联合软件工程会议暨软件工程基础研讨会* 中。672–683。
- en: 'Nong et al. (2022) Yu Nong, Rainy Sharma, Abdelwahab Hamou-Lhadj, Xiapu Luo,
    and Haipeng Cai. 2022. Open Science in Software Engineering: A Study on Deep Learning-Based
    Vulnerability Detection. *IEEE Transactions on Software Engineering* (2022).'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nong 等（2022）Yu Nong、Rainy Sharma、Abdelwahab Hamou-Lhadj、Xiapu Luo 和 Haipeng
    Cai。2022。《软件工程中的开放科学：基于深度学习的漏洞检测研究》。*IEEE 软件工程学报*（2022）。
- en: Pang et al. (2015) Yulei Pang, Xiaozhen Xue, and Akbar Siami Namin. 2015. Predicting
    vulnerable software components through n-gram analysis and statistical feature
    selection. In *2015 IEEE 14th International Conference on Machine Learning and
    Applications (ICMLA)*. IEEE, 543–548.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pang 等（2015）Yulei Pang、Xiaozhen Xue 和 Akbar Siami Namin。2015。《通过 n-gram 分析和统计特征选择预测易受攻击的软件组件》。在
    *2015 IEEE 第14届国际机器学习与应用会议（ICMLA）* 中。IEEE，543–548。
- en: Pascarella et al. (2019) Luca Pascarella, Fabio Palomba, and Alberto Bacchelli.
    2019. Fine-grained just-in-time defect prediction. *Journal of Systems and Software*
    150 (2019), 22–36.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pascarella 等（2019）Luca Pascarella、Fabio Palomba 和 Alberto Bacchelli。2019。《细粒度即时缺陷预测》。*系统与软件期刊*
    150 (2019)，22–36。
- en: 'Perl et al. (2015) Henning Perl, Sergej Dechand, Matthew Smith, Daniel Arp,
    Fabian Yamaguchi, Konrad Rieck, Sascha Fahl, and Yasemin Acar. 2015. Vccfinder:
    Finding potential vulnerabilities in open-source projects to assist code audits.
    In *Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications
    Security*. 426–437.'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perl 等（2015）Henning Perl、Sergej Dechand、Matthew Smith、Daniel Arp、Fabian Yamaguchi、Konrad
    Rieck、Sascha Fahl 和 Yasemin Acar。2015。《Vccfinder：在开源项目中发现潜在漏洞以协助代码审计》。在 *第22届
    ACM SIGSAC 计算机与通信安全会议论文集* 中。426–437。
- en: 'Petersen et al. (2015) Kai Petersen, Sairam Vakkalanka, and Ludwik Kuzniarz.
    2015. Guidelines for conducting systematic mapping studies in software engineering:
    An update. *Information and software technology* 64 (2015), 1–18.'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Petersen 等（2015）Kai Petersen、Sairam Vakkalanka 和 Ludwik Kuzniarz。2015。《软件工程中系统映射研究的指南：更新版》。*信息与软件技术*
    64（2015），1–18。
- en: Phan et al. (2017) Anh Viet Phan, Minh Le Nguyen, and Lam Thu Bui. 2017. Convolutional
    neural networks over control flow graphs for software defect prediction. In *2017
    IEEE 29th International Conference on Tools with Artificial Intelligence (ICTAI)*.
    IEEE, 45–52.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Phan 等（2017）Anh Viet Phan、Minh Le Nguyen 和 Lam Thu Bui。2017。《基于控制流图的卷积神经网络用于软件缺陷预测》。在
    *2017 IEEE 第29届人工智能工具国际会议（ICTAI）* 中。IEEE，45–52。
- en: 'Piantadosi et al. (2019) Valentina Piantadosi, Simone Scalabrino, and Rocco
    Oliveto. 2019. Fixing of security vulnerabilities in open source projects: A case
    study of apache http server and apache tomcat. In *2019 12th IEEE Conference on
    software testing, validation and verification (ICST)*. IEEE, 68–78.'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Piantadosi 等（2019）Valentina Piantadosi、Simone Scalabrino 和 Rocco Oliveto。2019。《修复开源项目中的安全漏洞：以
    Apache HTTP 服务器和 Apache Tomcat 为例》。在 *2019 第12届 IEEE 软件测试、验证与验证会议（ICST）* 中。IEEE，68–78。
- en: 'Pradel and Sen (2018) Michael Pradel and Koushik Sen. 2018. Deepbugs: A learning
    approach to name-based bug detection. *Proceedings of the ACM on Programming Languages*
    2, OOPSLA (2018), 1–25.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pradel 和 Sen（2018）Michael Pradel 和 Koushik Sen。2018。《Deepbugs：一种基于名称的缺陷检测学习方法》。*ACM
    编程语言学报* 2，OOPSLA（2018），1–25。
- en: Raza and Ahmed (2022) Ali Raza and Waseem Ahmed. 2022. Threat and Vulnerability
    management life cycle in operating systems. A systematic review. *Journal of Multidisciplinary
    Engineering Science and Technology (JMEST)* 9, 1 (2022).
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raza 和 Ahmed（2022）Ali Raza 和 Waseem Ahmed。2022。《操作系统中的威胁与漏洞管理生命周期：系统评审》。*多学科工程科学与技术期刊（JMEST）*
    9，1（2022）。
- en: Riom et al. (2021) Timothé Riom, Arthur Sawadogo, Kevin Allix, Tegawendé F Bissyandé,
    Naouel Moha, and Jacques Klein. 2021. Revisiting the VCCFinder approach for the
    identification of vulnerability-contributing commits. *Empirical Software Engineering*
    26, 3 (2021), 1–30.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Riom 等（2021）Timothé Riom、Arthur Sawadogo、Kevin Allix、Tegawendé F Bissyandé、Naouel
    Moha 和 Jacques Klein。2021。《重新审视 VCCFinder 方法以识别漏洞贡献提交》。*实证软件工程* 26，3（2021），1–30。
- en: Ruospo et al. (2020) Annachiara Ruospo, Alberto Bosio, Alessandro Ianne, and
    Ernesto Sanchez. 2020. Evaluating convolutional neural networks reliability depending
    on their data representation. In *2020 23rd Euromicro Conference on Digital System
    Design (DSD)*. IEEE, 672–679.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruospo 等 (2020) Annachiara Ruospo, Alberto Bosio, Alessandro Ianne 和 Ernesto
    Sanchez. 2020. 评估卷积神经网络的可靠性取决于其数据表示。发表于 *2020 第23届欧罗微数字系统设计会议 (DSD)*。IEEE，672–679。
- en: Russell et al. (2018) Rebecca Russell, Louis Kim, Lei Hamilton, Tomo Lazovich,
    Jacob Harer, Onur Ozdemir, Paul Ellingwood, and Marc McConley. 2018. Automated
    vulnerability detection in source code using deep representation learning. In
    *2018 17th IEEE international conference on machine learning and applications
    (ICMLA)*. IEEE, 757–762.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Russell 等 (2018) Rebecca Russell, Louis Kim, Lei Hamilton, Tomo Lazovich, Jacob
    Harer, Onur Ozdemir, Paul Ellingwood 和 Marc McConley. 2018. 使用深度表示学习在源代码中自动检测漏洞。发表于
    *2018 第17届 IEEE 机器学习与应用国际会议 (ICMLA)*。IEEE，757–762。
- en: Sabetta and Bezzi (2018) Antonino Sabetta and Michele Bezzi. 2018. A practical
    approach to the automatic classification of security-relevant commits. In *2018
    IEEE International conference on software maintenance and evolution (ICSME)*.
    IEEE, 579–582.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sabetta 和 Bezzi (2018) Antonino Sabetta 和 Michele Bezzi. 2018. 自动分类安全相关提交的实际方法。发表于
    *2018 IEEE 软件维护与演进国际会议 (ICSME)*。IEEE，579–582。
- en: Scandariato et al. (2014) Riccardo Scandariato, James Walden, Aram Hovsepyan,
    and Wouter Joosen. 2014. Predicting vulnerable software components via text mining.
    *IEEE Transactions on Software Engineering* 40, 10 (2014), 993–1006.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scandariato 等 (2014) Riccardo Scandariato, James Walden, Aram Hovsepyan 和 Wouter
    Joosen. 2014. 通过文本挖掘预测易受攻击的软件组件。*IEEE 软件工程学报* 40, 10 (2014)，993–1006。
- en: Semasaba et al. (2020) Abubakar Omari Abdallah Semasaba, Wei Zheng, Xiaoxue
    Wu, and Samuel Akwasi Agyemang. 2020. Literature survey of deep learning-based
    vulnerability analysis on source code. *IET Software* 14, 6 (2020), 654–664.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Semasaba 等 (2020) Abubakar Omari Abdallah Semasaba, Wei Zheng, Xiaoxue Wu 和
    Samuel Akwasi Agyemang. 2020. 基于深度学习的漏洞分析文献综述。*IET 软件* 14, 6 (2020)，654–664。
- en: Shar and Tan (2010) Lwin Khin Shar and Hee Beng Kuan Tan. 2010. Auditing the
    defense against cross site scripting in web applications. In *2010 International
    Conference on Security and Cryptography (SECRYPT)*. IEEE, 1–7.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shar 和 Tan (2010) Lwin Khin Shar 和 Hee Beng Kuan Tan. 2010. 在网页应用中审计对跨站脚本攻击的防御。发表于
    *2010 年国际安全与密码学会议 (SECRYPT)*。IEEE，1–7。
- en: Shar and Tan (2012) Lwin Khin Shar and Hee Beng Kuan Tan. 2012. Auditing the
    XSS defence features implemented in web application programs. *IET software* 6,
    4 (2012), 377–390.
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shar 和 Tan (2012) Lwin Khin Shar 和 Hee Beng Kuan Tan. 2012. 审计在网页应用程序中实现的 XSS
    防御特性。*IET 软件* 6, 4 (2012)，377–390。
- en: 'Shippey et al. (2019) Thomas Shippey, David Bowes, and Tracy Hall. 2019. Automatically
    identifying code features for software defect prediction: Using AST N-grams. *Information
    and Software Technology* 106 (2019), 142–160.'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shippey 等 (2019) Thomas Shippey, David Bowes 和 Tracy Hall. 2019. 自动识别软件缺陷预测的代码特征：使用
    AST N-grams。*信息与软件技术* 106 (2019)，142–160。
- en: SpotBugs. (2021) SpotBugs. 2021. *SpotBugs*. [.https://spotbugs.github.io/](.https://spotbugs.github.io/)
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpotBugs. (2021) SpotBugs. 2021. *SpotBugs*。[https://spotbugs.github.io/](https://spotbugs.github.io/)
- en: Staron et al. (2020) Miroslaw Staron, Mirosław Ochodek, Wilhelm Meding, and
    Ola Söder. 2020. Using machine learning to identify code fragments for manual
    review. In *2020 46th Euromicro Conference on Software Engineering and Advanced
    Applications (SEAA)*. IEEE, 513–516.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Staron 等 (2020) Miroslaw Staron, Mirosław Ochodek, Wilhelm Meding 和 Ola Söder.
    2020. 使用机器学习识别需要手动审查的代码片段。发表于 *2020 第46届欧罗微软件工程与高级应用会议 (SEAA)*。IEEE，513–516。
- en: 'Suciu et al. (2022) Octavian Suciu, Connor Nelson, Zhuoer Lyu, Tiffany Bao,
    and Tudor Dumitraș. 2022. Expected exploitability: Predicting the development
    of functional vulnerability exploits. In *31st USENIX Security Symposium (USENIX
    Security 22)*. 377–394.'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Suciu 等 (2022) Octavian Suciu, Connor Nelson, Zhuoer Lyu, Tiffany Bao 和 Tudor
    Dumitraș. 2022. 期望的可利用性：预测功能漏洞利用的发展。发表于 *第31届 USENIX 安全研讨会 (USENIX Security 22)*。377–394。
- en: 'Sun et al. (2018) Nan Sun, Jun Zhang, Paul Rimba, Shang Gao, Leo Yu Zhang,
    and Yang Xiang. 2018. Data-driven cybersecurity incident prediction: A survey.
    *IEEE communications surveys & tutorials* 21, 2 (2018), 1744–1772.'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sun 等 (2018) Nan Sun, Jun Zhang, Paul Rimba, Shang Gao, Leo Yu Zhang 和 Yang
    Xiang. 2018. 数据驱动的网络安全事件预测：一项调查。*IEEE 通信调查与教程* 21, 2 (2018)，1744–1772。
- en: Tan et al. (2020) Youshuai Tan, Sijie Xu, Zhaowei Wang, Tao Zhang, Zhou Xu,
    and Xiapu Luo. 2020. Bug severity prediction using question-and-answer pairs from
    Stack Overflow. *Journal of Systems and Software* 165 (2020), 110567.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tan et al. (2020) Youshuai Tan, Sijie Xu, Zhaowei Wang, Tao Zhang, Zhou Xu,
    和 Xiapu Luo. 2020. 利用Stack Overflow上的问答对进行缺陷严重性预测。*系统与软件期刊* 165 (2020), 110567。
- en: 'Tian et al. (2020) Junfeng Tian, Wenjing Xing, and Zhen Li. 2020. BVDetector:
    A program slice-based binary code vulnerability intelligent detection system.
    *Information and Software Technology* 123 (2020), 106289.'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tian et al. (2020) Junfeng Tian, Wenjing Xing, 和 Zhen Li. 2020. BVDetector：一种基于程序切片的二进制代码漏洞智能检测系统。*信息与软件技术*
    123 (2020), 106289。
- en: Walkowski et al. (2021) Michał Walkowski, Jacek Oko, and Sławomir Sujecki. 2021.
    Vulnerability Management Models Using a Common Vulnerability Scoring System. *Applied
    Sciences* 11, 18 (2021), 8735.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Walkowski et al. (2021) Michał Walkowski, Jacek Oko, 和 Sławomir Sujecki. 2021.
    使用通用漏洞评分系统的漏洞管理模型。*应用科学* 11, 18 (2021), 8735。
- en: Wang et al. (2020) Huanting Wang, Guixin Ye, Zhanyong Tang, Shin Hwei Tan, Songfang
    Huang, Dingyi Fang, Yansong Feng, Lizhong Bian, and Zheng Wang. 2020. Combining
    graph-based learning with automated data collection for code vulnerability detection.
    *IEEE Transactions on Information Forensics and Security* 16 (2020), 1943–1958.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wang et al. (2020) Huanting Wang, Guixin Ye, Zhanyong Tang, Shin Hwei Tan, Songfang
    Huang, Dingyi Fang, Yansong Feng, Lizhong Bian, 和 Zheng Wang. 2020. 将基于图的学习与自动数据收集结合用于代码漏洞检测。*IEEE信息取证与安全期刊*
    16 (2020), 1943–1958。
- en: Wang et al. (2018) Song Wang, Taiyue Liu, Jaechang Nam, and Lin Tan. 2018. Deep
    semantic feature learning for software defect prediction. *IEEE Transactions on
    Software Engineering* 46, 12 (2018), 1267–1293.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wang et al. (2018) Song Wang, Taiyue Liu, Jaechang Nam, 和 Lin Tan. 2018. 深度语义特征学习用于软件缺陷预测。*IEEE软件工程期刊*
    46, 12 (2018), 1267–1293。
- en: Wang et al. (2016) Song Wang, Taiyue Liu, and Lin Tan. 2016. Automatically learning
    semantic features for defect prediction. In *2016 IEEE/ACM 38th International
    Conference on Software Engineering (ICSE)*. IEEE, 297–308.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wang et al. (2016) Song Wang, Taiyue Liu, 和 Lin Tan. 2016. 自动学习语义特征以进行缺陷预测。在*2016年IEEE/ACM第38届国际软件工程大会（ICSE）*中。IEEE，297–308。
- en: Wheeler (2013) David A. Wheeler. 2013. *Dlawfinder*. [http://dwheeler.com/flawfinder/](http://dwheeler.com/flawfinder/)
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wheeler (2013) David A. Wheeler. 2013. *Dlawfinder*. [http://dwheeler.com/flawfinder/](http://dwheeler.com/flawfinder/)
- en: 'Wu et al. (2021) Hongjun Wu, Zhuo Zhang, Shangwen Wang, Yan Lei, Bo Lin, Yihao
    Qin, Haoyu Zhang, and Xiaoguang Mao. 2021. Peculiar: Smart Contract Vulnerability
    Detection Based on Crucial Data Flow Graph and Pre-training Techniques. In *2021
    IEEE 32nd International Symposium on Software Reliability Engineering (ISSRE).
    IEEE*. 378–389.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wu et al. (2021) Hongjun Wu, Zhuo Zhang, Shangwen Wang, Yan Lei, Bo Lin, Yihao
    Qin, Haoyu Zhang, 和 Xiaoguang Mao. 2021. Peculiar：基于关键数据流图和预训练技术的智能合约漏洞检测。在*2021年IEEE第32届国际软件可靠性工程研讨会（ISSRE）*中。IEEE。378–389。
- en: Xia et al. (2023) Chunqiu Steven Xia, Yuxiang Wei, and Lingming Zhang. 2023.
    Automated program repair in the era of large pre-trained language models. In *Proceedings
    of the 45th International Conference on Software Engineering (ICSE 2023). Association
    for Computing Machinery*.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xia et al. (2023) Chunqiu Steven Xia, Yuxiang Wei, 和 Lingming Zhang. 2023. 自动化程序修复在大型预训练语言模型时代的应用。在*第45届国际软件工程大会（ICSE
    2023）论文集*中。计算机协会。
- en: Yamaguchi et al. (2012) Fabian Yamaguchi, Markus Lottmann, and Konrad Rieck.
    2012. Generalized vulnerability extrapolation using abstract syntax trees. In
    *Proceedings of the 28th Annual Computer Security Applications Conference*. 359–368.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yamaguchi et al. (2012) Fabian Yamaguchi, Markus Lottmann, 和 Konrad Rieck. 2012.
    使用抽象语法树的广义漏洞外推。在*第28届年度计算机安全应用会议论文集*中。359–368。
- en: 'Yamaguchi et al. (2011) Fabian Yamaguchi, Konrad Rieck, et al. 2011. Vulnerability
    extrapolation: Assisted discovery of vulnerabilities using machine learning. In
    *5th USENIX Workshop on Offensive Technologies (WOOT 11)*.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yamaguchi et al. (2011) Fabian Yamaguchi, Konrad Rieck, 等。2011. 漏洞外推：利用机器学习辅助发现漏洞。在*第5届USENIX进攻性技术研讨会（WOOT
    11）*中。
- en: 'Yamaguchi et al. (2013) Fabian Yamaguchi, Christian Wressnegger, Hugo Gascon,
    and Konrad Rieck. 2013. Chucky: Exposing missing checks in source code for vulnerability
    discovery. In *Proceedings of the 2013 ACM SIGSAC conference on Computer & communications
    security*. 499–510.'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yamaguchi et al. (2013) Fabian Yamaguchi, Christian Wressnegger, Hugo Gascon,
    和 Konrad Rieck. 2013. Chucky：揭示源代码中缺失的检查以发现漏洞。在*2013年ACM SIGSAC计算机与通信安全会议论文集*中。499–510。
- en: 'Yan et al. (2021) Han Yan, Senlin Luo, Limin Pan, and Yifei Zhang. 2021. HAN-BSVD:
    a hierarchical attention network for binary software vulnerability detection.
    *Computers & Security* 108 (2021), 102286.'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 燕等人（2021）燕寒、罗森林、潘利民和张艺飞。2021。HAN-BSVD：一种用于二进制软件漏洞检测的层次注意力网络。*计算机与安全* 108 (2021)，102286。
- en: Yang et al. (2022) Hongyu Yang, Haiyun Yang, Liang Zhang, and Xiang Cheng. 2022.
    Source Code Vulnerability Detection Using Vulnerability Dependency Representation
    Graph. In *2022 IEEE International Conference on Trust, Security and Privacy in
    Computing and Communications (TrustCom)*. IEEE, 457–464.
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杨等人（2022）杨鸿宇、杨海云、张亮和程翔。2022。使用漏洞依赖表示图的源代码漏洞检测。在*2022 IEEE国际计算与通信信任、安全和隐私会议（TrustCom）*。IEEE，457–464。
- en: 'Yang et al. (2017) Limin Yang, Xiangxue Li, and Yu Yu. 2017. Vuldigger: A just-in-time
    and cost-aware tool for digging vulnerability-contributing changes. In *GLOBECOM
    2017-2017 IEEE Global Communications Conference*. IEEE, 1–7.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杨等人（2017）杨利敏、李向学和余宇。2017。Vuldigger：一个及时且成本意识的漏洞挖掘工具。在*GLOBECOM 2017-2017 IEEE全球通信大会*。IEEE，1–7。
- en: Yin et al. (2022) Jiao Yin, MingJian Tang, Jinli Cao, Hua Wang, and Mingshan
    You. 2022. A real-time dynamic concept adaptive learning algorithm for exploitability
    prediction. *Neurocomputing* 472 (2022), 252–265.
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尹等人（2022）尹骄、唐名坚、曹锦利、王华和游铭山。2022。用于可利用性预测的实时动态概念自适应学习算法。*神经计算* 472 (2022)，252–265。
- en: Yong and Horwitz (2005) Suan Hsi Yong and Susan Horwitz. 2005. Using static
    analysis to reduce dynamic analysis overhead. *Formal Methods in System Design*
    27 (2005), 313–334.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永和霍尔维茨（2005）永思远和苏珊·霍尔维茨。2005。使用静态分析减少动态分析开销。*系统设计中的形式化方法* 27 (2005)，313–334。
- en: 'Zeng et al. (2021) Cheng Zeng, Chun Ying Zhou, Sheng Kai Lv, Peng He, and Jie
    Huang. 2021. GCN2defect: Graph Convolutional Networks for SMOTETomek-based Software
    Defect Prediction. In *2021 IEEE 32nd International Symposium on Software Reliability
    Engineering (ISSRE)*. IEEE, 69–79.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曾等人（2021）曾程、周春莹、吕胜凯、贺鹏和黄杰。2021。GCN2defect：基于SMOTETomek的软件缺陷预测的图卷积网络。在*2021 IEEE第32届软件可靠性工程国际研讨会（ISSRE）*。IEEE，69–79。
- en: 'Zeng et al. (2020) Peng Zeng, Guanjun Lin, Lei Pan, Yonghang Tai, and Jun Zhang.
    2020. Software vulnerability analysis and discovery using deep learning techniques:
    A survey. *IEEE Access* 8 (2020), 197158–197172.'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曾等人（2020）曾鹏、林冠军、潘磊、泰永航和张军。2020。使用深度学习技术的软件漏洞分析与发现：一项综述。*IEEE Access* 8 (2020)，197158–197172。
- en: 'Zhang et al. (2022) Zhuo Zhang, Yan Lei, Meng Yan, Yue Yu, Jiachi Chen, Shangwen
    Wang, and Xiaoguang Mao. 2022. Reentrancy Vulnerability Detection and Localization:
    A Deep Learning Based Two-phase Approach. In *37th IEEE/ACM International Conference
    on Automated Software Engineering*. 1–13.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 张等人（2022）张卓、雷艳、闵阳、余月、陈佳驰、王尚文和毛晓光。2022。重入性漏洞检测与定位：一种基于深度学习的双阶段方法。在*第37届IEEE/ACM国际自动化软件工程会议*。1–13。
- en: 'Zheng et al. (2021) Weining Zheng, Yuan Jiang, and Xiaohong Su. 2021. VulSPG:
    Vulnerability detection based on slice property graph representation learning.
    *arXiv preprint arXiv:2109.02527* (2021).'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 郑等人（2021）郑维宁、姜远和苏晓红。2021。VulSPG：基于切片属性图表示学习的漏洞检测。*arXiv预印本 arXiv:2109.02527*
    (2021)。
- en: 'Zhou et al. (2019) Yaqin Zhou, Shangqing Liu, Jingkai Siow, Xiaoning Du, and
    Yang Liu. 2019. Devign: Effective vulnerability identification by learning comprehensive
    program semantics via graph neural networks. *Advances in neural information processing
    systems* 32 (2019).'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周等人（2019）周雅琴、刘尚清、肖景凯、杜晓宁和刘洋。2019。Devign：通过图神经网络学习全面程序语义的有效漏洞识别。*神经信息处理系统进展*
    32 (2019)。
- en: Zhou and Sharma (2017) Yaqin Zhou and Asankhaya Sharma. 2017. Automated identification
    of security issues from commit messages and bug reports. In *Proceedings of the
    2017 11th joint meeting on foundations of software engineering*. 914–919.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周和夏尔玛（2017）周雅琴和阿桑克哈亚·夏尔玛。2017。从提交信息和错误报告中自动识别安全问题。在*2017年第11届软件工程基础联合会议论文集*。914–919。
- en: Zhuang et al. (2022) Weiyuan Zhuang, Hao Wang, and Xiaofang Zhang. 2022. Just-in-time
    defect prediction based on AST change embedding. *Knowledge-Based Systems* 248
    (2022), 108852.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 庄等人（2022）庄伟远、王浩和张小芳。2022。基于AST变化嵌入的及时缺陷预测。*知识基础系统* 248 (2022)，108852。
- en: Zhuang et al. (2020) Yuan Zhuang, Zhenguang Liu, Peng Qian, Qi Liu, Xiang Wang,
    and Qinming He. 2020. Smart Contract Vulnerability Detection using Graph Neural
    Network.. In *IJCAI*. 3283–3290.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 庄等人（2020）庄元、刘征光、钱鹏、刘琦、王翔和何琴铭。2020。使用图神经网络的智能合约漏洞检测。在*IJCAI*。3283–3290。
- en: Ziems and Wu (2021) Noah Ziems and Shaoen Wu. 2021. Security Vulnerability Detection
    Using Deep Learning Natural Language Processing. In *IEEE INFOCOM 2021-IEEE Conference
    on Computer Communications Workshops (INFOCOM WKSHPS)*. IEEE, 1–6.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ziems 和 Wu (2021) Noah Ziems 和 Shaoen Wu. 2021. 使用深度学习自然语言处理的安全漏洞检测。在 *IEEE
    INFOCOM 2021-IEEE 计算机通信研讨会 (INFOCOM WKSHPS)*。IEEE, 1–6。
- en: 'Zou et al. (2022) Deqing Zou, Yutao Hu, Wenke Li, Yueming Wu, Haojun Zhao,
    and Hai Jin. 2022. mVulPreter: A Multi-Granularity Vulnerability Detection System
    With Interpretations. *IEEE Transactions on Dependable and Secure Computing* (2022).'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Zou 等人 (2022) Deqing Zou, Yutao Hu, Wenke Li, Yueming Wu, Haojun Zhao, 和 Hai
    Jin. 2022. mVulPreter: 一个具有解释功能的多粒度漏洞检测系统。*IEEE Transactions on Dependable and
    Secure Computing* (2022)。'
- en: 'Zou et al. (2019) Deqing Zou, Sujuan Wang, Shouhuai Xu, Zhen Li, and Hai Jin.
    2019. muVulDeePecker: A Deep Learning-Based System for Multiclass Vulnerability
    Detection. *IEEE Transactions on Dependable and Secure Computing* 18, 5 (2019),
    2224–2236.'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Zou 等人 (2019) Deqing Zou, Sujuan Wang, Shouhuai Xu, Zhen Li, 和 Hai Jin. 2019.
    muVulDeePecker: 一个基于深度学习的多类漏洞检测系统。*IEEE Transactions on Dependable and Secure
    Computing* 18, 5 (2019), 2224–2236。'
- en: Zou et al. (2021) Deqing Zou, Yawei Zhu, Shouhuai Xu, Zhen Li, Hai Jin, and
    Hengkai Ye. 2021. Interpreting Deep Learning-Based Vulnerability Detector Predictions
    Based on Heuristic Searching. 30, 2, Article 23 (mar 2021), 31 pages. [https://doi.org/10.1145/3429444](https://doi.org/10.1145/3429444)
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zou 等人 (2021) Deqing Zou, Yawei Zhu, Shouhuai Xu, Zhen Li, Hai Jin, 和 Hengkai
    Ye. 2021. 基于启发式搜索的深度学习漏洞检测器预测解释。30, 2, 文章 23 (2021年3月)，31 页。 [https://doi.org/10.1145/3429444](https://doi.org/10.1145/3429444)
