# 五、事件集合  

> 译者：[PEGASUS1993](https://github.com/PEGASUS1993)  [GG-yuki](https://github.com/GG-yuki)

数据科学中的大多数问题涉及多个变量和事件。 随机变量及其联合分布为我们提供了一种方法来建立我们数据来源的概率模型。 某些技术对于处理大量变量和事件特别有用。它们包括：  
    在精确值难以计算时使用边界  
    使用小型集合时注意模式，然后推广到较大的集合  
    使用对称性，既可以观察也可以简化计算   
在本章中，我们将研究所有这些技术的有力例子。　　

```py
# HIDDEN
from datascience import *
from prob140 import *
import numpy as np
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
%matplotlib inline
import math
from scipy import stats
```
## 5.1Bounding the Chance of a Union

```py
# HIDDEN
from datascience import *
from prob140 import *
import numpy as np
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
%matplotlib inline
import math
from scipy import stats

from matplotlib import patches
import shapely.geometry as sg
import descartes

def show_intersection():
    plt.figure(figsize=(5, 5))
    # create the circles with shapely
    a = sg.Point(-.5,0).buffer(1.0)
    b = sg.Point(0.5,0).buffer(0.75)

    # compute the 3 parts
    left = a.difference(b)
    right = b.difference(a)
    middle = a.intersection(b)

    # use descartes to create the matplotlib patches
    ax = plt.subplot(111)
    ax.add_patch(descartes.PolygonPatch(left, fc='darkblue', ec='k', alpha=0.8))
    ax.add_patch(descartes.PolygonPatch(right, fc='gold', ec='k', alpha=0.6))
    ax.add_patch(descartes.PolygonPatch(middle, fc='olive', ec='k', alpha=0.8))
    ax.annotate('A', [-0.5, 0])
    ax.annotate('B', [0.5, 0])

    # control display
    plt.title('Not Mutually Exclusive')
    plt.axis('off')
    ax.set_xlim(-2, 2); ax.set_ylim(-2, 2)
    ax.set_aspect('equal')
```
在我们获得更大的事件集合之前，让我们考虑两个不相互排斥的事件的联合。 下图显示了两个这样的事件。 集合是整个彩色区域：蓝色，金色，当然也包括交叉区域。  

```py
show_intersection()
```
　　　　　　　　![](https://i.imgur.com/0wAqh2R.png)                                  
我们可以通过分区找到 P（A∪B）。 A∪B 的区域是所有 A 联合 B 中不包含在 A 的一部分。即： A∪B=A∪(B∖AB)  
因此：  　 　P(A∪B)=P(A)+P(B\AB)     　(加法法则) 

　　　　　　    =P(A)+P(B)−P(AB)   (差异法则)  
我们现在有一个 n = 2 的公式。它计算两个事件结合的概率，首先包括每个事件的机会，然后排除交集的机会。　　
Inclusion-Exclusion Formula：两个事件的集合情况  
　　　　　　　　P(A∪B)=P(A)+P(B)−P(AB)
#### 布尔不等式
对于 n> 2，n 个事件的并集的维恩图可能非常复杂且具有多个重叠。所以并集会有点难以找到。我们将在下一节中讲述这一点。  
现在，我们会观察到一些更为简单的事情，即添加所有单个事件的概率而不处理重叠事件必须给我们一个联合概率的上限。  
可以在上图中看到，对于 n = 2。如果只是添加 P（A）和 P（B），则双倍计算交点并且您的答案大于 P（A∪B）(需要校对)。 从上面的 Inclusion-Exclusion Formula 公式中也可以看出这一点。  
布尔的不等式提供了 n 个事件联合概率的上限。 设 A1，A2，...，AnA1，A2，......，An 为事件，则布尔不等式： 
　　　　　　　　　　![](https://i.imgur.com/d81Z2c0.png)　
 
也就是说，至少一个事件发生的可能性不大于发生概率的总和。  
我们已经讨论了为什么 n = 2 时不等式是正确的。一般来说，不等式可以通过数学归纳来证明，这当做个练习留给您。  
对于每个 k，由于![](https://i.imgur.com/mQc8d6b.jpg) ,我们也有个下限：  
　　　　　　　　　![](https://i.imgur.com/pDBTZN6.jpg)  

所以  
　　　　　　　　　![](https://i.imgur.com/iGQeSnc.jpg)  
例如，如果天气预报显示星期六下雨的几率是 40％，而星期日下雨的几率是 10％，那么在这两天的某个时间点降雨的可能性至少为 40％，最多 50％。  
为了准确地找到机会，你需要在两天都下雨的机会，这是你没有的。假设独立在这种情况下似乎不是一个好主意。 因此，您无法计算确切的答案，并且必须满足边界。（有问题，待斟酌）  
虽然边界不是精确答案甚至是近似值，但它们非常有用。 以下是 Boole 不等式在数据科学中的常见用法示例。 它附有 Bonferroni 的名字，因为 Boole 和 Bonferroni 都有关于工会概率的相关界限。   

### Bonferroni 方法  
假设您基于随机样本估计五个参数，并且对于每个参数，您有一个方法可以产生具有任何预先指定概率的良好估计。例如，如果估计值 99％可以保证很好，那么你就有办法做到这一点。  
现在假设你希望你的估计是这样的，95％那五个都是好的。你该怎么办？  
只有 95％的概率才能使每项评估成为可能。如果你这样做，他们一切都好的可能性将低于 95％，因为“一切都很好”的事件是每个事件的一个子集“估计我是好的”。  
布尔不等式可以帮助你弄清楚该怎么做。  
让 A<sub>1</sub>成为 Estimate i 很好的事件。 你想要 P(A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>)= 0.95。 但现在你被卡住了，因为你可以控制的只是 P(A<sub>1</sub>)，P(A<sub>2</sub>)，P(A<sub>3</sub>)，P(A<sub>4</sub>)和 P(A<sub>5</sub>)。 您可以将它们中的每一个都设置为您想要的大小，但是你不知道它们与交叉的可能性有何关系，因为这五个估计是相关的。它们都基于相同的样本。  
你可以通过查看“所有五个都很好”事件的补充来解决这个问题。 补充是“至少一个是坏的”，这是事件的结合“Estimate i 是坏的”。 你的条件是  
　　　　　　　![](https://i.imgur.com/XLZSGIp.jpg)　　  
总和中的每个项都是相应估计值不是很好的概率。你希望这些概率很小。但是由于上面的计算，你也希望它们足够大，以便它们的总和至少为 0.05。  
一种方法是使它们中的每一个等于 0.05 / 5 = 0.01，即 1％。 换句话说，你必须构建每个估计值，以便偶然发现 99％（例如，通过构建 99％的置信区间）。 这被称为 Bonferroni 同时推理方法。  
Bonferroni 方法表明，如果你构建五个估计值中的每个估计值，以便有机会获得 99％，那么所有五个估计值都是好的几率至少为 95％。  
您可以将 95％替换为任何其他阈值并再次执行计算，以查看单个估计值的好坏程度，以便它们同时具有超过阈值的机会。  
## 5.2 容斥  
虽然我们已经确定了 n 个事件结合的概率，除非在 n = 2 的情况下，我们还没有确切机会的公式。对于 n = 2，我们有    
　　　　　　　　　　　![](https://i.imgur.com/EMCP9Fm.jpg)　  
 
### n 个事件集合  
让我们看看我们是否可以通过应用我们对两个事件的并集的了解来猜测更大的 n 的公式。  
　　　　　　　　　　　　![](https://i.imgur.com/dvbZRXH.jpg)　　  
            
一种清晰的形式正在出现！如果我们有一些粗略和准备好的描述，那么将它们写出来会更容易。（XXX）     
重要的是要注意，集合“1≤i<j≤n”指定所有无序的不同索引对。 如果索引是不同的，则其中一个必须小于另一个，因此它是指示集的一部分。 如果 i 和 j 在集合中，则 i <j，因此 i 和 j 是不同的。  
以相同的方式，1≤i<j <k≤n 指定不同指数的所有无序三元组。以此类推。     
### 高斯  
根据我们在三个事件中看到的情况，我们将猜测 n 事件结合的可能性可以通过计算得出  
包括所有事件的概率   
排除所有双交叉点的概率  
包括所有三重交叉点的概率  
排除所有四重交叉点的概率; 以此类推。  
### 一般包含 - 排除公式  
对于事件 A<sub>1</sub>，A<sub>2</sub>，...，A<sub>n</sub>,  
![](https://i.imgur.com/RntLiTf.jpg)

如果你感到疑惑，你可以通过归纳证明这一点; 对于 n = 3 的情况，只需执行类似于上述步骤的步骤。 我们将在后面的章节中用不同的方法证明该公式。  
现在，让我们接受并继续前进。  
### 每个总和中的项数  
要结束该部分，我们将计算包含 - 排除公式中每个总和中的术语数，因此我们知道应用它所需要完成的工作的范围。  
这是再次参考的公式:  
![](https://i.imgur.com/5zWHSpI.png)  
显然，第一个总和中有 n 个项。由于下一步将要清楚的原因，我们将其写为：  
![](https://i.imgur.com/FFPOupS.png)  
在第二个总和中，这些项数对应于从索引 1 到 n 中选择的不同的无序对。这个数字是  
![](https://i.imgur.com/3LejgYo.png)  
在第三个总和中，项数是三个组的数量  
![](https://i.imgur.com/C9mGxLr.png)  
以此类推。  
这表明在包含 - 排除公式中添加和减去了很多项。  
但有时我们很幸运，许多项数都是相等的。然后简化了总和了。这有一个漂亮的例子，请继续阅读。  
## 5.3 匹配问题  
这个著名的问题已经在帽子和人，信件和信封，茶杯和碟子方面进行了各种各样的陈述。事实上，实际上，您可能想要匹配两种项目的任何情况似乎都出现在某处作为匹配问题的设置。  

在字母信封设置中，有 n 个字母标记为 1 到 n，还有 n 个信封标记为 1 到 n。 这些信件被随机地置换到信封中，每个信封一个字母（一个不幸的事件通常归咎于一个不幸的假设秘书），所以所有的排列都是同样可能的。 主要问题是关于放入匹配信封的字母数量。  
除了“现实生活”设置之外，问题在于随机排列的固定点的数量。 固定点是一个元素，其位置不受洗牌的影响。
### 固定位置匹配  
考虑 n 个元素的随机排列，为简单起见，我们将其称为{1,2，...，n}。 对于 1 到 n 范围内的任何 i，位置 i 是固定点的几率是多少？ 换句话说，我写信封的可能性是多少？  
我们知道有 n！ 可能的排列，所有这些都是同样可能的。 要找到 P（在位置 i 处匹配），我们所要做的就是计算将字母 i 放入信封中的排列数量 i。这是计算这些的好方法：  
把信 i 放在信封 i 里。  
完成后，剩余的 n-1 封信进行（n-1）!次置换。  
所以  
![](https://i.imgur.com/tSWtYTB.png)  
请注意答案中没有 i。 无论你修复哪个位置，在该位置匹配的机会是 1 / n。 这形象化了直观的概念，即每个字母同样可能落入任何包络中，因此它落入匹配包络的机会是 1 / n。  
现在修复任何一对位置 i≠j。要找到 P（在位置 i 和 j 处匹配），请扩展我们上面使用的方法：  
将信件 i 放在信封 i 中，将信件 j 放入信封 j 中。  
完成后，剩余的 n-2 封信进行(n−2)!次置换。  
所以  
![](https://i.imgur.com/TcKQBXh.png)  
通过归纳检验 k = 1,2，...，n，  
![](https://i.imgur.com/j9FFCz5.png)  
### 无匹配情况 
如果落在右边信封中的信件是好事件，则最糟糕的事件是每个信件都落在错误的信封中。这是没有匹配的事件，被称为紊乱。让我们找到紊乱的情况。  
关键是要注意补充是一个联合，然后使用包含 - 排除公式。  
![](https://i.imgur.com/FYo1Mro.png)  
事件 A<sub>i</sub>与“位置 i 匹配”。  
通过包含 - 排除公式和我们上面的计算，  
![](https://i.imgur.com/AvuVMuQ.png)  
如果这些款项看起来很令人毛骨悚然，那就再看看。 所添加的术语都没有索引（i，j 等）！ 每个和包括多次添加常数值，因此等于总和中的项数的常数乘积。   
第一个求和公式项数为 n,第二个求和公式的项数是  
![](https://i.imgur.com/AnaBDv3.png)   
第三个求和公式的项数  
![](https://i.imgur.com/C2PJGua.png)  
以此类推  
![](https://i.imgur.com/tDBqaHb.png)  
记住这点  
![](https://i.imgur.com/NrDWBFv.png)  
所以紊乱的概率是(当 n 很大时)    
![](https://i.imgur.com/ruvZIbK.png)  
在随机变量的语言中，令 M<sub>n</sub>为 n 个元素的随机排列中的固定点（匹配）的数量。 然后，对于每个 n≥1，我们有一个确切的公式，表明 M<sub>n</sub>为 0：  
![](https://i.imgur.com/KhiwQ5I.png)  
当 n 很大时，我们也有一个近似值：  
![](https://i.imgur.com/f7escgO.png)  
粗略地看，当 n 很大时，n 个元素的所有排列中约 36.8％将所有元素移离其原始位置。  
### k 匹配  
![](https://i.imgur.com/6bmaHd9.png)　　
## 5.4 无替换抽样  
  
考虑一组标记为$$1, 2 \ldots , n$$的$$n$$个个体。 在没有替换的情况下随机抽取的结果是所有元素的随机排列。 当您尝试评估两个样本是否来自相同的基础分布时，您在 Data8 中使用了随机排列。

让我们来思考$$(X_1, X_2, \ldots , X_n)$$的排列。对于任何 $$i_1, i_2, \ldots , i_n$$ 的 1 到 n 的排列，$$P(X_1 = i_1, X_2 = i_2, \ldots, X_n = i_n) = \frac{1}{n!}$$

注意，右边并不只是依赖于左边这种排列，参数$$X_1, X_2, \ldots , X_n$$是可变的。

#### 相似性

对每个固定的 i，第 i 个参数 Xi 是一个 1 到 n 之间的整数。为了找到 Xi 的边缘分布，我们需要找到从 1 到 n 的每个 k 对应的 P(Xi=k)值，由于所有排列具有相同的可能性，即
$$ P(X_i = k) = \frac{(n-1)!}{n!} = \frac{1}{n} $$

使用一种现在很普遍的方法，把 k 放在 i 的位置上，让剩下 n-1 个元素随意排列，对于每个 i 而言，从 1 到 n 的 Xi 的分布都是一样的。

对于任意 2 个参数 i 和 j 而言，
$$ P(X_i = k, X_j = l) = \frac{1}{n} \cdot \frac{1}{n-1}, ~~ 1 \le k \ne l \le n $$

同样的，右边概率的取值并不需要左边的 i 和 j 取特定值。

我们早在匹配问题中就见过这种概率值的问题。在那个问题中，我们找到了匹配后的概率值，比如$$P(X_i = i, X_j = j)$$。但答案并不取决于 i 和 j 的取值，只有在考虑两个方向时他们的值才会起作用。同理，在我们当下研究的这个问题中也是一样的。

#### 范例：洗牌整齐的牌堆

假设洗完了一副标准扑克牌，所有排列组合的可能性都是一样的。

问题一：第 17 张牌是 A 的可能性有多大？

回答一.根据我们上面的计算，第 17 张牌可能是 52 张牌中的任意一张。里面有四张 A，所有概率值为 4/52。

同理，第 1 张牌或者第 32 张牌是 A 的可能性都为 4/52。根据相似性，所有这些非条件性的边缘分布的概率值都是相等的。如果这听起来很神秘的话，想象一下把发好的牌列首尾相连，你就挑不出哪张是第 1 张牌，哪张是第 17 张牌了。

问题二：如果第 32 张牌是 A，那么第 17 张牌是 A 的可能性有多大？

回答 2.根据我们上面计算的 Xi 和 Xj 的联合分布，答案是 3/51。如果换成第 2 张牌是 A，答案相同。

#### 简单随机样本

简单随机样本是随机抽取的样本，不需要从有限总体中进行替换。样本是总体的一个随机子集，而不是总体的重新排布。如果你从 52 张标准扑克牌中抽取一份 5 张的随机样本，那么那么你拿到的就是子集的五张牌。这五张牌可以按任何顺序出现在你手里，但顺序无关紧要。重要的是这五张牌的集合。

为了找出你手上拿到特殊子集的五张牌的概率，首先得数出这五张牌如果不考虑顺序会有多少种组合数。

这五张牌总共有 52×51×50×49×48 种顺序。

为了得到这 5 张牌的图书组合，把其中一张放在位置 1；第 1 张牌可以有 5 个选择。然后再挑 1 张放在位置 4，以此类推。

所以出现特定牌组的概率是$$ \frac{5 \times 4 \times 3 \times 2 \times 1}{52 \times 51 \times 50 \times 49 \times 48} = \frac{5! 47!}{52!} = \frac{1}{\binom{52}{5}} $$。

这表明，在没有替换的情况下随机一张接一张地发 5 张牌， 相当于洗牌和抽出 5 张牌。

在 scipy 里的 misc 模块允许你计算出这些组合项。

```py
from scipy import misc
misc.comb(52, 5)
2598960.0
```

有将近 260 万种组合。那是一个很大的数字。这有助于我们建立一个理论来理解这个问题以及其他的简单随机样本。在下个部分，我们会建立这个理论。在计算出从总体中抽出的简单随机样本的数量后，我们会结束这个部分。

假设有一个大小为$$N$$的总体（一个确定整数，而非一个随机变量），你想从中抽取一个大小为$$n \le N$$的简单随机样本。你能得到多少不同样本？

我们假设那个“样本”是$$n$$个个体的集合，可以以任何顺序出现。这就和扑克牌很像了。

#### 简单随机样本的数量

一个类似的论点告诉我们简单随机样本的数量为$$ \binom{N}{n} $$，他们出现的可能性相同。

#### 在一个简单随机样本中计算出好的元素

如果一个整体由两类个体组成，这两类按照惯例会被称为“成功或失败”或者“好和坏”。在这里“好”几乎总是代表着你在计算的个体的种类。例如，如果你在尝试数出在一场选举中一个特定的候选人有多少支持者，无论你抱有何种政治观点，那一类的支持者都会被标记成“好”。

假设一个总体为$$N$$的个体包含$$G$$个好的个体，你从中抽取一个大小为$$n$$的简单随机样本。有多少样本会包含$$g$$个好的元素？

包含$$g$$个好个体的样本数量可以通过乘法法则计算得出：
在整体中，从$$G$$个好个体中选出$g$个好个体。你有$$\binom{G}{g}$$种做法。
对于这些有$$g$$个好个体的每个选项而言，你总共有$$\binom{N-G}{n-g}$$个坏个体的选项。

所以包含$$g$$个好个体的样本总数是$$ \binom{G}{g}\binom{N-G}{n-g} $$个。

这些被称为超几何分布，因为这些公式和数学中的超几何序列有关。我们在这个课程中不会解决相关序列的问题，但我仍然可以使用这个令人印象深刻的名词。我们会在稍后的课程中涉及更多的相关的概率的问题。

#### 技术笔记

如果你很谨慎的话，你需要通过尝试找出哪些价值为$$g$$来开始，这是应该在这里被考虑到的事情。因为这是在样本中好的元素的个数，我们知道$$g \le \min(n, G)$$。通过考虑样本中坏的元素的个数，我们知道$$n-g \le \min(n, N-G)$$，因此$$g \ge \max(0, n-N+G)$$。

但你其实不用担心这些技术细节。在计算不可能选项时，仅仅只需定义$$\binom{a}{b}$$为 0。比如$$\binom{5}{10}$$或者$$\binom{6}{-4}$$。如果在样本中得到$$g$$个好的元素是不可能的，那么用来计算概率为$$g$$的好的元素的超几何的算式会得到结果为 0。
