# 2 -- Learning to Answer Yes/No

上节课，我们主要简述了机器学习的定义及其重要性，并用流程图的形式介绍了机器学习的整个过程：根据模型H，使用演算法A，在训练样本D上进行训练，得到最好的h，其对应的g就是我们最后需要的机器学习的模型函数，一般g接近于目标函数f。本节课将继续深入探讨机器学习问题，介绍感知机Perceptron模型，并推导课程的第一个机器学习算法：Perceptron Learning Algorithm（PLA）。

### **一、Perceptron Hypothesis Set**

引入这样一个例子：某银行要根据用户的年龄、性别、年收入等情况来判断是否给该用户发信用卡。现在有训练样本D，即之前用户的信息和是否发了信用卡。这是一个典型的机器学习问题，我们要根据D，通过A，在H中选择最好的h，得到g，接近目标函数f，也就是根据先验知识建立是否给用户发信用卡的模型。银行用这个模型对以后用户进行判断：发信用卡（+1），不发信用卡（-1）。

在这个机器学习的整个流程中，有一个部分非常重要：就是模型选择，即Hypothesis Set。选择什么样的模型，很大程度上会影响机器学习的效果和表现。下面介绍一个简单常用的Hypothesis Set：感知机（Perceptron）。

还是刚才银行是否给用户发信用卡的例子，我们把用户的个人信息作为特征向量x，令总共有d个特征，每个特征赋予不同的权重w，表示该特征对输出（是否发信用卡）的影响有多大。那所有特征的加权和的值与一个设定的阈值threshold进行比较：大于这个阈值，输出为+1，即发信用卡；小于这个阈值，输出为-1，即不发信用卡。感知机模型，就是当特征加权和与阈值的差大于或等于0，则输出h(x)=1；当特征加权和与阈值的差小于0，则输出h(x)=-1，而我们的目的就是计算出所有权值w和阈值threshold。

![这里写图片描述](img/b82f5722a3ab38fa777a0941ce313102.jpg)

为了计算方便，通常我们将阈值threshold当做![](img/80aba44293dd8bc07d580471772db0d3.jpg)，引入一个![](img/ba8e90ec3b50f66d895b239f68d3b97e.jpg)的量与![](img/80aba44293dd8bc07d580471772db0d3.jpg)相乘，这样就把threshold也转变成了权值![](img/80aba44293dd8bc07d580471772db0d3.jpg)，简化了计算。h(x)的表达式做如下变换：

![这里写图片描述](img/b0388ac66d4e814cf2ecc1c4aebc2799.jpg)

为了更清晰地说明感知机模型，我们假设Perceptrons在二维平面上，即![](img/9da10bd554efbaa3d9f62efed8cb7834.jpg)。其中，![](img/80aba44293dd8bc07d580471772db0d3.jpg)是平面上一条分类直线，直线一侧是正类（+1），直线另一侧是负类（-1）。权重w不同，对应于平面上不同的直线。

![这里写图片描述](img/6eb760b955af84cb1123dd680eb4b559.jpg)

那么，我们所说的Perceptron，在这个模型上就是一条直线，称之为linear(binary) classifiers。注意一下，感知器线性分类不限定在二维空间中，在3D中，线性分类用平面表示，在更高维度中，线性分类用超平面表示，即只要是形如![](img/b060a4879c8127c91fe14a0a743ca23d.jpg)的线性模型就都属于linear(binary) classifiers。

同时，需要注意的是，这里所说的linear(binary) classifiers是用简单的感知器模型建立的，线性分类问题还可以使用logistic regression来解决，后面将会介绍。

### **二、Perceptron Learning Algorithm(PLA)**

根据上一部分的介绍，我们已经知道了hypothesis set由许多条直线构成。接下来，我们的目的就是如何设计一个演算法A，来选择一个最好的直线，能将平面上所有的正类和负类完全分开，也就是找到最好的g，使![](img/061263d047d98f81c1e18f8f49c57003.jpg)。

如何找到这样一条最好的直线呢？我们可以使用逐点修正的思想，首先在平面上随意取一条直线，看看哪些点分类错误。然后开始对第一个错误点就行修正，即变换直线的位置，使这个错误点变成分类正确的点。接着，再对第二个、第三个等所有的错误分类点就行直线纠正，直到所有的点都完全分类正确了，就得到了最好的直线。这种“逐步修正”，就是PLA思想所在。

![这里写图片描述](img/75217f1e29be523c4e5b655d738984a2.jpg)

下面介绍一下PLA是怎么做的。首先随机选择一条直线进行分类。然后找到第一个分类错误的点，如果这个点表示正类，被误分为负类，即![](img/4042fc2c320d85292df45d0c2633965e.jpg)，那表示w和x夹角大于90度，其中w是直线的法向量。所以，x被误分在直线的下侧（相对于法向量，法向量的方向即为正类所在的一侧），修正的方法就是使w和x夹角小于90度。通常做法是![](img/cdb3c7bd482f1beb34c202eef937eefd.jpg)，如图右上角所示，一次或多次更新后的![](img/9cfd891e8acb93d51d15087897f73aa2.jpg)与x夹角小于90度，能保证x位于直线的上侧，则对误分为负类的错误点完成了直线修正。

同理，如果是误分为正类的点，即![](img/7e16316a1d9c7fd686cdb66b9f09f630.jpg)，那表示w和x夹角小于90度，其中w是直线的法向量。所以，x被误分在直线的上侧，修正的方法就是使w和x夹角大于90度。通常做法是![](img/25df598a47ca943cce43cee3f072d4e9.jpg)，如图右下角所示，一次或多次更新后的![](img/9cfd891e8acb93d51d15087897f73aa2.jpg)与x夹角大于90度，能保证x位于直线的下侧，则对误分为正类的错误点也完成了直线修正。

按照这种思想，遇到个错误点就进行修正，不断迭代。要注意一点：每次修正直线，可能使之前分类正确的点变成错误点，这是可能发生的。但是没关系，不断迭代，不断修正，最终会将所有点完全正确分类（PLA前提是线性可分的）。这种做法的思想是“知错能改”，有句话形容它：“A fault confessed is half redressed.”

实际操作中，可以一个点一个点地遍历，发现分类错误的点就进行修正，直到所有点全部分类正确。这种被称为Cyclic PLA。

![这里写图片描述](img/a01f86d78da3a4c18e65c580dcbc3034.jpg)

下面用图解的形式来介绍PLA的修正过程：

![这里写图片描述](img/e0d499510e79ae414ba6d8fd0e2b8873.jpg)

![这里写图片描述](img/4c2ee658095b1de81eef6462835ccff5.jpg)

![这里写图片描述](img/eade122d2714fd8f022ed5750dac7ebb.jpg)

![这里写图片描述](img/ee9dfb1122ece819e36dfa0dffa3d710.jpg)

![这里写图片描述](img/0907de3645464656b10156121be5ca29.jpg)

![这里写图片描述](img/3588fd87a025943f3a44dda267611783.jpg)

![这里写图片描述](img/a0efb902fa72d856e691be2b58d367c8.jpg)

![这里写图片描述](img/31868f4e7c73a3c6172e1feb72168f5f.jpg)

![这里写图片描述](img/e54782823ec6e1465008d4c91cdc7924.jpg)

![这里写图片描述](img/83392b3b4e2f3481d33b79efaed3ec11.jpg)

![这里写图片描述](img/a7e3b39ad0a959c6a37bc3b4ab350504.jpg)

对PLA，我们需要考虑以下两个问题：

*   PLA迭代一定会停下来吗？如果线性不可分怎么办？

*   PLA停下来的时候，是否能保证![](img/4e89dc8628aa25992aee4c27f454472b.jpg)？如果没有停下来，是否有![](img/4e89dc8628aa25992aee4c27f454472b.jpg)？

### **三、Guarantee of PLA**

PLA什么时候会停下来呢？根据PLA的定义，当找到一条直线，能将所有平面上的点都分类正确，那么PLA就停止了。要达到这个终止条件，就必须保证D是线性可分（linear separable）。如果是非线性可分的，那么，PLA就不会停止。

![这里写图片描述](img/eed8a5d3f418163842ee06008346de06.jpg)

对于线性可分的情况，如果有这样一条直线，能够将正类和负类完全分开，令这时候的目标权重为![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)，则对每个点，必然满足![](img/e70d3b173167e8a06cb87df08df81c73.jpg)，即对任一点：

![这里写图片描述](img/e13d51359e00687861a9c469e7e0f8d8.jpg)

PLA会对每次错误的点进行修正，更新权重![](img/75cc738213b9d738d2f3b8b323d07aef.jpg)的值，如果![](img/75cc738213b9d738d2f3b8b323d07aef.jpg)与![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)越来越接近，数学运算上就是内积越大，那表示![](img/75cc738213b9d738d2f3b8b323d07aef.jpg)是在接近目标权重![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)，证明PLA是有学习效果的。所以，我们来计算![](img/75cc738213b9d738d2f3b8b323d07aef.jpg)与![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)的内积：

![这里写图片描述](img/522dc5f7b352e150c9704f00ad795cca.jpg)

从推导可以看出，![](img/75cc738213b9d738d2f3b8b323d07aef.jpg)与![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)的内积跟![](img/2a7c3c74c112ab824335ff317c785f4e.jpg)与![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)的内积相比更大了。似乎说明了![](img/75cc738213b9d738d2f3b8b323d07aef.jpg)更接近![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)，但是内积更大，可能是向量长度更大了，不一定是向量间角度更小。所以，下一步，我们还需要证明![](img/75cc738213b9d738d2f3b8b323d07aef.jpg)与![](img/2a7c3c74c112ab824335ff317c785f4e.jpg)向量长度的关系：

![这里写图片描述](img/d316f70f72b7ea87e40817e2cd9f5543.jpg)

![](img/2a7c3c74c112ab824335ff317c785f4e.jpg)只会在分类错误的情况下更新，最终得到的![](img/be9452610f340ddcd227d32452da883b.jpg)相比![](img/392d2051d8acd806804208c33704175a.jpg)的增量值不超过![](img/46294e55f4b6c554e691470ae7ec3d2a.jpg)。也就是说，![](img/2a7c3c74c112ab824335ff317c785f4e.jpg)的增长被限制了，![](img/75cc738213b9d738d2f3b8b323d07aef.jpg)与![](img/2a7c3c74c112ab824335ff317c785f4e.jpg)向量长度不会差别太大！

如果令初始权值![](img/80aba44293dd8bc07d580471772db0d3.jpg)，那么经过T次错误修正后，有如下结论：

下面贴出来该结论的具体推导过程：

![这里写图片描述](img/9499cd5bc28ac0c3d524f8115ef09a46.jpg)

![这里写图片描述](img/182b2ba169926a57c9bb35d350c6d04f.jpg)

上述不等式左边其实是![](img/2ed3b41c02e21f3224f54ab912153516.jpg)与![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)夹角的余弦值，随着T增大，该余弦值越来越接近1，即![](img/2ed3b41c02e21f3224f54ab912153516.jpg)与![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)越来越接近。同时，需要注意的是，![](img/2b1582bb9dd36767edc8638d5142f4a6.jpg)，也就是说，迭代次数T是有上界的。根据以上证明，我们最终得到的结论是：![](img/75cc738213b9d738d2f3b8b323d07aef.jpg)与![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)的是随着迭代次数增加，逐渐接近的。而且，PLA最终会停下来（因为T有上界），实现对线性可分的数据集完全分类。

### **四、Non-Separable Data**

上一部分，我们证明了线性可分的情况下，PLA是可以停下来并正确分类的，但对于非线性可分的情况，![](img/40de538fbc9692d37d7d1b7ab8958efb.jpg)实际上并不存在，那么之前的推导并不成立，PLA不一定会停下来。所以，PLA虽然实现简单，但也有缺点：

![这里写图片描述](img/184006fbd0c94062a9bad5aecdb2b705.jpg)

对于非线性可分的情况，我们可以把它当成是数据集D中掺杂了一下noise，事实上，大多数情况下我们遇到的D，都或多或少地掺杂了noise。这时，机器学习流程是这样的：

![这里写图片描述](img/5ca498908766c95678b857366c359ede.jpg)

在非线性情况下，我们可以把条件放松，即不苛求每个点都分类正确，而是容忍有错误点，取错误点的个数最少时的权重w：

![这里写图片描述](img/459e9ae9fb763c5285e4b3d6e7017446.jpg)

事实证明，上面的解是NP-hard问题，难以求解。然而，我们可以对在线性可分类型中表现很好的PLA做个修改，把它应用到非线性可分类型中，获得近似最好的g。

修改后的PLA称为Packet Algorithm。它的算法流程与PLA基本类似，首先初始化权重![](img/80aba44293dd8bc07d580471772db0d3.jpg)，计算出在这条初始化的直线中，分类错误点的个数。然后对错误点进行修正，更新w，得到一条新的直线，在计算其对应的分类错误的点的个数，并与之前错误点个数比较，取个数较小的直线作为我们当前选择的分类直线。之后，再经过n次迭代，不断比较当前分类错误点个数与之前最少的错误点个数比较，选择最小的值保存。直到迭代次数完成后，选取个数最少的直线对应的w，即为我们最终想要得到的权重值。

![这里写图片描述](img/5d5060a872bbddfe2d5fb0263407ee05.jpg)

如何判断数据集D是不是线性可分？对于二维数据来说，通常还是通过肉眼观察来判断的。一般情况下，Pocket Algorithm要比PLA速度慢一些。

### **五、总结**

本节课主要介绍了线性感知机模型，以及解决这类感知机分类问题的简单算法：PLA。我们详细证明了对于线性可分问题，PLA可以停下来并实现完全正确分类。对于不是线性可分的问题，可以使用PLA的修正算法Pocket Algorithm来解决。

**_注明：_**

文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程。