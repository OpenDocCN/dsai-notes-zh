["```py\nphases = [TrainingPhase(epochs=1, opt_fn=optim.SGD, lr = 1e-2),   \n          TrainingPhase(epochs=2, opt_fn=optim.SGD, lr = 1e-3)]\n```", "```py\nlearn.fit_opt_sched(phases)\n```", "```py\nphases = [TrainingPhase(epochs=1, opt_fn=optim.SGD, lr = 1e-2), \n          TrainingPhase(epochs=1, opt_fn=optim.SGD, \n                       lr = (1e-2,1e-3), lr_decay=DecayType.LINEAR),\n          TrainingPhase(epochs=1, opt_fn=optim.SGD, lr = 1e-3)]\n```", "```py\nlr_i = start_lr + (end_lr - start_lr) * i/n\n```", "```py\nphases = [TrainingPhase(epochs=1, opt_fn=optim.SGD, lr = 1e-2),    \n          TrainingPhase(epochs=1, opt_fn=optim.SGD, lr =(1e-2,1e-3),\n                  lr_decay=DecayType.COSINE),           \n          TrainingPhase(epochs=1, opt_fn=optim.SGD, lr = 1e-3)]\n```", "```py\nlr_i = end_lr + (start_lr - end_lr)/2 * (1 + np.cos(i * np.pi)/n)\n```", "```py\nlr_i = start_lr * (end_lr/start_lr)**(i/n)\n```", "```py\nlr_i = end_lr + (start_lr - end_lr) * (1 - i/n) ** p\n```", "```py\nphases = [TrainingPhase(epochs=1, opt_fn=optim.SGD, lr = 1e-2), \n          TrainingPhase(epochs=1, opt_fn=optim.SGD, lr = 1e-2, \n                        lr_decay=DecayType.COSINE),\n          TrainingPhase(epochs=1, opt_fn=optim.SGD, lr = 1e-3)]\n```", "```py\n**def** phases_sgdr(lr, opt_fn, num_cycle,cycle_len,cycle_mult):\n    phases = [TrainingPhase(epochs = cycle_len/ 20, opt_fn=opt_fn, \n                       lr=lr/100),\n              TrainingPhase(epochs = cycle_len * 19/20, \n                   opt_fn=opt_fn, lr=lr, lr_decay=DecayType.COSINE)]\n    **for** i **in** range(1,num_cycle):\n        phases.append(TrainingPhase(epochs=cycle_len*\n                      (cycle_mult**i), opt_fn=opt_fn, lr=lr, \n                      lr_decay=DecayType.COSINE))\n    **return** phases\n```", "```py\n**def** phases_1cycle(cycle_len,lr,div,pct,max_mom,min_mom):\n    tri_cyc = (1-pct/100) * cycle_len\n    **return** [TrainingPhase(epochs=tri_cyc/2, opt_fn=optim.SGD, \n                          lr=(lr/div,lr), lr_decay=DecayType.LINEAR,\n                          momentum=(max_mom,min_mom),  \n                          momentum_decay=DecayType.LINEAR),\n           TrainingPhase(epochs=tri_cyc/2, opt_fn=optim.SGD, \n                         lr=(lr,lr/div), lr_decay=DecayType.LINEAR, \n                          momentum=(min_mom,max_mom), \n                          momentum_decay=DecayType.LINEAR),\n           TrainingPhase(epochs=cycle_len-tri_cyc, opt_fn=optim.SGD,\n                         lr=(lr/div,lr/(100*div)), \n                         lr_decay=DecayType.LINEAR, \n                         momentum=max_mom)]\n```", "```py\ndata1 = get_data(28,batch_size)\ndata2 = get_data(32,batch_size)learn = ConvLearner.from_model_data(ShallowConvNet(), data1)phases = [TrainingPhase(epochs=1, opt_fn=optim.Adam, lr=1e-2, \n                        lr_decay=DecayType.COSINE),\n          TrainingPhase(epochs=2, opt_fn=optim.Adam, lr=1e-2, \n                        lr_decay=DecayType.COSINE)]learn.fit_opt_sched(phases, data_list=[data1,data2])\n```", "```py\n%matplotlib inline\n%reload_ext autoreload\n%autoreload 2**from** **fastai.conv_learner** **import** *\n**from** **pathlib** **import** Path\n**from** **scipy** **import** ndimage\ntorch.cuda.set_device(3)\n\ntorch.backends.cudnn.benchmark=**True**PATH = Path('data/imagenet')\nPATH_TRN = PATH/'train'm_vgg = to_gpu(vgg16(**True**)).eval()\nset_trainable(m_vgg, **False**)\n```", "```py\nimg_fn = PATH_TRN/'n01558993'/'n01558993_9684.JPEG'\nimg = open_image(img_fn)\nplt.imshow(img);\n```", "```py\nsz=288trn_tfms,val_tfms = tfms_from_model(vgg16, sz)\nimg_tfm = val_tfms(img)\nimg_tfm.shape*(3, 288, 288)*opt_img = np.random.uniform(0, 1, size=img.shape).astype(np.float32)\nplt.imshow(opt_img);\n```", "```py\nsz=288\n```", "```py\ntrn_tfms,val_tfms = tfms_from_model(vgg16, sz)\nimg_tfm = val_tfms(img)\nimg_tfm.shape*(3, 288, 288)*\n```", "```py\nopt_img = np.random.uniform(0, 1, size=img.shape).astype(np.float32)\nplt.imshow(opt_img);\n```", "```py\nopt_img = scipy.ndimage.filters.median_filter(opt_img, [8,8,1])\nplt.imshow(opt_img);\n```", "```py\nopt_img = val_tfms(opt_img)/2\nopt_img_v = V(opt_img[**None**], requires_grad=**True**)\nopt_img_v.shape*torch.Size([1, 3, 288, 288])*\n```", "```py\nm_vgg = nn.Sequential(*children(m_vgg)[:37])\n```", "```py\ntarg_t = m_vgg(VV(img_tfm[**None**]))\ntarg_v = V(targ_t)\ntarg_t.shape*torch.Size([1, 512, 18, 18])*max_iter = 1000\nshow_iter = 100\noptimizer = optim.LBFGS([opt_img_v], lr=0.5)\n```", "```py\n**def** actn_loss(x): **return** F.mse_loss(m_vgg(x), targ_v)*1000**def** step(loss_fn):\n    **global** n_iter\n    optimizer.zero_grad()\n    loss = loss_fn(opt_img_v)\n    loss.backward()\n    n_iter+=1\n    **if** n_iter%show_iter==0: \n        print(f'Iteration: n_iter, loss: **{loss.data[0]}**')\n    **return** loss\n```", "```py\nn_iter=0\n**while** n_iter <= max_iter: optimizer.step(partial(step,actn_loss))*Iteration: n_iter, loss: 0.8466196656227112\nIteration: n_iter, loss: 0.34066855907440186\nIteration: n_iter, loss: 0.21001280844211578\nIteration: n_iter, loss: 0.15562333166599274\nIteration: n_iter, loss: 0.12673595547676086\nIteration: n_iter, loss: 0.10863320529460907\nIteration: n_iter, loss: 0.0966048613190651\nIteration: n_iter, loss: 0.08812198787927628\nIteration: n_iter, loss: 0.08170554041862488\nIteration: n_iter, loss: 0.07657770067453384*\n```", "```py\nx = val_tfms.denorm(np.rollaxis(to_np(opt_img_v.data),1,4))[0]\nplt.figure(figsize=(7,7))\nplt.imshow(x);\n```", "```py\n**class** **SaveFeatures**():\n    features=**None**\n    **def** __init__(self, m): \n        self.hook = m.register_forward_hook(self.hook_fn)\n    **def** hook_fn(self, module, input, output): self.features = output\n    **def** close(self): self.hook.remove()\n```", "```py\nm_vgg = to_gpu(vgg16(**True**)).eval()\nset_trainable(m_vgg, **False**)\n```", "```py\nblock_ends = [i-1 **for** i,o **in** enumerate(children(m_vgg))\n              **if** isinstance(o,nn.MaxPool2d)]\nblock_ends*[5, 12, 22, 32, 42]*\n```", "```py\nsf = SaveFeatures(children(m_vgg)[block_ends[3]])\n```", "```py\n**def** get_opt():\n    opt_img = np.random.uniform(0, 1, \n                                size=img.shape).astype(np.float32)\n    opt_img = scipy.ndimage.filters.median_filter(opt_img, [8,8,1])\n    opt_img_v = V(val_tfms(opt_img/2)[**None**], requires_grad=**True**)\n    **return** opt_img_v, optim.LBFGS([opt_img_v])opt_img_v, optimizer = get_opt()\n```", "```py\nm_vgg(VV(img_tfm[**None**]))\ntarg_v = V(sf.features.clone())\ntarg_v.shape*torch.Size([1, 512, 36, 36])***def** actn_loss2(x):\n    m_vgg(x)\n    out = V(sf.features)\n    **return** F.mse_loss(out, targ_v)*1000\n```", "```py\nn_iter=0\n**while** n_iter <= max_iter: optimizer.step(partial(step,actn_loss2))*Iteration: n_iter, loss: 0.2112911492586136\nIteration: n_iter, loss: 0.0902421623468399\nIteration: n_iter, loss: 0.05904778465628624\nIteration: n_iter, loss: 0.04517251253128052\nIteration: n_iter, loss: 0.03721420466899872\nIteration: n_iter, loss: 0.03215853497385979\nIteration: n_iter, loss: 0.028526008129119873\nIteration: n_iter, loss: 0.025799645110964775\nIteration: n_iter, loss: 0.02361033484339714\nIteration: n_iter, loss: 0.021835438907146454*\n```", "```py\nx = val_tfms.denorm(np.rollaxis(to_np(opt_img_v.data),1,4))[0]\nplt.figure(figsize=(7,7))\nplt.imshow(x);\n```", "```py\nsf.close()\n```", "```py\nstyle_fn = PATH/'style'/'starry_night.jpg'style_img = open_image(style_fn)\nstyle_img.shape, img.shape((1198, 1513, 3), (291, 483, 3))plt.imshow(style_img);\n```", "```py\n**def** scale_match(src, targ):\n    h,w,_ = img.shape\n    sh,sw,_ = style_img.shape\n    rat = max(h/sh,w/sw); rat\n    res = cv2.resize(style_img, (int(sw*rat), int(sh*rat)))\n    **return** res[:h,:w]style = scale_match(img, style_img)plt.imshow(style)\nstyle.shape, img.shape*((291, 483, 3), (291, 483, 3))*\n```", "```py\nopt_img_v, optimizer = get_opt()\n```", "```py\nsfs = [SaveFeatures(children(m_vgg)[idx]) **for** idx **in** block_ends]\n```", "```py\nstyle_tfm = val_tfms(style_img)\n```", "```py\nm_vgg(VV(style_tfm[**None**]))\ntarg_styles = [V(o.features.clone()) **for** o **in** sfs]\n[o.shape **for** o **in** targ_styles]*[torch.Size([1, 64, 288, 288]),\n torch.Size([1, 128, 144, 144]),\n torch.Size([1, 256, 72, 72]),\n torch.Size([1, 512, 36, 36]),\n torch.Size([1, 512, 18, 18])]*\n```", "```py\n**def** gram(input):\n        b,c,h,w = input.size()\n        x = input.view(b*c, -1)\n        **return** torch.mm(x, x.t())/input.numel()*1e6\n\n**def** gram_mse_loss(input, target): \n        **return** F.mse_loss(gram(input), gram(target))\n```", "```py\n**def** style_loss(x):\n    m_vgg(opt_img_v)\n    outs = [V(o.features) **for** o **in** sfs]\n    losses = [gram_mse_loss(o, s) **for** o,s **in** zip(outs, targ_styles)]\n    **return** sum(losses) \n```", "```py\nn_iter=0\n**while** n_iter <= max_iter: optimizer.step(partial(step,style_loss))*Iteration: n_iter, loss: 230718.453125\nIteration: n_iter, loss: 219493.21875\nIteration: n_iter, loss: 202618.109375\nIteration: n_iter, loss: 481.5616760253906\nIteration: n_iter, loss: 147.41177368164062\nIteration: n_iter, loss: 80.62625122070312\nIteration: n_iter, loss: 49.52326965332031\nIteration: n_iter, loss: 32.36254119873047\nIteration: n_iter, loss: 21.831811904907227\nIteration: n_iter, loss: 15.61091423034668*\n```", "```py\nx = val_tfms.denorm(np.rollaxis(to_np(opt_img_v.data),1,4))[0]\nplt.figure(figsize=(7,7))\nplt.imshow(x);\n```", "```py\n**for** sf **in** sfs: sf.close()\n```", "```py\nopt_img_v, optimizer = get_opt()\n```", "```py\n**def** comb_loss(x):\n    m_vgg(opt_img_v)\n    outs = [V(o.features) **for** o **in** sfs]\n    losses = [gram_mse_loss(o, s) **for** o,s **in** zip(outs, targ_styles)]\n    cnt_loss   = F.mse_loss(outs[3], targ_vs[3])*1000000\n    style_loss = sum(losses)\n    **return** cnt_loss + style_loss\n```", "```py\nn_iter=0\n**while** n_iter <= max_iter: optimizer.step(partial(step,comb_loss))*Iteration: n_iter, loss: 1802.36767578125\nIteration: n_iter, loss: 1163.05908203125\nIteration: n_iter, loss: 961.6024169921875\nIteration: n_iter, loss: 853.079833984375\nIteration: n_iter, loss: 784.970458984375\nIteration: n_iter, loss: 739.18994140625\nIteration: n_iter, loss: 706.310791015625\nIteration: n_iter, loss: 681.6689453125\nIteration: n_iter, loss: 662.4088134765625\nIteration: n_iter, loss: 646.329833984375*x = val_tfms.denorm(np.rollaxis(to_np(opt_img_v.data),1,4))[0]\nplt.figure(figsize=(9,9))\nplt.imshow(x, interpolation='lanczos')\nplt.axis('off');\n```", "```py\n**for** sf **in** sfs: sf.close()\n```"]