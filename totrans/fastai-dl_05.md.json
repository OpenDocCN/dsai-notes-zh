["```py\nratings = pd.read_csv(path+'ratings.csv')\nratings.head()\n```", "```py\ng=ratings.groupby('userId')['rating'].count()\ntopUsers=g.sort_values(ascending=False)[:15]g=ratings.groupby('movieId')['rating'].count()\ntopMovies=g.sort_values(ascending=False)[:15]top_r = ratings.join(topUsers, rsuffix='_r', how='inner', on='userId')\ntop_r = top_r.join(topMovies, rsuffix='_r', how='inner', on='movieId')pd.crosstab(top_r.userId, top_r.movieId, top_r.rating, aggfunc=np.sum)\n```", "```py\nval_idxs = get_cv_idxs(len(ratings)) \nwd = 2e-4 \nn_factors = 50\n```", "```py\ncf = CollabFilterDataset.from_csv(path, 'ratings.csv', 'userId', 'movieId', 'rating')\n```", "```py\nlearn = cf.get_learner(n_factors, val_idxs, 64, opt_fn=optim.Adam)learn.fit(1e-2, 2, wds=wd, cycle_len=1, cycle_mult=2)\n```", "```py\nmath.sqrt(0.765)\n```", "```py\npreds = learn.predict()\n```", "```py\ny = learn.data.val_y\nsns.jointplot(preds, y, kind='hex', stat_func=None)\n```", "```py\na = T([[1., 2], [3, 4]])\nb = T([[2., 2], [10, 10]])\n```", "```py\n(a*b).sum(1)6\n70\n[torch.FloatTensor of size 2]\n```", "```py\nclass DotProduct (nn.Module):\n   def forward(self, u, m): return (u*m).sum(1)\n```", "```py\nmodel = DotProduct()\n**model(a,b)**6\n70\n[torch.FloatTensor of size 2]\n```", "```py\nu_uniq = ratings.userId.unique() \nuser2idx = {o:i **for** i,o **in** enumerate(u_uniq)} \nratings.userId = ratings.userId.apply(**lambda** x: user2idx[x]) m_uniq = ratings.movieId.unique() \nmovie2idx = {o:i **for** i,o **in** enumerate(m_uniq)} \nratings.movieId = ratings.movieId.apply(**lambda** x: movie2idx[x]) n_users=int(ratings.userId.nunique()) n_movies=int(ratings.movieId.nunique())\n```", "```py\nclass EmbeddingDot(nn.Module):\n    def __init__(self, n_users, n_movies):\n        super().__init__()\n        self.u = nn.Embedding(n_users, n_factors)\n        self.m = nn.Embedding(n_movies, n_factors)\n        self.u.weight.data.uniform_(0,0.05)\n        self.m.weight.data.uniform_(0,0.05)\n\n    def forward(self, cats, conts):\n        users,movies = cats[:,0],cats[:,1]\n        u,m = self.u(users),self.m(movies)\n        return (u*m).sum(1)\n```", "```py\nx = ratings.drop(['rating', 'timestamp'],axis=1)\ny = ratings['rating'].astype(np.float32)\ndata = ColumnarModelData.from_data_frame(path, val_idxs, x, y, ['userId', 'movieId'], 64)\n```", "```py\nwd=1e-5\nmodel = EmbeddingDot(n_users, n_movies).cuda()\nopt = optim.SGD(model.parameters(), 1e-1, weight_decay=wd, momentum=0.9)\n```", "```py\nfit(model, data, 3, opt, F.mse_loss)\n```", "```py\nmin_rating,max_rating = ratings.rating.min(),ratings.rating.max()\nmin_rating,max_ratingdef get_emb(ni,nf):\n    e = nn.Embedding(ni, nf)\n    e.weight.data.uniform_(-0.01,0.01)\n    return eclass EmbeddingDotBias(nn.Module):\n    def __init__(self, n_users, n_movies):\n        super().__init__()\n        (self.u, self.m, **self.ub**, **self.mb**) = [get_emb(*o) for o in [\n            (n_users, n_factors), (n_movies, n_factors), (n_users,1), (n_movies,1)\n        ]]\n\n    def forward(self, cats, conts):\n        users,movies = cats[:,0],cats[:,1]\n        um = (self.u(users)* self.m(movies)).sum(1)\n        res = um + **self.ub(users)**.squeeze() + **self.mb(movies)**.squeeze()\n        res = F.sigmoid(res) * (max_rating-min_rating) + min_rating\n        return res\n```", "```py\nwd=2e-4\nmodel = EmbeddingDotBias(cf.n_users, cf.n_items).cuda()\nopt = optim.SGD(model.parameters(), 1e-1, weight_decay=wd, momentum=0.9)fit(model, data, 3, opt, F.mse_loss)\n[ 0\\.       0.85056  0.83742]                                     \n[ 1\\.       0.79628  0.81775]                                     \n[ 2\\.       0.8012   0.80994]\n```", "```py\nclass EmbeddingNet(nn.Module):\n    def __init__(self, n_users, n_movies, **nh**=10, p1=0.5, p2=0.5):\n        super().__init__()\n        (self.u, self.m) = [get_emb(*o) for o in [\n            (n_users, n_factors), (n_movies, n_factors)]]\n        self.lin1 = **nn.Linear**(n_factors*2, nh)\n        self.lin2 = nn.Linear(nh, 1)\n        self.drop1 = nn.Dropout(p1)\n        self.drop2 = nn.Dropout(p2)\n\n    def forward(self, cats, conts):\n        users,movies = cats[:,0],cats[:,1]\n        x = self.drop1(torch.cat([self.u(users),self.m(movies)], dim=1))\n        x = self.drop2(F.relu(self.lin1(x)))\n        return F.sigmoid(self.lin2(x)) * (max_rating-min_rating+1) + min_rating-0.5\n```", "```py\nwd=1e-5\nmodel = EmbeddingNet(n_users, n_movies).cuda()\nopt = optim.Adam(model.parameters(), 1e-3, weight_decay=wd)\nfit(model, data, 3, opt, **F.mse_loss**)A Jupyter Widget[ 0\\.       0.88043  0.82363]                                    \n[ 1\\.       0.8941   0.81264]                                    \n[ 2\\.       0.86179  0.80706]\n```", "```py\nopt = optim.SGD(model.parameters(), 1e-1, weight_decay=wd, momentum=0.9)\n```", "```py\navg_loss = avg_loss * avg_mom + loss * (1-avg_mom)\n```"]